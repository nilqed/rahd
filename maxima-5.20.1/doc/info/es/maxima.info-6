This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Ver. 5.20 Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Funciones y variables de valores descriptivos multivariantes,  Next: Funciones y variables para gráficos estadísticos,  Prev: Funciones y variables de valores descriptivos,  Up: descriptive

45.4 Funciones y variables de valores descriptivos multivariantes
=================================================================

 -- Función: cov (<matrix>)
     Es la matriz de covarianzas de una muestra multivariante, definida
     como
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1

     siendo X_j la j-ésima fila de la matriz muestral.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$  /* change precision for pretty output */
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o4) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]
          (%i5) cov (s2);

     Véase también `cov1'.

 -- Función: cov1 (<matrix>)
     Es la matriz de cuasivarianzas de una muestra multivariante,
     definida como
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1

     siendo X_j la j-ésima fila de la matriz muestral.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$ /* change precision for pretty output */
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o4) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]
          (%i5) cov1 (s2);

     Véase también `cov'.

 -- Función: global_variances (<matrix>)
 -- Función: global_variances (<matrix>, <logical_value>)
     La función `global_variances' devuelve una lista de medidas
     globales de variabilidad:

        * <varianza total>: `trace(S_1)',

        * <varianza media>: `trace(S_1)/p',

        * <varianza generalizada>: `determinant(S_1)',

        * <desviación típica generalizada>: `sqrt(determinant(S_1))',

        * <varianza efectiva> `determinant(S_1)^(1/p)', (definida en:
          Peña, D. (2002) <Análisis de datos multivariantes>;
          McGraw-Hill, Madrid.)

        * <desviación típica efectiva>: `determinant(S_1)^(1/(2*p))'.
     donde <p> es la dimensión de la variable aleatoria multivariante y
     S_1 la matriz de covarianzas devuelta por la función `cov1'.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) global_variances (s2);
          (%o3) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     La función `global_variances' tiene un argumento lógico opcional:
     `global_variances(x,true)' indica a Maxima que `x' es la matriz de
     datos, calculando entonces lo mismo que `global_variances(x)'. Por
     otro lado, `global_variances(x,false)' significa que  `x' no es la
     matriz de datos, sino la de covarianzas, evitando así recalcularla,

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) s : cov1 (s2)$
          (%i4) global_variances (s, false);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     Véanse también `cov' y `cov1'.

 -- Función: cor (<matrix>)
 -- Función: cor (<matrix>, <logical_value>)
     Es la matriz de correlaciones de la muestra multivariante.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) fpprintprec:7$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o4) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     La función `cor' tiene un argumento lógico opcional: `cor(x,true)'
     indica a Maxima que `x' es la matriz de datos, calculando entonces
     lo mismo que `cor(x)'. Por otro lado, `cor(x,false)' significa que
     `x' no es la matriz de datos, sino la de covarianzas, evitando
     así recalcularla,

          (%i1) load (descriptive)$
          (%i2) fpprintprec:7$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) cor (s, false); /* this is faster */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Véanse también `cov' y `cov1'.

 -- Función: list_correlations (<matrix>)
 -- Función: list_correlations (<matrix>, <logical_value>)
     La función `list_correlations' devuelve una lista con medidas de
     correlación:

        * <matriz de precisión>: es la inversa de la matriz de
          covarianzas S_1,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        * <multiple correlation vector>:  (R_1^2, R_2^2, ..., R_p^2),
          with
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          es un indicador de la bondad de ajuste del modelo de
          regresión lineal multivariante de X_i cuando el resto de
          variables se utilizan como regresores.

        * <matriz de correlaciones parciales>: en la que el elemento
          (i, j) es
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /


     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) z : list_correlations (s2)$
          (%i4) fpprintprec : 5$ /* for pretty output */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o5) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%o6)       [.85063, .80634, .86474, .71867, .72675]
                 [  - 1.0     .38244   .36627   .49908   - .13049 ]
                 [                                                ]
                 [  .38244    - 1.0    .37927  - .19907   .23492  ]
                 [                                                ]
          (%o7)  [  .36627    .37927   - 1.0    .10911    .37956  ]
                 [                                                ]
                 [  .49908   - .19907  .10911   - 1.0     .26719  ]
                 [                                                ]
                 [ - .13049   .23492   .37956   .26719    - 1.0   ]

     La función `list_correlations' tiene un argumento lógico opcional:
     `list_correlations(x,true)' indica a Maxima que `x' es la matriz
     de datos, calculando entonces lo mismo que `list_correlations(x)'.
     Por otro lado, `list_correlations(x,false)' significa que  `x' no
     es la matriz de datos, sino la de covarianzas, evitando así
     recalcularla.

     Véanse también `cov' y `cov1'.


File: maxima.info,  Node: Funciones y variables para gráficos estadísticos,  Prev: Funciones y variables de valores descriptivos multivariantes,  Up: descriptive

45.5 Funciones y variables para gráficos estadísticos
=====================================================

 -- Función: histogram (<list>)
 -- Función: histogram (<list>, <option_1>, <option_2>, ...)
 -- Función: histogram (<one_column_matrix>)
 -- Función: histogram (<one_column_matrix>, <option_1>, <option_2>,
          ...)
 -- Función: histogram (<one_row_matrix>)
 -- Función: histogram (<one_row_matrix>, <option_1>, <option_2>, ...)
     Esta función dibuja el histograma de una muestra de variable
     continua.  Los datos muestrales se deben almacenar en una lista de
     números o en una matriz unidimensional.

     Opciones disponibles:

        * Las definidas en el paquete `draw'. Véanse también `bars' y
          `barsplot'.

        * <nclasses>: número de clases del histograma (por defecto, 10).

     Véanse también `discrete_freq' y `continuous_freq' para recuentos,
     y `bars' y `barsplot' para representar gráficos.

     Ejemplos:

     Un histograma de ocho clases.

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) histogram (
               s1,
               nclasses     = 8,
               title        = "pi digits",
               xlabel       = "digits",
               ylabel       = "Absolute frequency",
               fill_color   = grey,
               fill_density = 0.6)$

 -- Función: scatterplot (<list>)
 -- Función: scatterplot (<list>, <option_1>, <option_2>, ...)
 -- Función: scatterplot (<matrix>)
 -- Función: scatterplot (<matrix>, <option_1>, <option_2>, ...)
     Dibuja diagramas de dispersión, tanto de muestras univariantes
     (<list>) como multivariantes (<matrix>).

     Opciones disponibles:

        * Las definidas en el paquete `draw'.

        * <nclasses>: número de clases del histograma (por defecto, 10).

     Ejemplos:

     Diagrama de dispersión univariante a partir de una muestra normal
     simulada.

          (%i1) load (descriptive)$
          (%i2) load (distrib)$
          (%i3) scatterplot(
            random_normal(0,1,200),
            xaxis      = true,
            point_size = 2,
            terminal   = eps,
            eps_width  = 10,
            eps_height = 2)$

     Diagrama de dispersión bidimensional.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
           submatrix(s2, 1,2,3),
           title      = "Data from stations #4 and #5",
           point_type = diamant,
           point_size = 2,
           color      = blue)$

     Diagrama de dispersión tridimensional.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(submatrix (s2, 1,2))$

     Diagrama de dispersión de cinco dimensiones, con histogramas de
     cinco classes.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
            s2,
            nclasses     = 5,
            fill_color   = blue,
            fill_density = 0.3,
            xtics        = 5)$

     Para dibujar puntos aislados o unidos por segmentos, tanto en dos
     como en tres dimensiones, véase `points'.  Para las opciones
     relacionadas con los histogramas, véase `bars'.

     Véase también `histogram'.

 -- Función: barsplot (<data1>, <data2>, ..., <option_1>, <option_2>,
          ...)
     Dibuja diagramas de barras para variables estadísticas discretas,
     tanto para una como para más muestras.

     <data> puede ser una lista de resultados provenientes de una
     muestra o una matriz de <m> filas y <n> columnas, representando <n>
     muestras de tamaño <m> cada una.

     Las opciones disponibles son:

        * Las definidas en el paquete `draw'.

        * <box_width>: ancho relativo de los rectángulos (`3/4' por
          defecto). Este valor debe pertenecer al rango `[0,1]'.

        * <groups_gap>: un número positivo que representa la separación
          entre dos grupos consecutivos de barras. El valor por defecto
          es 1.

        * <bars_colors>: una lista de colores para múltiples muestras.
          El valor por defecto es la lista vacía `[]'. Cuando el número
          de muestras sea mayor que el de colores especificados, los
          colores adicionales necesarios se seleccionan aleatoriamente.
          Véase `color' para más información.

        * <relative_frequencies>: si vale `false', se utilizarán
          frecuencias absolutas; si vale `true', las marcas del eje-<y>
          serán frecuencias relativas. El valor por defecto es `false'.

        * <ordering>: los valores admitidos para esta opción son:
          `orderlessp' y `ordergreatp', indicando cómo se deben ordenar
          los resultados muestrales sobre el eje-<x>. El valor por
          defecto es `orderlessp'.

        * <sample_keys>: es una lista de cadenas de texto a usar como
          leyendas.  Su valor por defecto es la lista vacía `[]'.
          Cuando la lista tenga una longitud diferente de cero o del
          número de muestras, se devolverá un mensaje de error.


     Ejemplos:

     Muestra univariante en formato matricial. Frecuencias absolutas.

          (%i1) load (descriptive)$
          (%i2) m : read_matrix (file_search ("biomed.data"))$
          (%i3) barsplot(
                  col(m,2),
                  title        = "Ages",
                  xlabel       = "years",
                  box_width    = 1/2,
                  fill_density = 3/4)$

     Dos muestras de diferente tamaño, con frecuencias relativas y
     colores definidos por el usuario.

          (%i1) load (descriptive)$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) barsplot(
                  l1,l2,
                  box_width    = 1,
                  fill_density = 1,
                  bars_colors  = [black, grey],
                  relative_frequencies = true,
                  sample_keys = ["A", "B"])$

     Cuatro muestras no numéricas de igual tamaño.

          (%i1) load (descriptive)$
          (%i2) barsplot(
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  title  = "Asking for something to four groups",
                  ylabel = "# of individuals",
                  groups_gap   = 3,
                  fill_density = 0.5,
                  ordering     = ordergreatp)$

     `barsplot' en un contexto multiplot.

          (%i1) load (descriptive)$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) draw_compound : false $
          (%i5) bp1 :
                  barsplot(
                   l1,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [blue],
                   relative_frequencies = true)$
          (%i6) bp2 :
                  barsplot(
                   l2,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [red],
                   relative_frequencies = true)$
          (%i7) draw(apply(gr2d,bp1),
                     apply(gr2d,bp2)) $

     Para las opciones relacionadas con los diagramas de barras, véase
     `bars' del paquete `draw'.

     Véanse también las funciones `histogram' y `piechart'.

 -- Función: piechart (<list>)
 -- Función: piechart (<list>, <option_1>, <option_2>, ...)
 -- Función: piechart (<one_column_matrix>)
 -- Función: piechart (<one_column_matrix>, <option_1>, <option_2>, ...)
 -- Función: piechart (<one_row_matrix>)
 -- Función: piechart (<one_row_matrix>, <option_1>, <option_2>, ...)
     Similar a `barsplot', pero dibuja sectores en lugar de rectángulos.

     Opciones disponibles:

        * Las definidas en el paquete `draw'.

        * <pie_center>: centro del diagrama (por defecto, `[0,0]').

        * <pie_radius>: radio del diagrama (por defecto, 1).

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) piechart(
            s1,
            xrange      = [-1.1, 1.3],
            yrange      = [-1.1, 1.1],
            axis_top    = false,
            axis_right  = false,
            axis_left   = false,
            axis_bottom = false,
            xtics       = none,
            ytics       = none,
            title       = "Digit frequencies in pi")$

     Véase también la función `barsplot'.

 -- Función: boxplot (<data>)
 -- Función: boxplot (<data>, <option_1>, <option_2>, ...)
     Dibuja diagramas de cajas (box-and-whishker). El argumento <data>
     puede ser una lista, lo cual no es de gran interés, puesto que
     estos gráficos se utilizan principalmente para comparar distintas
     muestras, o una matriz, de manera que sea posible comparar dos o
     más componentes de una muestra multivariante. También se permite
     que <data> sea una lista de muestras con posibles tamaños
     diferentes; de hecho, esta es la única función del paquete
     `descriptive' que admite esta estructura de datos.

     Opciones disponibles:

        * Las definidas en el paquete `draw'.

        * <box_width>: ancho relativo de las cajas (por defecto,
          `3/4'). Este valor debe estar en el rango `[0,1]'.

     Ejemplos:

     Diagrama de cajas de una muestra multivariante.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix(file_search("wind.data"))$
          (%i3) boxplot(s2,
            box_width  = 0.2,
            title      = "Windspeed in knots",
            xlabel     = "Stations",
            color      = red,
            line_width = 2)$

     Diagrama de cajas de tres muestras de tamaños diferentes.

          (%i1) load (descriptive)$
          (%i2) A :
           [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
            [8, 10, 7, 9, 12, 8, 10],
            [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i3) boxplot (A)$


File: maxima.info,  Node: diag,  Next: distrib,  Prev: descriptive,  Up: Top

46 diag
*******

* Menu:

* Funciones y variables para diag::


File: maxima.info,  Node: Funciones y variables para diag,  Prev: diag,  Up: diag

46.1 Funciones y variables para diag
====================================

 -- Función: diag (<lm>)
     Genera una matriz cuadrada con las matrices de <lm> en la
     diagonal, siendo <lm> una lista de matrices o de escalares.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$

          (%i3) a2:matrix([1,1],[1,0])$

          (%i4) diag([a1,x,a2]);
                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.

 -- Función: JF (<lambda>,<n>)
     Devuelve la célula de Jordan de orden  <n> con valor propio
     <lambda>.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) JF(2,5);
                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]
          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.

 -- Función: jordan (<mat>)
     Devuelve la forma de Jordan de la matriz <mat>, pero en formato de
     lista de Maxima. Para obtener la matriz correspondiente, llámese a
     la función `dispJordan' utilizando como argumento la salida de
     `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$

          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `dispJordan' y `minimalPoly'.

 -- Función: dispJordan (<l>)
     Devuelve la matriz de Jordan asociada a la codificación dada por
     la lista <l>, que habitualmente será la salida de la función
     `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `jordan' y `minimalPoly'.

 -- Función: minimalPoly (<l>)
     Devuelve el polinomio mínimo asociado a la codificación dada por
     la lista <l>, que habitualmente será la salida de la función
     `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `jordan' y `dispJordan'.

 -- Función: ModeMatrix (<A>,<l>)
     Devuelve la matriz <M> tal que (M^^-1).A.M=J, donde <J> es la
     forma de Jordan de <A>. La lista <l> es la forma codificada de la
     forma de Jordan tal como la devuelve la función `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);
                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]
          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true
     Nótese que `dispJordan(%o3)' es la forma de Jordan de la matriz
     `a'.

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `jordan' y `dispJordan'.

 -- Función: mat_function (<f>,<mat>)
     Devuelve  f(mat), siendo <f> una función analítica y <mat> una
     matriz. Este cálculo se basa en la fórmula integral de Cauchy, que
     establece que si `f(x)' es analítica y
          mat=diag([JF(m1,n1),...,JF(mk,nk)]),

     entonces

          f(mat)=ModeMatrix*diag([f(JF(m1,n1)),...,f(JF(mk,nk))])
                    * ModeMatrix^^(-1)

     Nótese que hay otros métodos alternativos para realizar este
     cálculo.

     Se presentan algunos ejemplos.

     Ejemplo 1:
          (%i1) load("diag")$

          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$

          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t
          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]
                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]
                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Ejemplo 2:
          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i7) minimalPoly(jordan(b1));
                                       3
          (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
          (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Ejemplo 3:
          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$

          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$

          (%i13) mat_function(fpow,a1);
                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.


File: maxima.info,  Node: distrib,  Next: draw,  Prev: diag,  Up: Top

47 distrib
**********

* Menu:

* Introducción a distrib::
* Funciones y variables para distribuciones continuas::
* Funciones y variables para distribuciones discretas::


File: maxima.info,  Node: Introducción a distrib,  Next: Funciones y variables para distribuciones continuas,  Prev: distrib,  Up: distrib

47.1 Introducción a distrib
===========================

El paquete `distrib' contiene un conjunto de funciones para la
realización de cálculos probabilísticos con modelos univariantes, tanto
discretos como continuos.

   A continuación un breve recordatorio de las deficiones básicas sobre
distribuciones de probabilidad.

   Sea f(x) la <función de densidad> de una variable aleatoria X
absolutamente continua. La <función de distribución> se define como
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
   que es igual a la probabilidad <Pr(X <= x)>.

   La <media> es un parámetro de localización y se define como
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

   La  <varianza> es una medida de dispersión,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
   que es un número real positivo. La raíz cuadrada de la varianza es
la <desviación típica>, D[X]=sqrt(V[X]), siendo otra medida de
dispersión.

   El <coeficiente de asimetría> es una medida de forma,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

   Y el <coeficiente de curtosis> mide el apuntamiento de la densidad,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
   Si X es normal, KU[X]=0. De hecho, tanto la asimetría como la
curtosis son parámetros de forma para medir la no normalidad de una
distribución.

   Si la variable aleatoria X es discreta, su función de densidad, o de
<probabiliad>,  f(x) toma valores positivos dentro de un conjunto
numerable de valores x_i, y cero en cualquier otro lugar. En este caso,
la función de distribución es
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

   La media, varianza, desviación típica y los coeficientes de
asimetría y curtosis adquieren las formas
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
   y
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
   respectivamente.

   Por favor, consúltese cualquier manual introductorio de probabilidad
y estadística para más información sobre toda esta parafernalia
matemática.

   Se sigue cierta convención a la hora de nombrar las funciones del
paquete `distrib'. Cada nombre tiene dos partes, el primero hace
referencia a la función o parámetro que se quiere calcular,
     Funciones:
        Función de densidad        (pdf_*)
        Función de distribución    (cdf_*)
        Cuantil                    (quantile_*)
        Media                      (mean_*)
        Varianza                   (var_*)
        Desviación típica          (std_*)
        Coeficiente de asimetría   (skewness_*)
        Coeficiente de curtosis    (kurtosis_*)
        Valor aleatorio            (random_*)

   La segunda parte hace referencia explícita al modelo probabilístico,
     Distribuciones continuas:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        Chi^2 no central    (*noncentral_chi2)
        F                   (*f)
        Exponencial         (*exp)
        Lognormal           (*lognormal)
        Gamma               (*gamma)
        Beta                (*beta)
        Continua uniforme   (*continuous_uniform)
        Logística           (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Distribuciones discretas:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geométrica           (*geometric)
        Uniforme discreta    (*discrete_uniform)
        Hipergeométrica      (*hypergeometric)
        Binomial negativa    (*negative_binomial)

   Por ejemplo, `pdf_student_t(x,n)' es la función de densidad de la
distribución de Student con <n> grados de libertad, `std_pareto(a,b)'
es la desviación típica de la distribución de Pareto de parámetros <a>
y <b>, y `kurtosis_poisson(m)' es el coeficiente de curtosis de la
distribución de Poisson de media <m>.

   Para poder hacer uso del paquete `distrib' es necesario cargarlo
primero tecleando
     (%i1) load(distrib)$

   Para comentarios, errores o sugerencias, por favor contáctese
conmigo en <'mario ARROBA edu PUNTO xunta PUNTO es'>.


File: maxima.info,  Node: Funciones y variables para distribuciones continuas,  Next: Funciones y variables para distribuciones discretas,  Prev: Introducción a distrib,  Up: distrib

47.2 Funciones y variables para distribuciones continuas
========================================================

 -- Función: pdf_normal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de la variable aleatoria Normal(m,s), con s>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_normal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de la variable aleatoria Normal(m,s), con s>0. Esta
     función se define en términos de la función de error,  `erf', de
     Maxima.

          (%i1) load (distrib)$
          (%i2) assume(s>0)$ cdf_normal(x,m,s);
                                       x - m
                                 erf(---------)
                                     sqrt(2) s    1
          (%o3)                  -------------- + -
                                       2          2

     Véase también `erf'.

 -- Función: quantile_normal (<q>,<m>,<s>)
     Devuelve el <q>-cuantil de una variable aleatoria Normal(m,s), con
     s>0; en otras palabras, es la inversa de  `cdf_normal'. El
     argumento <q> debe ser un número de [0,1]. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) quantile_normal(95/100,0,1);
                                                9
          (%o2)             sqrt(2) inverse_erf(--)
                                                10
          (%i3) float(%);
          (%o3)               1.644853626951472


 -- Función: mean_normal (<m>,<s>)
     Devuelve la media de  una variable aleatoria Normal(m,s), con s>0,
     es decir <m>. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_normal (<m>,<s>)
     Devuelve la varianza de  una variable aleatoria Normal(m,s), con
     s>0, es decir <s^2>.

 -- Función: std_normal (<m>,<s>)
     Devuelve la desviación típica de  una variable aleatoria
     Normal(m,s), con s>0, es decir <s>. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: skewness_normal (<m>,<s>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Normal(m,s), con s>0, que es siempre igual a 0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_normal (<m>,<s>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Normal(m,s), con s>0, que es siempre igual a 0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: random_normal (<m>,<s>)
 -- Función: random_normal (<m>,<s>,<n>)
     Devuelve un valor aleatorio  Normal(m,s), con s>0. Llamando a
     `random_normal' con un tercer argumento <n>, se simula una muestra
     aleatoria de tamaño <n>.

     El algoritmo de simulación es el de Box-Mueller, tal como está
     descrito en Knuth, D.E. (1981) <Seminumerical Algorithms. The Art
     of Computer Programming.> Addison-Wesley.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_student_t (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Student t(n), con n>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_student_t (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Student t(n), con n>0.

          (%i1) load (distrib)$
          (%i2) cdf_student_t(1/2, 7/3);
                                                   7  1  28
                       beta_incomplete_regularized(-, -, --)
                                                   6  2  31
          (%o2)    1 - -------------------------------------
                                         2
          (%i3) float(%);
          (%o3)                .6698450596140415

 -- Función: quantile_student_t (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria de Student t(n),
     con n>0; en otras palabras, se trata de la inversa de
     `cdf_student_t'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_student_t (<n>)
     Devuelve la media de una variable aleatoria de Student t(n), con
     n>0, que vale siempre 0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: var_student_t (<n>)
     Devuelve la varianza de una variable aleatoria de Student t(n),
     con n>2.

          (%i1) load (distrib)$
          (%i2) assume(n>2)$  var_student_t(n);
                                          n
          (%o3)                         -----
                                        n - 2

 -- Función: std_student_t (<n>)
     Devuelve la desviación típica de una variable aleatoria de Student
     t(n), con n>2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: skewness_student_t (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Student t(n), con n>3, que vale siempre 0. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_student_t (<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Student t(n), con n>4. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_student_t (<n>)
 -- Función: random_student_t (<n>,<m>)
     Devuelve un valor aleatorio t(n), con n>0. Llamando a
     `random_student_t' con un segundo argumento <m>, se obtiene una
     muestra aleatoria simulada de tamaño <m>.

     El algoritmo utilizado está basado en el hecho de que si <Z> es
     una variable aleatoria normal N(0,1) y S^2 es una chi cuadrada de
     <n> grados de libertad, Chi^2(n), entonces
                                     Z
                           X = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /

     es una variable aleatoria de Student de <n> grados de libertad,
     t(n).

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_noncentral_student_t (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria no central de Student nc_t(n,ncp), con
     n>0 grados de libertad y parámetro de no centralidad ncp. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

     En ocasiones es necesario hacer algún trabajo extra para obtener
     el resultado final.

          (%i1) load (distrib)$
          (%i2) expand(pdf_noncentral_student_t(3,5,0.1));
                 .01370030107589574 sqrt(5)
          (%o2)  --------------------------
                 sqrt(2) sqrt(14) sqrt(%pi)
             1.654562884111515E-4 sqrt(5)
           + ----------------------------
                      sqrt(%pi)
             .02434921505438663 sqrt(5)
           + --------------------------
                        %pi
          (%i3) float(%);
          (%o3)          .02080593159405669

 -- Función: cdf_noncentral_student_t (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria no central de Student
     nc_t(n,ncp), con n>0 grados de libertad y parámetro de no
     centralidad ncp. Esta función no tiene expresión compacta y se
     calcula numéricamente si la variable global `numer' vale `true' o
     si alguno de sus argumentos es un número decimal, en otro caso
     devuelve una expresión nominal.  Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) cdf_noncentral_student_t(-2,5,-5);
          (%o2) cdf_noncentral_student_t(- 2, 5, - 5)
          (%i3) cdf_noncentral_student_t(-2.0,5,-5);
          (%o3)          .9952030093319743


 -- Función: quantile_noncentral_student_t (<q>,<n>,<ncp>)
     Devuelve el <q>-cuantil de una variable aleatoria no central de
     Student nc_t(n,ncp), con n>0 grados de libertad y parámetro de no
     centralidad ncp; en otras palabras, se trata de la inversa de
     `cdf_noncentral_student_t'. El argumento <q> debe ser un número de
     [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_noncentral_student_t (<n>,<ncp>)
     Devuelve la media de una variable aleatoria no central de Student
     nc_t(n,ncp), con n>1 grados de libertad y parámetro de no
     centralidad ncp. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) (assume(df>1), mean_noncentral_student_t(df,k));
                             df - 1
                       gamma(------) sqrt(df) k
                               2
          (%o2)        ------------------------
                                        df
                          sqrt(2) gamma(--)
                                        2


 -- Función: var_noncentral_student_t (<n>,<ncp>)
     Devuelve la varianza de una variable aleatoria no central de
     Student nc_t(n,ncp), con n>2 grados de libertad y parámetro de no
     centralidad ncp. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_noncentral_student_t (<n>,<ncp>)
     Devuelve la desviación típica de una variable aleatoria no central
     de Student nc_t(n,ncp), con n>2 grados de libertad y parámetro de
     no centralidad ncp. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_noncentral_student_t (<n>,<ncp>)
     Devuelve el coeficiente de asimetría de una variable aleatoria no
     central de Student nc_t(n,ncp), con n>3 grados de libertad y
     parámetro de no centralidad ncp. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_noncentral_student_t (<n>,<ncp>)
     Devuelve el coeficiente de curtosis de una variable aleatoria no
     central de Student nc_t(n,ncp), con n>4 grados de libertad y
     parámetro de no centralidad ncp. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_noncentral_student_t (<n>,<ncp>)
 -- Función: random_noncentral_student_t (<n>,<ncp>,<m>)
     Devuelve un valor aleatorio nc_t(n,ncp), con n>0. Llamando a
     `random_noncentral_student_t' con un tercer argumento <m>, se
     obtiene una muestra aleatoria simulada de tamaño <m>.

     El algoritmo utilizado está basado en el hecho de que si <X> es
     una variable aleatoria normal N(ncp,1) y S^2 es una chi cuadrada
     de <n> grados de libertad, Chi^2(n), entonces
                                     X
                           U = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /

     es una variable aleatoria no central de Student de <n> grados de
     libertad y parámetro de no centralidad ncp, nc_t(n,ncp).

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_chi2 (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria chi-cuadrado Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la función de
     densidad de la gamma.

          (%i1) load (distrib)$
          (%i2) pdf_chi2(x,n);
                                              n
          (%o2)                  pdf_gamma(x, -, 2)
                                              2
          (%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o4)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2

 -- Función: cdf_chi2 (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria chi-cuadrado Chi^2(n), con
     n>0.

          (%i1) load (distrib)$
          (%i2) cdf_chi2(3,4);
                                                         3
          (%o2)      1 - gamma_incomplete_regularized(2, -)
                                                         2
          (%i3) float(%);
          (%o3)               .4421745996289256

 -- Función: quantile_chi2 (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria Chi^2(n), con
     n>0; en otras palabras, se trata de la inversa de  `cdf_chi2'. El
     argumento <q> debe ser un número de [0,1].

     Esta función no tiene expresión compacta y se calcula
     numéricamente si la variable global `numer' vale `true', en otro
     caso devuelve una expresión nominal basada en la función cuantil
     de la gamma, puesto que la variable aleatoria Chi^2(n) equivale a
     una Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194
          (%i3) quantile_chi2(0.99,n);
                                                  n
          (%o3)              quantile_gamma(0.99, -, 2)
                                                  2

 -- Función: mean_chi2 (<n>)
     Devuelve la media de  una variable aleatoria  Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la media de la
     gamma.

          (%i1) load (distrib)$
          (%i2) mean_chi2(n);
                                             n
          (%o2)                   mean_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ mean_chi2(n);
          (%o4)                           n

 -- Función: var_chi2 (<n>)
     Devuelve la varianza de  una variable aleatoria  Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la varianza de la
     gamma.

          (%i1) load (distrib)$
          (%i2) var_chi2(n);
                                             n
          (%o2)                    var_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ var_chi2(n);
          (%o4)                          2 n

 -- Función: std_chi2 (<n>)
     Devuelve la desviación típica de  una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la desviación
     típica de la gamma.

          (%i1) load (distrib)$
          (%i2) std_chi2(n);
                                             n
          (%o2)                    std_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ std_chi2(n);
          (%o4)                    sqrt(2) sqrt(n)

 -- Función: skewness_chi2 (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en el coeficiente de
     asimetría de la gamma.

          (%i1) load (distrib)$
          (%i2) skewness_chi2(n);
                                               n
          (%o2)                 skewness_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ skewness_chi2(n);
                                      2 sqrt(2)
          (%o4)                       ---------
                                       sqrt(n)

 -- Función: kurtosis_chi2 (<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en el coeficiente de
     curtosis de la gamma.

          (%i1) load (distrib)$
          (%i2) kurtosis_chi2(n);
                                               n
          (%o2)                 kurtosis_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ kurtosis_chi2(n);
                                         12
          (%o4)                          --
                                         n

 -- Función: random_chi2 (<n>)
 -- Función: random_chi2 (<n>,<m>)
     Devuelve un valor aleatorio  Chi^2(n), con n>0. Llamando a
     `random_chi2' con un segundo argumento <m>, se simulará una
     muestra aleatoria de tamaño <m>.

     La simulación está basada en el algoritmo de Ahrens-Cheng. Véase
     `random_gamma' para más detalles.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_noncentral_chi2 (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria chi-cuadrado no centrada
     nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad ncp>=0.
     Para hacer uso de esta función ejecútese primero `load(distrib)'.


 -- Función: cdf_noncentral_chi2 (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria chi-cuadrado no centrada
     nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad ncp>=0.


 -- Función: quantile_noncentral_chi2 (<q>,<n>,<ncp>)
     Devuelve el <q>-cuantil de una variable aleatoria chi-cuadrado no
     centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0; en otras palabras, se trata de la inversa de
     `cdf_noncentral_chi2'. El argumento <q> debe ser un número de
     [0,1].

     Esta función no tiene expresión compacta y se calcula
     numéricamente si la variable global `numer' vale `true', en otro
     caso devuelve una expresión nominal.


 -- Función: mean_noncentral_chi2 (<n>,<ncp>)
     Devuelve la media de  una variable aleatoria chi-cuadrado no
     centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0.


 -- Función: var_noncentral_chi2 (<n>,<ncp>)
     Devuelve la varianza de  una variable aleatoria chi-cuadrado no
     centrada  nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0.


 -- Función: std_noncentral_chi2 (<n>,<ncp>)
     Devuelve la desviación típica de  una variable aleatoria
     chi-cuadrado no centrada  nc_Chi^2(n,ncp), con n>0 y parámetro de
     no centralidad ncp>=0.


 -- Función: skewness_noncentral_chi2 (<n>,<ncp>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     chi-cuadrado no centrada  nc_Chi^2(n,ncp), con n>0 y parámetro de
     no centralidad ncp>=0.


 -- Función: kurtosis_noncentral_chi2 (<n>,<ncp>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     chi-cuadrado no centrada nc_Chi^2(n,ncp), con n>0 y parámetro de
     no centralidad ncp>=0.


 -- Función: random_noncentral_chi2 (<n>,<ncp>)
 -- Función: random_noncentral_chi2 (<n>,<ncp>,<m>)
     Devuelve un valor aleatorio  nc_Chi^2(n,ncp), con n>0 y parámetro
     de no centralidad ncp>=0. Llamando a `random_noncentral_chi2' con
     un tercer argumento <m>, se simulará una muestra aleatoria de
     tamaño <m>.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.


 -- Función: pdf_f (<x>,<m>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria  F(m,n), con m,n>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_f (<x>,<m>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria  F(m,n), con m,n>0.

          (%i1) load (distrib)$
          (%i2) cdf_f(2,3,9/4);
                                                   9  3  3
          (%o2)    1 - beta_incomplete_regularized(-, -, --)
                                                   8  2  11
          (%i3) float(%);
          (%o3)                 0.66756728179008

 -- Función: quantile_f (<q>,<m>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria  F(m,n), con
     m,n>0; en otras palabras, se trata de la inversa de  `cdf_f'. El
     argumento <q> debe ser un número de [0,1].

     Esta función no tiene expresión compacta, por lo que es evaluada
     numéricamente si la variable global `numer' vale `true', en caso
     contrario devuelve una forma nominal.

          (%i1) load (distrib)$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693

 -- Función: mean_f (<m>,<n>)
     Devuelve la media de  una variable aleatoria  F(m,n), con m>0,
     n>2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_f (<m>,<n>)
     Devuelve la varianza de  una variable aleatoria  F(m,n), con m>0,
     n>4. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_f (<m>,<n>)
     Devuelve la desviación típica de  una variable aleatoria  F(m,n),
     con m>0, n>4. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: skewness_f (<m>,<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     F(m,n), con m>0, n>6. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_f (<m>,<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     F(m,n), con m>0, n>8. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_f (<m>,<n>)
 -- Función: random_f (<m>,<n>,<k>)
     Devuelve un valor aleatorio  F(m,n), con m,n>0. Llamando a
     `random_f' con un tercer argumento <k>, se simulará una muestra
     aleatoria de tamaño <k>.

     El algoritmo de simulación está basado en el hecho de que si <X>
     es una variable aleatoria Chi^2(m) y Y es una Chi^2(n), entonces
                                  n X
                              F = ---
                                  m Y

     es una variable aleatoria F con <m> y <n> grados de libertad,
     F(m,n).

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_exp (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la densidad de Weibull.

          (%i1) load (distrib)$
          (%i2) pdf_exp(x,m);
                                                  1
          (%o2)                 pdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                          - m x
          (%o4)                       m %e

 -- Función: cdf_exp (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la distribución de Weibull.

          (%i1) load (distrib)$
          (%i2) cdf_exp(x,m);
                                                  1
          (%o2)                 cdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                           - m x
          (%o4)                      1 - %e

 -- Función: quantile_exp (<q>,<m>)
     Devuelve el <q>-cuantil de una variable aleatoria Exponencial(m),
     con m>0; en otras palabras, se trata de la inversa de  `cdf_exp'.
     El argumento <q> debe ser un número de [0,1].

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en el cuantil de la Weibull.

          (%i1) load (distrib)$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m

 -- Función: mean_exp (<m>)
     Devuelve la media de  una variable aleatoria Exponencial(m), con
     m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la media de la Weibull.

          (%i1) load (distrib)$
          (%i2) mean_exp(m);
                                                 1
          (%o2)                  mean_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  mean_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Función: var_exp (<m>)
     Devuelve la varianza de  una variable aleatoria Exponencial(m),
     con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la varianza de la Weibull.

          (%i1) load (distrib)$
          (%i2) var_exp(m);
                                                 1
          (%o2)                   var_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  var_exp(m);
                                         1
          (%o4)                          --
                                          2
                                         m

 -- Función: std_exp (<m>)
     Devuelve la desviación típica de  una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la desviación típica de la Weibull.

          (%i1) load (distrib)$
          (%i2) std_exp(m);
                                                 1
          (%o2)                   std_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  std_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Función: skewness_exp (<m>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en el coeficiente de asimetría de la Weibull.

          (%i1) load (distrib)$
          (%i2) skewness_exp(m);
                                                   1
          (%o2)                skewness_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  skewness_exp(m);
          (%o4)                           2

 -- Función: kurtosis_exp (<m>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en el coeficiente de curtosis de la Weibull.

          (%i1) load (distrib)$
          (%i2) kurtosis_exp(m);
                                                   1
          (%o2)                kurtosis_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  kurtosis_exp(m);
          (%o4)                           6

 -- Función: random_exp (<m>)
 -- Función: random_exp (<m>,<k>)
     Devuelve un valor aleatorio  Exponencial(m), con m>0. Llamando a
     `random_exp2' con un segundo argumento <k>, se simulará una
     muestra aleatoria de tamaño <k>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_lognormal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Lognormal(m,s), con s>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_lognormal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Lognormal(m,s), con s>0.
     Esta función se define en términos de la función de error, `erf',
     de Maxima.

          (%i1) load (distrib)$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o3)                  --------------- + -
                                        2          2

     Véase también `erf'.

 -- Función: quantile_lognormal (<q>,<m>,<s>)
     Devuelve el <q>-cuantil de una variable aleatoria Lognormal(m,s),
     con s>0; en otras palabras, se trata de la inversa de
     `cdf_lognormal'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_lognormal (<m>,<s>)
     Devuelve la media de  una variable aleatoria Lognormal(m,s), con
     s>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_lognormal (<m>,<s>)
     Devuelve la varianza de  una variable aleatoria Lognormal(m,s),
     con s>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_lognormal (<m>,<s>)
     Devuelve la desviación típica de  una variable aleatoria
     Lognormal(m,s), con s>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_lognormal (<m>,<s>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Lognormal(m,s), con s>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_lognormal (<m>,<s>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Lognormal(m,s), con s>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_lognormal (<m>,<s>)
 -- Función: random_lognormal (<m>,<s>,<n>)
     Devuelve un valor aleatorio  Lognormal(m,s), con s>0. Llamando a
     `random_lognormal' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     Las variables lognormales se simulan mediante variables normales.
     Véase `random_normal' para más detalles.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_gamma (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Gamma(a,b), con a,b>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_gamma (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Gamma(a,b), con a,b>0.

          (%i1) load (distrib)$
          (%i2) cdf_gamma(3,5,21);
                                                        1
          (%o2)     1 - gamma_incomplete_regularized(5, -)
                                                        7
          (%i3) float(%);
          (%o3)              4.402663157376807E-7

 -- Función: quantile_gamma (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Gamma(a,b), con
     a,b>0; en otras palabras, se trata de la inversa de  `cdf_gamma'.
     El argumento <q> debe ser un número de [0,1]. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_gamma (<a>,<b>)
     Devuelve la media de  una variable aleatoria Gamma(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_gamma (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria Gamma(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_gamma (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria
     Gamma(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_gamma (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Gamma(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_gamma (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Gamma(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_gamma (<a>,<b>)
 -- Función: random_gamma (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Gamma(a,b), con a,b>0. Llamando a
     `random_gamma' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación es una combinación de dos
     procedimientos, según sea el valor del parámetro <a>:

     Para a>=1, Cheng, R.C.H. y Feast, G.M. (1979). <Some simple gamma
     variate generators>. Appl. Stat., 28, 3, 290-295.

     Para 0<a<1, Ahrens, J.H. y Dieter, U. (1974). <Computer methods
     for sampling from gamma, beta, poisson and binomial
     distributions>. Computing, 12, 223-246.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_beta (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Beta(a,b), con a,b>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_beta (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Beta(a,b), con a,b>0.

          (%i1) load (distrib)$
          (%i2) cdf_beta(1/3,15,2);
                                       11
          (%o2)                     --------
                                    14348907
          (%i3) float(%);
          (%o3)              7.666089131388195E-7

 -- Función: quantile_beta (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Beta(a,b), con
     a,b>0; en otras palabras, se trata de la inversa de  `cdf_beta'.
     El argumento <q> debe ser un número de [0,1]. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_beta (<a>,<b>)
     Devuelve la media de  una variable aleatoria Beta(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: var_beta (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria Beta(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_beta (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria
     Beta(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_beta (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Beta(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_beta (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Beta(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_beta (<a>,<b>)
 -- Función: random_beta (<a>,<b>,<n>)
     Devuelve un valor aleatorio Beta(a,b), con a,b>0. Llamando a
     `random_beta' con un tercer argumento <n>, se simulará una muestra
     aleatoria de tamaño  <n>.

     El algoritmo de simulación es el decrito en Cheng, R.C.H. (1978).
     <Generating Beta Variates with Nonintegral Shape Parameters>.
     Communications of the ACM, 21:317-322.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_continuous_uniform (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria  Uniforme Continua(a,b), con a<b. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_continuous_uniform (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria  Uniforme Continua(a,b),
     con a<b. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: quantile_continuous_uniform (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria  Uniforme
     Continua(a,b), con a<b; en otras palabras, se trata de la inversa
     de  `cdf_continuous_uniform'. El argumento <q> debe ser un número
     de [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_continuous_uniform (<a>,<b>)
     Devuelve la media de  una variable aleatoria  Uniforme
     Continua(a,b), con a<b. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: var_continuous_uniform (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria  Uniforme
     Continua(a,b), con a<b. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: std_continuous_uniform (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria  Uniforme
     Continua(a,b), con a<b. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_continuous_uniform (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Uniforme Continua(a,b), con a<b. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_continuous_uniform (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Uniforme Continua(a,b), con a<b. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_continuous_uniform (<a>,<b>)
 -- Función: random_continuous_uniform (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Uniforme Continuo(a,b), con a<b.
     Llamando a `random_continuous_uniform' con un tercer argumento
     <n>, se simulará una muestra aleatoria de tamaño  <n>.

     Esta función es una aplicación directa de la función  `random' de
     Maxima.

     Véase también `random'. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: pdf_logistic (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Logística(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_logistic (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Logística(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_logistic (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Logística(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_logistic'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_logistic (<a>,<b>)
     Devuelve la media de  una variable aleatoria Logística(a,b), con
     b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_logistic (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria Logística(a,b),
     con b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_logistic (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria
     Logística(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_logistic (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Logística(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_logistic (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Logística(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_logistic (<a>,<b>)
 -- Función: random_logistic (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Logístico(a,b), con b>0. Llamando a
     `random_logistic' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_pareto (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Pareto(a,b), con a,b>0. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_pareto (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Pareto(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_pareto (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Pareto(a,b),
     con a,b>0; en otras palabras, se trata de la inversa de
     `cdf_pareto'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_pareto (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Pareto(a,b), con
     a>1,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_pareto (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Pareto(a,b),
     con a>2,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_pareto (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Pareto(a,b), con a>2,b>0. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: skewness_pareto (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Pareto(a,b), con a>3,b>0. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_pareto (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Pareto(a,b), con a>4,b>0. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_pareto (<a>,<b>)
 -- Función: random_pareto (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Pareto(a,b), con a>0,b>0. Llamando a
     `random_pareto' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_weibull (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Weibull(a,b), con a,b>0. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_weibull (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Weibull(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_weibull (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Weibull(a,b),
     con a,b>0; en otras palabras, se trata de la inversa de
     `cdf_weibull'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_weibull (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Weibull(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_weibull (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Weibull(a,b),
     con a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_weibull (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Weibull(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_weibull (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Weibull(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_weibull (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Weibull(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_weibull (<a>,<b>)
 -- Función: random_weibull (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Weibull(a,b), con a,b>0. Llamando a
     `random_weibull' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_rayleigh (<x>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la densidad de
     la Weibull.

          (%i1) load (distrib)$
          (%i2) pdf_rayleigh(x,b);
                                                  1
          (%o2)                 pdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o4)                   2 b  x %e

 -- Función: cdf_rayleigh (<x>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la
     distribución de la Weibull.

          (%i1) load (distrib)$
          (%i2) cdf_rayleigh(x,b);
                                                  1
          (%o2)                 cdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o4)                     1 - %e

 -- Función: quantile_rayleigh (<q>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Rayleigh(b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_rayleigh'. El argumento <q> debe ser un número de [0,1].

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en los cuantiles
     de la Weibull.

          (%i1) load (distrib)$
          (%i2) quantile_rayleigh(0.99,b);
                                                      1
          (%o2)             quantile_weibull(0.99, 2, -)
                                                      b
          (%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o4)                   -----------------
                                          b

 -- Función: mean_rayleigh (<b>)
     Devuelve la media de  una variable aleatoria de Rayleigh(b), con
     b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la media de la
     Weibull.

          (%i1) load (distrib)$
          (%i2) mean_rayleigh(b);
                                                 1
          (%o2)                  mean_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ mean_rayleigh(b);
                                      sqrt(%pi)
          (%o4)                       ---------
                                         2 b

 -- Función: var_rayleigh (<b>)
     Devuelve la varianza de  una variable aleatoria de Rayleigh(b),
     con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la varianza de
     la Weibull.

          (%i1) load (distrib)$
          (%i2) var_rayleigh(b);
                                                 1
          (%o2)                   var_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o4)                        -------
                                          2
                                         b

 -- Función: std_rayleigh (<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la desviación
     típica de la Weibull.

          (%i1) load (distrib)$
          (%i2) std_rayleigh(b);
                                                 1
          (%o2)                   std_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o4)                     -------------
                                          b

 -- Función: skewness_rayleigh (<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de asimetría de la Weibull.

          (%i1) load (distrib)$
          (%i2) skewness_rayleigh(b);
                                                   1
          (%o2)                skewness_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o4)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4

 -- Función: kurtosis_rayleigh (<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de curtosis de la Weibull.

          (%i1) load (distrib)$
          (%i2) kurtosis_rayleigh(b);
                                                   1
          (%o2)                kurtosis_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o4)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4

 -- Función: random_rayleigh (<b>)
 -- Función: random_rayleigh (<b>,<n>)
     Devuelve un valor aleatorio  Rayleigh(b), con b>0. Llamando a
     `random_rayleigh' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_laplace (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Laplace(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_laplace (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Laplace(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_laplace (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Laplace(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_laplace'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_laplace (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Laplace(a,b), con
     b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_laplace (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Laplace(a,b),
     con b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_laplace (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Laplace(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_laplace (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Laplace(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_laplace (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Laplace(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_laplace (<a>,<b>)
 -- Función: random_laplace (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Laplace(a,b), con b>0. Llamando a
     `random_laplace' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_cauchy (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Cauchy(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_cauchy (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Cauchy(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_cauchy (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Cauchy(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_cauchy'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: random_cauchy (<a>,<b>)
 -- Función: random_cauchy (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Cauchy(a,b), con b>0. Llamando a
     `random_cauchy' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_gumbel (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Gumbel(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_gumbel (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Gumbel(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_gumbel (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Gumbel(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_gumbel'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_gumbel (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Gumbel(a,b), con
     b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$  mean_gumbel(a,b);
          (%o3)                     %gamma b + a
     donde el símbolo `%gamma' representa la constante de
     Euler-Mascheroni. Véase también `%gamma'.

 -- Función: var_gumbel (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Gumbel(a,b),
     con b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_gumbel (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Gumbel(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_gumbel (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Gumbel(a,b), con b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$ skewness_gumbel(a,b);
                                 12 sqrt(6) zeta(3)
          (%o3)                  ------------------
                                           3
                                        %pi
          (%i4) numer:true$ skewness_gumbel(a,b);
          (%o5)                   1.139547099404649
     donde `zeta' representa la función zeta de Riemann.

 -- Función: kurtosis_gumbel (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Gumbel(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_gumbel (<a>,<b>)
 -- Función: random_gumbel (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Gumbel(a,b), con b>0. Llamando a
     `random_gumbel' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.


File: maxima.info,  Node: Funciones y variables para distribuciones discretas,  Prev: Funciones y variables para distribuciones continuas,  Up: distrib

47.3 Funciones y variables para distribuciones discretas
========================================================

 -- Función: pdf_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Binomial(n,p), con 0<p<1 y
     n entero positivo. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: cdf_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Binomial(n,p), con 0<p<1 y
     n entero positivo.

          (%i1) load (distrib)$
          (%i2) cdf_binomial(5,7,1/6);
                                      7775
          (%o2)                       ----
                                      7776
          (%i3) float(%);
          (%o3)               .9998713991769548

 -- Función: quantile_binomial (<q>,<n>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Binomial(n,p),
     con 0<p<1 y n entero positivo; en otras palabras, se trata de la
     inversa de  `cdf_binomial'. El argumento <q> debe ser un número de
     [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_binomial (<n>,<p>)
     Devuelve la media de  una variable aleatoria Binomial(n,p), con
     0<p<1 y n entero positivo. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: var_binomial (<n>,<p>)
     Devuelve la varianza de  una variable aleatoria Binomial(n,p), con
     0<p<1 y n entero positivo. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: std_binomial (<n>,<p>)
     Devuelve la desviación típica de  una variable aleatoria
     Binomial(n,p), con 0<p<1 y n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: skewness_binomial (<n>,<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Binomial(n,p), con 0<p<1 y n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_binomial (<n>,<p>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     binomial  Binomial(n,p), con 0<p<1 y n entero positivo. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: random_binomial (<n>,<p>)
 -- Función: random_binomial (<n>,<p>,<m>)
     Devuelve un valor aleatorio  Binomial(n,p), con 0<p<1 y n entero
     positivo. Llamando a  `random_binomial' con un tercer argumento
     <m>, se simulará una muestra aleatoria de tamaño  <m>.

     El algoritmo de simulación es el descrito en Kachitvichyanukul, V.
     y Schmeiser, B.W. (1988) <Binomial Random Variate Generation>.
     Communications of the ACM, 31, Feb., 216.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_poisson (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria de Poisson(m), con m>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_poisson (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Poisson(m), con m>0.

          (%i1) load (distrib)$
          (%i2) cdf_poisson(3,5);
          (%o2)       gamma_incomplete_regularized(4, 5)
          (%i3) float(%);
          (%o3)               .2650259152973623

 -- Función: quantile_poisson (<q>,<m>)
     Devuelve el <q>-cuantil de una variable aleatoria de Poisson(m),
     con m>0; en otras palabras, se trata de la inversa de
     `cdf_poisson'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_poisson (<m>)
     Devuelve la media de una variable aleatoria de Poisson(m), con
     m>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_poisson (<m>)
     Devuelve la varianza de  una variable aleatoria de Poisson(m), con
     m>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_poisson (<m>)
     Devuelve la desviación típica de  una variable aleatoria de
     Poisson(m), con m>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_poisson (<m>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Poisson(m), con m>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_poisson (<m>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Poisson(m), con m>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_poisson (<m>)
 -- Función: random_poisson (<m>,<n>)
     Devuelve un valor aleatorio  Poisson(m), con m>0. Llamando a
     `random_poisson' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación es el descrito en Ahrens, J.H. and
     Dieter, U. (1982) <Computer Generation of Poisson Deviates From
     Modified Normal Distributions>. ACM Trans. Math. Software, 8, 2,
     June,163-179.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_bernoulli (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria de Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la función de
     probabilidad de la binomial.

          (%i1) load (distrib)$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                 pdf_binomial(1, 1, p)
          (%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
          (%o4)                           p

 -- Función: cdf_bernoulli (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Bernoulli(p), con 0<p<1.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_bernoulli (<q>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria de Bernoulli(p),
     con 0<p<1; en otras palabras, se trata de la inversa de
     `cdf_bernoulli'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_bernoulli (<p>)
     Devuelve la media de  una variable aleatoria de Bernoulli(p), con
     0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la media de la
     binomial.

          (%i1) load (distrib)$
          (%i2) mean_bernoulli(p);
          (%o2)                  mean_binomial(1, p)
          (%i3) assume(0<p,p<1)$ mean_bernoulli(p);
          (%o4)                           p

 -- Función: var_bernoulli (<p>)
     Devuelve la varianza de  una variable aleatoria de Bernoulli(p),
     con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la varianza de
     la binomial.

          (%i1) load (distrib)$
          (%i2) var_bernoulli(p);
          (%o2)                  var_binomial(1, p)
          (%i3) assume(0<p,p<1)$ var_bernoulli(p);
          (%o4)                       (1 - p) p

 -- Función: std_bernoulli (<p>)
     Devuelve la desviación típica de  una variable aleatoria de
     Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la desviación
     típica de la binomial.

          (%i1) load (distrib)$
          (%i2) std_bernoulli(p);
          (%o2)                  std_binomial(1, p)
          (%i3) assume(0<p,p<1)$ std_bernoulli(p);
          (%o4)                  sqrt(1 - p) sqrt(p)

 -- Función: skewness_bernoulli (<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de asimetría de la binomial.

          (%i1) load (distrib)$
          (%i2) skewness_bernoulli(p);
          (%o2)                skewness_binomial(1, p)
          (%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                                       1 - 2 p
          (%o4)                  -------------------
                                 sqrt(1 - p) sqrt(p)

 -- Función: kurtosis_bernoulli (<p>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de curtosis de la binomial.

          (%i1) load (distrib)$
          (%i2) kurtosis_bernoulli(p);
          (%o2)                kurtosis_binomial(1, p)
          (%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o4)                    ---------------
                                      (1 - p) p

 -- Función: random_bernoulli (<p>)
 -- Función: random_bernoulli (<p>,<n>)
     Devuelve un valor aleatorio  Bernoulli(p), con 0<p<1. Llamando a
     `random_bernoulli' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Es aplicación directa de la función `random' de Maxima.

     Véase también `random'. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: pdf_geometric (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Geométrica(p), con 0<p<1.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_geometric (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Geométrica(p), con 0<p<1.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_geometric (<q>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Geométrica(p),
     con 0<p<1; en otras palabras, se trata de la inversa de
     `cdf_geometric'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_geometric (<p>)
     Devuelve la media de  una variable aleatoria Geométrica(p), con
     0<p<1. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_geometric (<p>)
     Devuelve la varianza de  una variable aleatoria Geométrica(p), con
     0<p<1. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_geometric (<p>)
     Devuelve la desviación típica de  una variable aleatoria
     Geométrica(p), con 0<p<1. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: skewness_geometric (<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Geométrica(p), con 0<p<1. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_geometric (<p>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Geométrica(p), con 0<p<1. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_geometric (<p>)
 -- Función: random_geometric (<p>,<n>)
     Devuelve un valor aleatorio Geométrico(p), con 0<p<1. Llamando a
     `random_geometric' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo está basado en la simulación de ensayos de Bernoulli.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_discrete_uniform (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Uniforme Discreta(n), con n
     entero positivo. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: cdf_discrete_uniform (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Uniforme Discreta(n), con n
     entero positivo. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: quantile_discrete_uniform (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria Uniforme
     Discreta(n), con n entero positivo; en otras palabras, se trata de
     la inversa de  `cdf_discrete_uniform'. El argumento <q> debe ser
     un número de [0,1]. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: mean_discrete_uniform (<n>)
     Devuelve la media de  una variable aleatoria Uniforme Discreta(n),
     con n entero positivo. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: var_discrete_uniform (<n>)
     Devuelve la varianza de  una variable aleatoria Uniforme
     Discreta(n), con n entero positivo. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: std_discrete_uniform (<n>)
     Devuelve la desviación típica de  una variable aleatoria Uniforme
     Discreta(n), con n entero positivo. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: skewness_discrete_uniform (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Uniforme Discreta(n), con n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_discrete_uniform (<n>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Uniforme Discreta(n), con n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: random_discrete_uniform (<n>)
 -- Función: random_discrete_uniform (<n>,<m>)
     Devuelve un valor aleatorio  Uniforme Discreto(n), con n entero
     positivo. Llamando a  `random_discrete_uniform' con un segundo
     argumento <m>, se simulará una muestra aleatoria de tamaño  <m>.

     Se trata de una aplicación directa de la función `random' de
     Maxima.

     Véase también `random'. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: pdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Hipergeométrica(n1,n2,n),
     con <n1>, <n2> y <n> enteros positivos y n<=n1+n2. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución of una variable aleatoria Hipergeométrica(n1,n2,n),
     con <n1>, <n2> y <n> enteros positivos y n<=n1+n2. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_hypergeometric (<q>,<n1>,<n2>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2; en otras palabras, se trata de la inversa de
     `cdf_hypergeometric'. El argumento <q> debe ser un número de
     [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la media de  una variable aleatoria uniforme discreta
     Hyp(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y n<=n1+n2.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: var_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la varianza de  una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la desviación típica de  una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: skewness_hypergeometric (<n1>,<n2>,<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: random_hypergeometric (<n1>,<n2>,<n>)
 -- Función: random_hypergeometric (<n1>,<n2>,<n>,<m>)
     Devuelve un valor aleatorio Hipergeométrico(n1,n2,n), con <n1>,
     <n2> y <n> enteros positivos y n<=n1+n2. Llamando a
     `random_hypergeometric' con un cuarto argumento <m>, se simulará
     una muestra aleatoria de tamaño  <m>.

     Algoritmo descrito en Kachitvichyanukul, V., Schmeiser, B.W.
     (1985) <Computer generation of hypergeometric random variates.>
     Journal of Statistical Computation and Simulation 22, 127-145.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_negative_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Binomial Negativa(n,p), con
     0<p<1 y n entero positivo. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: cdf_negative_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Binomial Negativa(n,p), con
     0<p<1 y n entero positivo.

          (%i1) load (distrib)$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                      3271
          (%o2)                      ------
                                     524288
          (%i3) float(%);
          (%o3)              .006238937377929687

 -- Función: quantile_negative_binomial (<q>,<n>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 y n entero positivo; en otras palabras,
     se trata de la inversa de  `cdf_negative_binomial'. El argumento
     <q> debe ser un número de [0,1]. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: mean_negative_binomial (<n>,<p>)
     Devuelve la media de  una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 and n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: var_negative_binomial (<n>,<p>)
     Devuelve la varianza de  una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 and n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: std_negative_binomial (<n>,<p>)
     Devuelve la desviación típica de  una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 and n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: skewness_negative_binomial (<n>,<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Binomial Negativa(n,p), con 0<p<1 and n entero positivo. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_negative_binomial (<n>,<p>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     binomial negativa  NB(n,p), con 0<p<1 and n entero positivo. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: random_negative_binomial (<n>,<p>)
 -- Función: random_negative_binomial (<n>,<p>,<m>)
     Devuelve un valor aleatorio Binomial Negativo(n,p), con 0<p<1 y n
     entero positivo. Llamando a  `random_negative_binomial' con un
     tercer argumento <m>, se simulará una muestra aleatoria de tamaño
     <m>.

     Algoritmo descrito en Devroye, L. (1986) <Non-Uniform Random
     Variate Generation>. Springer Verlag, p. 480.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.


File: maxima.info,  Node: draw,  Next: dynamics,  Prev: distrib,  Up: Top

48 draw
*******

* Menu:

* Introducción a draw::
* Funciones y variables para draw::
* Funciones y variables para picture::
* Funciones y variables para worldmap::


File: maxima.info,  Node: Introducción a draw,  Next: Funciones y variables para draw,  Prev: draw,  Up: draw

48.1 Introducción a draw
========================

`draw' es un interfaz para comunicar Maxima con Gnuplot.

   Tres son las funciones principales a utilizar a nivel de Maxima:
`draw2d', `draw3d' y `draw'.

   Sígase este enlace para ver ejemplos más elaborados de este paquete:

   `http://www.telefonica.net/web2/biomates/maxima/gpdraw'

   Se necesita tener instalado Gnuplot 4.2 para ejecutar este paquete.


File: maxima.info,  Node: Funciones y variables para draw,  Next: Funciones y variables para picture,  Prev: Introducción a draw,  Up: draw

48.2 Funciones y variables para draw
====================================

 -- Opción gráfica: proportional_axes
     Valor por defecto: `none'

     Cuando `proportional_axes' es igual a `xy', una escena 2D se
     dibujará con los ejes proporcionales a sus longitudes relativas.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Esta opción sólo funciona para gráficos 2D. Una vez se haya
     liberado la versión 4.3 de Gnuplot, se extenderá
     `proportional_axes' a los gráficos 3D.

     Ejemplos:

     Gráfico sencillo.

          (%i1) load(draw)$
          (%i2) draw2d(
                  ellipse(0,0,1,1,0,360),
                  transparent=true,
                  color = blue,
                  line_width = 4,
                  ellipse(0,0,2,1/2,0,360),
                  proportional_axes = xy) $

     Multiplot.

          (%i1) load(draw)$
          (%i2) draw(
                  terminal = wxt,
                  gr2d(proportional_axes = xy,
                       explicit(x^2,x,0,1)),
                  gr2d(explicit(x^2,x,0,1),
                       xrange = [0,1],
                       yrange = [0,2],
                       proportional_axes=xy),
                  gr2d(explicit(x^2,x,0,1))


 -- Opción gráfica: xrange
     Valor por defecto: `auto'

     Cuando `xrange' vale `auto', el rango de la coordenada <x> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <x>, éste debe
     expresarse como una lista de Maxima, como en `xrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [-3,5],
                       explicit(x^2,x,-1,1))$

     Véanse también `yrange' y `zrange'.

 -- Opción gráfica: xrange_secondary
     Valor por defecto: `auto'

     Cuando `xrange_secondary' vale `auto', el rango del eje <x>
     secundario se calcula de forma automática.

     Si el usuario quiere especificar un intervalo para el eje <x>
     secundario, éste debe expresarse como una lista de Maxima, como en
     `xrange_secondary=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véanse también `xrange', `yrange', `zrange' y `yrange_secondary'.

 -- Opción gráfica: yrange
     Valor por defecto: `auto'

     Cuando `yrange' vale `auto', el rango de la coordenada <y> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <y>, éste debe
     expresarse como una lista de Maxima, como en `yrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [-2,3],
                       explicit(x^2,x,-1,1),
                       xrange = [-3,3])$

     Véanse también `xrange' y `zrange'.

 -- Opción gráfica: yrange_secondary
     Valor por defecto: `auto'

     Cuando `yrange_secondary' vale `auto', el rango del eje <y>
     secundario se calcula de forma automática.

     Si el usuario quiere especificar un intervalo para el eje <y>
     secundario, éste debe expresarse como una lista de Maxima, como en
     `yrange_secondary=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   yrange = [-3, 3],
                   yrange_secondary = [-20, 20],
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10)) $

     Véanse también `xrange', `yrange' y `zrange'.

 -- Opción gráfica: zrange
     Valor por defecto: `auto'

     Cuando `zrange' vale `auto', el rango de la coordenada <z> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <z>, éste debe
     expresarse como una lista de Maxima, como en `zrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(yrange = [-3,3],
                       zrange = [-2,5],
                       explicit(x^2+y^2,x,-1,1,y,-1,1),
                       xrange = [-3,3])$

     Véanse también `xrange' y `yrange'.

 -- Opción gráfica: cbrange
     Valor por defecto: `auto'

     Cuando `cbrange' vale `auto', el rango de los valores que se
     colorean cuando `enhanced3d' es diferente de `false' se calcula
     automáticamente. Valores fuera del rango utilizan el color del
     valor extremo más cercano.

     Cuando `enhanced3d' o `colorbox' vale `false', la opción `cbrange'
     no tiene efecto alguno.

     Si el usuario quiere especificar un intervalo para los valores a
     colorear, éste debe expresarse como una lista de Maxima, como en
     `cbrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d     = true,
                  color          = green,
                  cbrange = [-3,10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     Véanse también `enhanced3d' y `cbtics'.

 -- Opción gráfica: logx
     Valor por defecto: `false'

     Cuando `logx' vale `true', el eje <x> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(log(x),x,0.01,5),
                       logx = true)$

     Véanse también `logy' y `logz'.

 -- Opción gráfica: logy
     Valor por defecto: `false'

     Cuando `logy' vale `true', el eje <y> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(logy = true,
                       explicit(exp(x),x,0,5))$

     Véanse también `logx' y `logz'.

 -- Opción gráfica: logz
     Valor por defecto: `false'

     Cuando `logz' vale `true', el eje <z> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(logz = true,
                       explicit(exp(u^2+v^2),u,-2,2,v,-2,2))$

     Véanse también `logx' y `logy'.

 -- Opción gráfica: logcb
     Valor por defecto: `false'

     Cuando `logcb' vale `true', la escala de colores se dibuja
     logarítmicamente.

     Cuando `enhanced3d' o `colorbox' vale `false', la opción `logcb'
     no tiene efecto alguno.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  logcb = true,
                  logz  = true,
                  palette = [-15,24,-9],
                  explicit(exp(x^2-y^2), x,-2,2,y,-2,2)) $

     Véanse también `enhanced3d', `colorbox' y `cbrange'.

 -- Opción gráfica: terminal
     Valor por defecto: `screen'

     Selecciona el terminal a utilizar por Gnuplot; valores posibles
     son: `screen' (por defecto), `png', `jpg', `eps', `eps_color',
     `pdf', `pdfcairo', `gif', `animated_gif', `wxt' y `aquaterm'.

     Los terminales `screen', `wxt' y `aquaterm' también se pueden
     definir como una lista de dos elementos: el propio nombre del
     terminal y un número entero no negativo. De esta forma se pueden
     abrir varias ventanas al mismo tiempo, cada una de ellas con su
     número correspondiente. Esta modalidad no funciona en plataformas
     Windows.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     pdfcairo necesita Gnuplot 4.3. Actualmente (Nov 2008) Gnuplot 4.3
     es una versión en desarrollo.  pdf necesita que Gnuplot 4.2/4.3
     haya sido compilado con la opción `--enable-pdf' y libpdf debe
     estar instalado
     (`http://www.pdflib.com/en/download/pdflib-family/pdflib-lite/').

     Ejemplos:

          (%i1) load(draw)$
          (%i2) /* screen terminal (default) */
                draw2d(explicit(x^2,x,-1,1))$
          (%i3) /* png file */
                draw2d(terminal  = 'png,
                       pic_width = 300,
                       explicit(x^2,x,-1,1))$
          (%i4) /* jpg file */
                draw2d(terminal   = 'jpg,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$
          (%i5) /* eps file */
                draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'eps)$
          (%i6) /* pdf file */
                draw2d(file_name = "mypdf",
                       pdf_width = 12.0,
                       pdf_height = 8.0,
                       explicit(x^2,x,-1,1),
                       terminal  = 'pdf)$
          (%i7) /* wxwidgets window */
                draw2d(explicit(x^2,x,-1,1),
                       terminal  = 'wxt)$

     Ventanas múltiples.
          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^5,x,-2,2), terminal=[screen, 3])$
          (%i3) draw2d(explicit(x^2,x,-2,2), terminal=[screen, 0])$

     Un fichero gif animado.
          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     La opción `delay' sólo se activa en caso de gifs animados; se
     ignora en cualquier otro caso.

     Véanse también `file_name', `pic_width', `pic_height' y `delay'.

 -- Opción gráfica: font
     Valor por defecto: `""' (cadena vacía)

     Esta opción permite seleccionar el tipo de fuente a utilizar por el
     terminal. Sólo se puede utilizar un tipo de fuente y tamaño por
     gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véase también `font_size'.

     Gnuplot no puede gestionar por sí mismo las fuentes, dejando esta
     tarea a las librerías que dan soporte a los diferentes terminales,
     cada uno con su propia manera de controlar la tipografía. A
     continuación un breve resumen:

        * x11: Utiliza el mecanismo habitual para suministrar las
          fuentes en x11.

          Ejemplo:
               (%i1) load(draw)$
               (%i2) draw2d(font      = "Arial",
                            font_size = 20,
                            label(["Arial font, size 20",1,1]))$

        * windows: El terminal de windows no permite cambiar fuentes
          desde dentro del gráfico. Una vez se ha creado el gráfico, se
          pueden cambiar las fuentes haciendo clic derecho en el menú
          de la ventana gráfica.

        * png, jpeg, gif: La librería libgd utiliza la ruta a las
          fuentes almacenada en la variable de entorno `GDFONTPATH'; en
          tal caso sólo es necesario darle a la opción `font' el nombre
          de la fuente. También es posible darle la ruta completa al
          fichero de la fuente.

          Ejemplos:

          A la opción `font' se le puede dar la ruta completa al
          fichero de la fuente:
               (%i1) load(draw)$
               (%i2) path: "/usr/share/fonts/truetype/freefont/" $
               (%i3) file: "FreeSerifBoldItalic.ttf" $
               (%i4) draw2d(
                       font      = concat(path, file),
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

          Si la variable de entorno `GDFONTPATH' almacena la ruta a la
          carpeta donde se alojan las fuentes, es posible darle a la
          opción `font' sólo el nombre de la fuente:
               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "FreeSerifBoldItalic",
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

        * Postscript: Las fuentes estándar de Postscript son:
          `"Times-Roman"', `"Times-Italic"', `"Times-Bold"',
          `"Times-BoldItalic"', `"Helvetica"', `"Helvetica-Oblique"',
          `"Helvetica-Bold"', `"Helvetic-BoldOblique"', `"Courier"',
          `"Courier-Oblique"', `"Courier-Bold"' y
          `"Courier-BoldOblique"'.

          Ejemplo:
               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "Courier-Oblique",
                       font_size = 15,
                       label(["Courier-Oblique font, size 15",1,1]),
                       terminal = eps)$

        * pdf: Utiliza las mismas fuentes que Postscript.

        * pdfcairo: Utiliza las mismas fuentes que wxt.

        * wxt: La librería pango encuentra las fuentes por medio de la
          utilidad `fontconfig'.

        * aqua: La fuente por defecto es `"Times-Roman"'.

     La documentación de gnuplot es una importante fuente de
     información sobre terminales y fuentes.

 -- Opción gráfica: font_size
     Valor por defecto: 12

     Esta opción permite seleccionar el tamaño de la fuente a utilizar
     por el terminal. Sólo se puede utilizar un tipo de fuente y tamaño
     por gráfico. `font_size' sólo se activa cuando la opción `font'
     tiene un valor diferente de la cadena vacía.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véase también `font'.

 -- Opción gráfica: grid
     Valor por defecto: `false'

     Cuando `grid' vale `true', se dibujará una rejilla sobre el plano
     <xy>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(grid = true,
                       explicit(exp(u),u,-2,2))$

 -- Opción gráfica: title
     Valor por defecto: `""' (cadena vacía)

     La opción `title' almacena una cadena con el título de la escena.
     Por defecto, no se escribe título alguno.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(u),u,-2,2),
                       title = "Exponential function")$

 -- Opción gráfica: xlabel
     Valor por defecto: `""' (cadena vacía)

     La opción `xlabel' almacena una cadena con la etiqueta del eje
     <x>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       explicit(exp(u),u,-2,2),
                       ylabel = "Population")$

     Véanse también `ylabel' y `zlabel'.

 -- Opción gráfica: ylabel
     Valor por defecto: `""' (cadena vacía)

     La opción `ylabel' almacena una cadena con la etiqueta del eje
     <y>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       ylabel = "Population",
                       explicit(exp(u),u,-2,2) )$

     Véanse también `xlabel' y `zlabel'.

 -- Opción gráfica: zlabel
     Valor por defecto: `""' (cadena vacía)

     La opción `zlabel' almacena una cadena con la etiqueta del eje
     <z>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(zlabel = "Z variable",
                       ylabel = "Y variable",
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2),
                       xlabel = "X variable" )$

     Véanse también `xlabel' y `ylabel'.

 -- Opción gráfica: xtics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <x>.

        * Cuando a `xtics' se le da el valor <auto>, las marcas se
          dibujarán de forma automática.

        * Cuando a `xtics' se le da el valor <none>, no habrá marcas en
          los ejes.

        * Cuando a `xtics' se le da un valor numérico positivo, se
          interpretará como la distancia entre dos marcas consecutivas.

        * Cuando a `xtics' se le da una lista de longitud tres de la
          forma `[start,incr,end]', las marcas se dibujarán desde
          `start' hasta `end' a intervalos de longitud `incr'.

        * Cuando a `xtics' se le da un conjunto de números de la forma
          `{n1, n2, ...}', las marcas se dibujarán exactamente en los
          valores `n1', `n2', ...

        * Cuando a `xtics' se le da un conjunto de pares de la forma
          `{["label1", n1], ["label2", n2], ...}', las marcas
          correspondientes a los valores `n1', `n2', ... se etiquetarán
          con `"label1"', `"label2"', ..., respectivamente.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Marcas desactivadas.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 'none,
                       explicit(x^3,x,-1,1)  )$

     Marcas cada 1/4 unidades.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 1/4,
                       explicit(x^3,x,-1,1)  )$

     Marcas desde -3/4 hasta 3/4 en saltos de 1/8.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = [-3/4,1/8,3/4],
                       explicit(x^3,x,-1,1)  )$

     Marcas en los puntos -1/2, -1/4 y 3/4.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {-1/2,-1/4,3/4},
                       explicit(x^3,x,-1,1)  )$

     Marcas etiquetadas.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {["High",0.75],["Medium",0],["Low",-0.75]},
                       explicit(x^3,x,-1,1)  )$

 -- Opción gráfica: xtics_secondary
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <x> secundario.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: ytics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <y>.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: ytics_secondary
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <y> secundario.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: ztics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <z>.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: cbtics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas en la escala de color cuando la opción `enhanced3d' sea
     diferente de `false'.

     Cuando `enhanced3d' o `colorbox' vale `false', la opción `cbtics'
     no tiene efecto alguno.

     Véase `xtics' para una descripción completa.

     Ejemplo :

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  cbtics  = {["High",10],["Medium",05],["Low",0]},
                  cbrange = [0, 10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     See also `enhanced3d', `colorbox' and `cbrange'.

 -- Opción gráfica: xtics_rotate
     Valor por defecto: `false'

     Si `xtics_rotate' vale `true', las marcas del eje <x> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_rotate_secondary
     Valor por defecto: `false'

     Si `xtics_rotate_secondary' vale `true', las marcas del eje <x>
     secundario se giran 90 grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_rotate
     Valor por defecto: `false'

     Si `ytics_rotate' vale `true', las marcas del eje <y> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_rotate_secondary
     Valor por defecto: `false'

     Si `ytics_rotate_secondary' vale `true', las marcas del eje <y>
     secundario se giran 90 grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ztics_rotate
     Valor por defecto: `false'

     Si `ztics_rotate' vale `true', las marcas del eje <z> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_axis
     Valor por defecto: `false'

     Si `xtics_axis' vale `true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <x>, si vale `false' las marcas se colocan a
     lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_secondary_axis
     Valor por defecto: `false'

     Si `xtics_secondary_axis' vale `true', las marcas y sus etiquetas
     se dibujan sobre el propio eje <x> secundario, si vale `false' las
     marcas se colocan a lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_axis
     Valor por defecto: `false'

     Si `ytics_axis' vale `true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <y>, si vale `false' las marcas se colocan a
     lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_secondary_axis
     Valor por defecto: `false'

     Si `ytics_secondary_axis' vale `true', las marcas y sus etiquetas
     se dibujan sobre el propio eje <y> secundario, si vale `false' las
     marcas se colocan a lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ztics_axis
     Valor por defecto: `false'

     Si `ztics_axis' vale `true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <z>, si vale `false' las marcas se colocan a
     lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xaxis
     Valor por defecto: `false'

     Si `xaxis' vale `true', se dibujará el eje <x>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = blue)$

     Véanse también `xaxis_width', `xaxis_type' y `xaxis_color'.

 -- Opción gráfica: xaxis_secondary
     Valor por defecto: `false'

     Si `xaxis_secondary' vale `true', los valores de las funciones se
     pueden representar respecto del eje <x> secundario, el cual se
     dibuja en la parte superior de la escena.

     Nótese que esta es una opción gráfica local que sólo afecta a
     objetos 2d.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   key   = "Bottom x-axis",
                   explicit(x+1,x,1,2),
                   color = red,
                   key   = "Above x-axis",
                   xtics_secondary = true,
                   xaxis_secondary = true,
                   explicit(x^2,x,-1,1)) $

     Véanse también `xrange_secondary', `xtics_secondary',
     `xtics_rotate_secondary', `xtics_axis_secondary' y
     `xaxis_secondary'.


 -- Opción gráfica: xaxis_width
     Valor por defecto: 1

     `xaxis_width' es el ancho del eje <x>.  Su valor debe ser un
     número positivo.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_width = 3)$

     Véanse también `xaxis', `xaxis_type' y `xaxis_color'.

 -- Opción gráfica: xaxis_type
     Valor por defecto: `dots'

     `xaxis_type' indica cómo se debe dibujar el eje <x>; valores
     admisibles son `solid' y `dots'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_type  = solid)$

     Véanse también `xaxis', `xaxis_width' y `xaxis_color'.

 -- Opción gráfica: xaxis_color
     Valor por defecto: `"black"'

     `xaxis_color' especifica el color para el eje <x>. Véase `color'
     para ver cómo se definen los colores.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = red)$

     Véanse también `xaxis', `xaxis_width' y `xaxis_type'.

 -- Opción gráfica: yaxis
     Valor por defecto: `false'

     Si `yaxis' vale `true', se dibujará el eje <y>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = blue)$

     Véanse también `yaxis_width', `yaxis_type' y `yaxis_color'.

 -- Opción gráfica: yaxis_secondary
     Valor por defecto: `false'

     Si `yaxis_secondary' vale `true', los valores de las funciones se
     pueden representar respecto del eje <y> secundario, el cual se
     dibuja al lado derecho de la escena.

     Nótese que esta es una opción gráfica local que sólo afecta a
     objetos 2d.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10));

     Véanse también `yrange_secondary', `ytics_secondary',
     `ytics_rotate_secondary' y `ytics_axis_secondary'.


 -- Opción gráfica: yaxis_width
     Valor por defecto: 1

     `yaxis_width' es el ancho del eje <y>.  Su valor debe ser un
     número positivo.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_width = 3)$

     Véanse también `yaxis', `yaxis_type' y `yaxis_color'.

 -- Opción gráfica: yaxis_type
     Valor por defecto: `dots'

     `yaxis_type' indica cómo se debe dibujar el eje <y>; valores
     admisibles son `solid' y `dots'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_type  = solid)$

     Véanse también `yaxis', `yaxis_width' y `yaxis_color'.

 -- Opción gráfica: yaxis_color
     Valor por defecto: `"black"'

     `yaxis_color' especifica el color para el eje <y>. Véase `color'
     para ver cómo se definen los colores.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = red)$

     Véanse también `yaxis', `yaxis_width' y `yaxis_type'.

 -- Opción gráfica: zaxis
     Valor por defecto: `false'

     Si `zaxis' vale `true', se dibujará el eje <z> en escenas 3D. Esta
     opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = blue)$

     Véanse también `zaxis_width', `zaxis_type' y `zaxis_color'.

 -- Opción gráfica: zaxis_width
     Valor por defecto: 1

     `zaxis_width' es el ancho del eje <z>.  Su valor debe ser un
     número positivo. Esta opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_width = 3)$

     Véanse también `zaxis', `zaxis_type' y `zaxis_color'.

 -- Opción gráfica: zaxis_type
     Valor por defecto: `dots'

     `zaxis_type' indica cómo se debe dibujar el eje <z>; valores
     admisibles son `solid' y `dots'.  Esta opción no tiene efecto
     alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid)$

     Véanse también `zaxis', `zaxis_width' y `zaxis_color'.

 -- Opción gráfica: zaxis_color
     Valor por defecto: `"black"'

     `zaxis_color' especifica el color para el eje <z>. Véase `color'
     para ver cómo se definen los colores.  Esta opción no tiene efecto
     alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = red)$

     Véanse también `zaxis', `zaxis_width' y `zaxis_type'.

 -- Graphic option: xyplane
     Valor por defecto: `false'

     Coloca el plano-xy en escenas 3D. Si `xyplane' vale `false', el
     plano-xy se coloca automáticamente; en cambio, si toma un valor
     real, el plano-xy intersectará con el eje <z> a ese nivel.  Esta
     opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xyplane = %e-2,
                       explicit(x^2+y^2,x,-1,1,y,-1,1))$

 -- Opción gráfica: rot_vertical
     Valor por defecto: 60

     `rot_vertical' es el ángulo (en grados) de la rotación vertical
     (alrededor del eje <x>) para situar el punto del observador en las
     escenas 3d.

     El ángulo debe pertenecer al intervalo [0, 180].

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(rot_vertical = 170,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véase también `rot_horizontal'.

 -- Opción gráfica: rot_horizontal
     Valor por defecto: 30

     `rot_horizontal' es el ángulo (en grados) de la rotación horizontal
     (alrededor del eje <z>) para situar el punto del observador en las
     escenas 3d.

     El ángulo debe pertenecer al intervalo [0, 360].

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(rot_vertical = 170,
                       rot_horizontal = 360,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véase también `rot_vertical'.

 -- Opción gráfica: xy_file
     Valor por defecto: `""' (cadena vacía)

     `xy_file' es el nombre del fichero donde se almacenarán las
     coordenadas después de hacer clic con el botón del ratón en un
     punto de la imagen y pulsado la tecla 'x'. Por defecto, las
     coordenadas no se almacenan.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: user_preamble
     Valor por defecto: `""' (cadena vacía)

     Usuarios expertos en Gnuplot pueden hacer uso de esta opción para
     afinar el comportamiento de Gnuplot escribiendo código que será
     enviado justo antes de la instrucción `plot' o `splot'.

     El valor dado a esta opción debe ser una cadena alfanumérica o una
     lista de cadenas (una por línea).

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

     El terminal dumb no está soportado por el paquete `draw', pero es
     posible activarlo haciendo uso de la opción `user_preamble',
          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x)-1,x,-1,1),
                       parametric(cos(u),sin(u),u,0,2*%pi),
                       user_preamble="set terminal dumb")$

 -- Opción gráfica: file_name
     Valor por defecto: `"maxima_out"'

     `file_name' es el nombre del fichero en el que los terminales
     `png', `jpg', `eps', `pdf' and `pdfcairo' y `eps_color' guardarán
     el gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'png)$

     Véanse también `terminal', `pic_width' y `pic_height'.

 -- Opción gráfica: gnuplot_file_name
     Valor por defecto: `"maxout.gnuplot"'

     `gnuplot_file_name' es el nombre del fichero que almacena las
     instrucciones a ser procesadas por Gnuplot.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                 file_name = "my_file",
                 gnuplot_file_name = "my_commands_for_gnuplot",
                 data_file_name    = "my_data_for_gnuplot",
                 terminal          = png,
                 explicit(x^2,x,-1,1)) $

     Véase también `data_file_name'.


 -- Opción gráfica: data_file_name
     Valor por defecto: `"data.gnuplot"'

     `data_file_name' es el nombre del fichero que almacena la
     información numérica que necesita Gnuplot para crear el gráfico
     solicitado.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Véase ejemplo en `gnuplot_file_name'.


 -- Opción gráfica: file_bgcolor
     Valor por defecto: `"xffffff"'

     Establece el color de fondo en los terminales png, jpg y gif.  Los
     colores deben definirse en código hexadecimal rgb.  Nombres de
     colores no están permitidos. El color de fondo por defecto es
     blanco.

 -- Opción gráfica: delay
     Valor por defecto: 5

     Este es el retraso en centésimas de segundo entre imágenes en los
     ficheros gif animados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     La opciób `delay' sólo se activa en caso de gifs animados; se
     ignora en cualquier otro caso.

     See also `terminal', `pic_width', and `pic_height'.

 -- Opción gráfica: pic_width
     Valor por defecto: 640

     `pic_width' es la anchura del fichero de imagen de bits generado
     por los terminales `png' y `jpg'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'png,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `pic_height'.

 -- Opción gráfica: pic_height
     Valor por defecto: 640

     `pic_height' es la altura del fichero de imagen de bits generado
     por los terminales `png' y `jpg'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'png,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `pic_width'.

 -- Opción gráfica: eps_width
     Valor por defecto: 12

     `eps_width' es el ancho (medido en cm) del archivo Postscript
     generado por los terminales `eps' y `eps_color'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'eps,
                       eps_width  = 3,
                       eps_height = 3,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `eps_height'.

 -- Opción gráfica: eps_height
     Valor por defecto: 8

     `eps_height' es la altura (medida en cm) del archivo Postscript
     generado por los terminales `eps' y `eps_color'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'eps,
                       eps_width  = 3,
                       eps_height = 3,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `eps_width'.

 -- Opción gráfica: pdf_width
     Valor por defecto: 21.0 (ancho A4)

     Es el ancho (medida en cm) del documento PDF generado por los
     terminales `pdf' y `pdfcairo'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'pdf,
                       pdf_width  = 3.0,
                       pdf_height = 3.0,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `pdf_height'.

 -- Opción gráfica: pdf_height
     Valor por defecto: 29.7 (alto A4)

     Es el alto (medida en cm) del documento PDF generado por los
     terminales `pdf' y `pdfcairo'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'pdf,
                       pdf_width  = 3.0,
                       pdf_height = 3.0,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `pdf_width'.

 -- Opción gráfica: axis_bottom
     Valor por defecto: `true'

     Cuando `axis_bottom' vale `true', el eje inferior permanece
     visible en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_bottom = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_left',  `axis_top', `axis_right' y `axis_3d'.

 -- Opción gráfica: axis_left
     Valor por defecto: `true'

     Cuando `axis_left' vale `true', el eje izquierdo permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_left = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_top', `axis_right' y
     `axis_3d'.

 -- Opción gráfica: axis_top
     Valor por defecto: `true'

     Cuando `axis_top' vale `true', el eje superior permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_top = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_left', `axis_right' y
     `axis_3d'.

 -- Opción gráfica: axis_right
     Valor por defecto: `true'

     Cuando `axis_right' vale `true', el eje derecho permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_right = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_left', `axis_top' y `axis_3d'.

 -- Opción gráfica: axis_3d
     Valor por defecto: `true'

     Cuando `axis_3d' vale `true', los ejes <x>, <y> y <z> permanecen
     visibles en las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(axis_3d = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véanse también `axis_bottom',  `axis_left', `axis_top' y
     `axis_right' for axis in 2d.

 -- Opción gráfica: palette
     Valor por defecto: `color'

     `palette' indica cómo transformar los valores reales de una matriz
     pasada al objeto `image' en componentes cromáticas.

     `palette' es un vector de longitud tres con sus componentes tomando
     valores enteros en el rango desde -36 a +36; cada valor es un
     índice para seleccionar una fórmula que transforma los niveles
     numéricos en las componentes cromáticas rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de
     las componentes cromáticas.

     `palette = gray' y `palette = color' son atajos para `palette =
     [3,3,3]' y `palette = [7,5,15]', respectivamente.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     Véase también `colorbox'.

 -- Opción gráfica: colorbox
     Valor por defecto: `true'

     Cuando `colorbox' vale `true', se dibuja una escala de color al
     lado de los objetos `image'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) im: apply('matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(colorbox=false, image(im,0,0,30,30))$

     Véase también `palette'.

 -- Opción gráfica: enhanced3d
     Valor por defecto: `false'

     Si `enhanced3d' vale `false', no se colorearán las superficies de
     los gráficos tridimensionales. Si `enhanced3d' vale `true', las
     superficies se colorearán activando el modo pm3d de Gnuplot.  Si
     se da una expresión a `enhanced3d', ésta se utilizará para asignar
     colores de acuerdo con el valor de la opción `palette'; las
     variables de esta expresión deben ser las mismas que luego se
     utilicen para la descripción de la superficie.

     Ejemplos:

          (%i1) load(draw)$
          (%i2) draw3d(
                   surface_hide = true,
                   enhanced3d   = true,
                   palette      = gray,
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$
          (%i3) draw3d(
                   surface_hide = true,
                   /* mismas variables x e y que */
                   /* en explicit mas abajo:     */
                   enhanced3d   = sin(x*y),
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$
          (%i4) draw3d(
                   color = blue,
                   nticks = 60,
                   line_width = 3,
                   enhanced3d = (u-1)^2,
                   parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2))$

 -- Opción gráfica: point_size
     Valor por defecto: 1

     `point_size' establece el tamaño de los puntos dibujados. Debe ser
     un número no negativo.

     Esta opción no tiene efecto alguno cuando a la opción gráfica
     `point_type' se le ha dado el valor `dot'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_size = 5,
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

 -- Opción gráfica: point_type
     Valor por defecto: 1

     `point_type' indica cómo se van a dibujar los puntos aislados. Los
     valores para esta opción pueden ser índices enteros mayores o
     iguales que -1, o también nombres de estilos: `$none' (-1), `dot'
     (0), `plus' (1), `multiply' (2), `asterisk' (3), `square' (4),
     `filled_square' (5), `circle' (6), `filled_circle' (7),
     `up_triangle' (8), `filled_up_triangle' (9), `down_triangle' (10),
     `filled_down_triangle' (11), `diamant' (12) y `filled_diamant'
     (13).

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [0,10],
                       yrange = [0,10],
                       point_size = 3,
                       point_type = diamant,
                       points([[1,1],[5,1],[9,1]]),
                       point_type = filled_down_triangle,
                       points([[1,2],[5,2],[9,2]]),
                       point_type = asterisk,
                       points([[1,3],[5,3],[9,3]]),
                       point_type = filled_diamant,
                       points([[1,4],[5,4],[9,4]]),
                       point_type = 5,
                       points([[1,5],[5,5],[9,5]]),
                       point_type = 6,
                       points([[1,6],[5,6],[9,6]]),
                       point_type = filled_circle,
                       points([[1,7],[5,7],[9,7]]),
                       point_type = 8,
                       points([[1,8],[5,8],[9,8]]),
                       point_type = filled_diamant,
                       points([[1,9],[5,9],[9,9]]) )$

 -- Opción gráfica: points_joined
     Valor por defecto: `false'

     Cuando `points_joined' vale `true', los puntos se unen con
     segmentos; si vale `false', se dibujarán puntos aislados. Un
     tercer valor posible para esta opción gráfica es `impulses'; en
     tal caso, se dibujarán segmentos verticales desde los puntos hasta
     el eje-x (2D) o hasta el plano-xy (3D).

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange        = [0,10],
                       yrange        = [0,4],
                       point_size    = 3,
                       point_type    = up_triangle,
                       color         = blue,
                       points([[1,1],[5,1],[9,1]]),
                       points_joined = true,
                       point_type    = square,
                       line_type     = dots,
                       points([[1,2],[5,2],[9,2]]),
                       point_type    = circle,
                       color         = red,
                       line_width    = 7,
                       points([[1,3],[5,3],[9,3]]) )$

 -- Opción gráfica: filled_func
     Valor por defecto: `false'

     La opción `filled_func' establece cómo se van a rellenar las
     regiones limitadas por funciones. Si `filled_func' vale `true', la
     región limitada por la función definida en el objeto `explicit' y
     el borde inferior del la ventana gráfica se rellena con
     `fill_color'.  Si `filled_func' guarda la expresión de una
     función, entonces la región limitada por esta función y la
     definida en el objeto `explicit' será la que se rellene. Por
     defecto, las funciones explícitas no se rellenan.

     Esta opción sólo afecta al objeto gráfico bidimensional `explicit'.

     Ejemplo:

     Región limitada por un objeto `explicit' y el borde inferior de la
     ventana gráfica.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       filled_func = true,
                       explicit(sin(x),x,0,10) )$

     Región limitada por un objeto `explicit' y la función definida en
     la opción `filled_func'. Nótese que la variable en `filled_func'
     debe ser la misma que la utilizada en `explicit'.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = grey,
                       filled_func = sin(x),
                       explicit(-sin(x),x,0,%pi));

     Véanse también `fill_color' y `explicit'.

 -- Opción gráfica: transparent
     Valor por defecto: `false'

     Cuando `transparent' vale `true', las regiones internas de los
     polígonos se rellenan de acuerdo con `fill_color'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `polygon', `rectangle' y `ellipse'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(polygon([[3,2],[7,2],[5,5]]),
                       transparent = true,
                       color       = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: border
     Valor por defecto: `true'

     Cuando `border' vale `true', los bordes de los polígonos se
     dibujan de acuerdo con `line_type' y `line_width'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `polygon', `rectangle' y `ellipse'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color       = brown,
                       line_width  = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: head_both
     Valor por defecto: `false'

     Cuando `head_both' vale `true', los vectores se dibujan
     bidireccionales.  Si vale `false', se dibujan unidireccionales.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,8],
                       yrange      = [0,8],
                       head_length = 0.7,
                       vector([1,1],[6,0]),
                       head_both   = true,
                       vector([1,7],[6,0]) )$

     Véanse también `head_length', `head_angle' y `head_type'.

 -- Opción gráfica: head_length
     Valor por defecto: 2

     `head_length' indica, en las unidades del eje <x>, la longitud de
     las flechas de los vectores.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,8],
                       vector([0,1],[5,5]),
                       head_length = 1,
                       vector([2,1],[5,5]),
                       head_length = 0.5,
                       vector([4,1],[5,5]),
                       head_length = 0.25,
                       vector([6,1],[5,5]))$

     Véanse también `head_both', `head_angle' y `head_type'.

 -- Opción gráfica: head_angle
     Valor por defecto: 45

     `head_angle' indica el ángulo, en grados, entre la flecha y el
     segmento del vector.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,10],
                       yrange      = [0,9],
                       head_length = 0.7,
                       head_angle  = 10,
                       vector([1,1],[0,6]),
                       head_angle  = 20,
                       vector([2,1],[0,6]),
                       head_angle  = 30,
                       vector([3,1],[0,6]),
                       head_angle  = 40,
                       vector([4,1],[0,6]),
                       head_angle  = 60,
                       vector([5,1],[0,6]),
                       head_angle  = 90,
                       vector([6,1],[0,6]),
                       head_angle  = 120,
                       vector([7,1],[0,6]),
                       head_angle  = 160,
                       vector([8,1],[0,6]),
                       head_angle  = 180,
                       vector([9,1],[0,6]) )$

     Véanse también `head_both', `head_length' y `head_type'.

 -- Opción gráfica: head_type
     Valor por defecto: `filled'

     `head_type' se utiliza para especificar cómo se habrán de dibujar
     las flechas de los vectores. Los valores posibles para esta opción
     son: `filled' (flechas cerradas y rellenas), `empty' (flechas
     cerradas pero no rellenas) y `nofilled' (flechas abiertas).

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_type = 'nofilled,
                       vector([6,1],[5,5]))$

     Véanse también `head_both', `head_angle' y `head_length'.

 -- Opción gráfica: unit_vectors
     Valor por defecto: `false'

     Cuando `unit_vectors' vale `true', los vectores se dibujan con
     módulo unidad.  Esta opción es útil para representar campos
     vectoriales. Cuando `unit_vectors' vale `false', los vectores se
     dibujan con su longitud original.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [-1,6],
                       yrange      = [-1,6],
                       head_length = 0.1,
                       vector([0,0],[5,2]),
                       unit_vectors = true,
                       color        = red,
                       vector([0,3],[5,2]))$

 -- Opción gráfica: label_alignment
     Valor por defecto: `center'

     `label_alignment' se utiliza para especificar dónde se escribirán
     las etiquetas con respecto a las coordenadas de referencia. Los
     valores posibles para esta opción son: `center', `left' y `right'.

     Esta opción sólo es relevante para objetos de tipo `label'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange          = [0,10],
                       yrange          = [0,10],
                       points_joined   = true,
                       points([[5,0],[5,10]]),
                       color           = blue,
                       label(["Centered alignment (default)",5,2]),
                       label_alignment = 'left,
                       label(["Left alignment",5,5]),
                       label_alignment = 'right,
                       label(["Right alignment",5,8]))$

     Véanse también `label_orientation' y `color'.

 -- Opción gráfica: label_orientation
     Valor por defecto: `horizontal'

     `label_orientation' se utiliza para especificar la orientación de
     las etiquetas. Los valores posibles para esta opción son:
     `horizontal' y `vertical'.

     Esta opción sólo es relevante para objetos de tipo `label'.

     Ejemplo:

     En este ejemplo, el punto ficticio que se añade sirve para obtener
     la imagen, ya que el paquete `draw' necesita siempre de datos para
     construir la escena.
          (%i1) load(draw)$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[5,5]]),
                       color      = navy,
                       label(["Horizontal orientation (default)",5,2]),
                       label_orientation = 'vertical,
                       color             = "#654321",
                       label(["Vertical orientation",1,5]))$

     Véanse también `label_alignment' y `color'.

 -- Opción gráfica: color
     Valor por defecto: `"black"'

     `color' especifica el color para dibujar líneas, puntos, bordes de
     polígonos y etiquetas.

     Los colores se pueden dar a partir de sus nombres o en código
     hexadecimal rgb.

     Los nombres de colores disponibles son: `"white"', `"black"',
     `"gray0"', `"grey0"', `"gray10"', `"grey10"', `"gray20"',
     `"grey20"', `"gray30"', `"grey30"', `"gray40"', `"grey40"',
     `"gray50"', `"grey50"', `"gray60"', `"grey60"', `"gray70"',
     `"grey70"', `"gray80"', `"grey80"', `"gray90"', `"grey90"',
     `"gray100"', `"grey100"', `"gray"', `"grey"', `"light-gray"',
     `"light-grey"', `"dark-gray"', `"dark-grey"', `"red"',
     `"light-red"', `"dark-red"', `"yellow"', `"light-yellow"',
     `"dark-yellow"', `"green"', `"light-green"', `"dark-green"',
     `"spring-green"', `"forest-green"', `"sea-green"', `"blue"',
     `"light-blue"', `"dark-blue"', `"midnight-blue"', `"navy"',
     `"medium-blue"', `"royalblue"', `"skyblue"', `"cyan"',
     `"light-cyan"', `"dark-cyan"', `"magenta"', `"light-magenta"',
     `"dark-magenta"', `"turquoise"', `"light-turquoise"',
     `"dark-turquoise"', `"pink"', `"light-pink"', `"dark-pink"',
     `"coral"', `"light-coral"', `"orange-red"', `"salmon"',
     `"light-salmon"', `"dark-salmon"', `"aquamarine"', `"khaki"',
     `"dark-khaki"', `"goldenrod"', `"light-goldenrod"',
     `"dark-goldenrod"', `"gold"', `"beige"', `"brown"', `"orange"',
     `"dark-orange"', `"violet"', `"dark-violet"', `"plum"' y
     `"purple"'.

     Las componentes cromáticas en código hexadecimal se introducen en
     el formato `"#rrggbb"'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default is black */
                       color = "red",
                       explicit(0.5 + x^2,x,-1,1),
                       color = blue,
                       explicit(1 + x^2,x,-1,1),
                       color = "light-blue", /* double quotes if - is used */
                       explicit(1.5 + x^2,x,-1,1),
                       color = "#23ab0f",
                       label(["This is a label",0,1.2])  )$

     Véase también `fill_color'.

 -- Opción gráfica: fill_color
     Valor por defecto: `"red"'

     `fill_color' especifica el color para rellenar polígonos y
     funciones explícitas bidimensionales.

     Véase `color' para más información sobre cómo definir colores.

 -- Opción gráfica: fill_density
     Valor por defecto: 0

     `fill_density' es un número entre 0 y 1 que especifica la
     intensidad del color de relleno (dado por `fill_color') en los
     objetos `bars'.

     Véase `bars' para ejemplos.

 -- Opción gráfica: line_width
     Valor por defecto: 1

     `line_width' es el ancho de las líneas a dibujar.  Su valor debe
     ser un número positivo.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points' y `parametric'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default width */
                       line_width = 5.5,
                       explicit(1 + x^2,x,-1,1),
                       line_width = 10,
                       explicit(2 + x^2,x,-1,1))$

     Véase también `line_type'.

 -- Opción gráfica: line_type
     Valor por defecto: `solid'

     `line_type' indica cómo se van a dibujar las líneas; valores
     posibles son `solid' y `dots'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points', `explicit', `parametric' y
          `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_type = dots,
                       explicit(1 + x^2,x,-1,1),
                       line_type = solid, /* default */
                       explicit(2 + x^2,x,-1,1))$

     Véase también `line_width'.

 -- Opción gráfica: nticks
     Valor por defecto: 29

     En 2d, `nticks' es el número de puntos a utilizar por el programa
     adaptativo que genera las funciones explícitas. También es el
     número de puntos que se representan en las curvas paramétricas y
     polares.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `ellipse', `explicit', `parametric' y `polar'.

        * `gr3d': `parametric'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = true,
                       ellipse(0,0,4,2,0,180),
                       nticks = 5,
                       ellipse(0,0,4,2,180,180) )$

 -- Opción gráfica: adapt_depth
     Valor por defecto: 10

     `adapt_depth' es el número máximo de particiones utilizadas por la
     rutina gráfica adaptativa.

     Esta opción sólo es relevante para funciones de tipo `explicit' en
     2d.

 -- Opción gráfica: key
     Valor por defecto: `""' (cadena vacía)

     `key' es la clave de una función en la leyenda. Si `key' es una
     cadena vacía, las funciones no tendrán clave asociada en la
     leyenda.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points', `explicit', `parametric', y
          `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(key   = "Sinus",
                       explicit(sin(x),x,0,10),
                       key   = "Cosinus",
                       color = red,
                       explicit(cos(x),x,0,10) )$

 -- Opción gráfica: xu_grid
     Valor por defecto: 30

     `xu_grid' es el número de coordenadas de la primera variable (`x'
     en superficies explcítas y `u' en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr3d': `explicit' y `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también `yv_grid'.

 -- Opción gráfica: yv_grid
     Valor por defecto: 30

     `yv_grid' es el número de coordenadas de la segunda variable (`y'
     en superficies explcítas y `v' en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr3d': `explicit' y `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también `xu_grid'.

 -- Opción gráfica: surface_hide
     Valor por defecto: `false'

     Cuando `surface_hide' vale `true', las partes ocultas no se
     muestran en las superficies de las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw(columns=2,
                     gr3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)),
                     gr3d(surface_hide = true,
                          explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)) )$

 -- Opción gráfica: contour
     Valor por defecto: `none'

     La opción `contour' permite al usuario decidir dónde colocar las
     líneas de nivel.  Valores posibles son:

        * `none': no se dibujan líneas de nivel.

        * `base': las líneas de nivel se proyectan sobre el plano xy.

        * `surface': las líneas de nivel se dibujan sobre la propia
          superficie.

        * `both': se dibujan dos conjuntos de líneas de nivel: sobre la
          superficie y las que se proyectan sobre el plano xy.

        * `map': las líneas de nivel se proyectan sobre el plano xy y
          el punto de vista del observador se coloca perpendicularmente
          a él.


     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

     Véase también `contour_levels'.

 -- Opción gráfica: contour_levels
     Valor por defecto: 5

     Esta opción gráfica controla cómo se dibujarán las líneas de
     nivel. A `contour_levels' se le puede asignar un número entero
     positivo, una lista de tres números o un conjunto numérico
     arbitrario:

        * Si a `contour_levels' se le asigna un entero positivo <n>,
          entonces se dibujarán <n> líneas de nivel a intervalos
          iguales. Por defecto, se dibujaán cinco isolíneas.

        * Si a `contour_levels' se le asigna una lista de tres números
          de la forma `[inf,p,sup]', las isolíneas se dibujarán desde
          `inf' hasta `sup' en pasos de amplitud `p'.

        * Si a `contour_levels' se le asigna un conjunto de números de
          la forma `{n1, n2, ...}', entonces se dibujarán las isolíneas
          correspondientes a los niveles `n1', `n2', ...

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Diez isolíneas igualmente espaciadas. El número real puede
     ajustarse a fin de poder conseguir etiquetas más sencillas.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 10,
                       contour        = both,
                       surface_hide   = true) $

     Desde -8 hasta 8 en pasos de amplitud 4.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = [-8,4,8],
                       contour        = both,
                       surface_hide   = true) $

     Líneas correspondientes a los niveles -7, -6, 0.8 y 5.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = {-7, -6, 0.8, 5},
                       contour        = both,
                       surface_hide   = true) $

     Véase también `contour'.

 -- Opción gráfica: columns
     Valor por defecto: 1

     `columns' es el número de columnas en gráficos múltiples.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$


 -- Opción gráfica: ip_grid
     Valor por defecto: `[50, 50]'

     `ip_grid' establece la rejilla del primer muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo `implicit'.

 -- Opción gráfica: ip_grid_in
     Valor por defecto: `[5, 5]'

     `ip_grid_in' establece la rejilla del segundo muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo `implicit'.

 -- Opción gráfica: x_voxel
     Valor por defecto: 10

     `x_voxel' es el número de voxels en la dirección x a utilizar por
     el algoritmo marching cubes implementado por el objeto `implicit'
     tridimensional.

 -- Opción gráfica: y_voxel
     Valor por defecto: 10

     `y_voxel' es el número de voxels en la dirección y a utilizar por
     el algoritmo marching cubes implementado por el objeto `implicit'
     tridimensional.

 -- Opción gráfica: z_voxel
     Valor por defecto: 10

     `z_voxel' es el número de voxels en la dirección z a utilizar por
     el algoritmo marching cubes implementado por el objeto `implicit'
     tridimensional.

 -- Función: set_draw_defaults (<Opción gráfica>, ..., <Opción
          gráfica>, ...)
     Establece las opciones gráficas de usuario. Esta función es útil
     para dibujar varios gráficos con las mismas opciones. Llamando a
     la función sin argumentos se borran las opciones de usuario por
     defecto.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) set_draw_defaults(
                   xrange = [-10,10],
                   yrange = [-2, 2],
                   color  = blue,
                   grid   = true)$
          (%i3) /* dibujo con opciones de usuario */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$
          (%i4) set_draw_defaults()$
          (%i5) /* dibujo con opciones por defecto */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$

     Para utilizar esta función, ejecútese primero `load(draw)'.

 -- Constructor de escena: gr2d (<Opción gráfica>, ...,
          <graphic_object>, ...)
     La función `gr2d' construye un objeto que describe una escena 2d.
     Los argumentos son opciones gráficas y objetos gráficos. Esta
     escena se interpreta secuencialmente: las opciones gráficas
     afectan a aquellos objetos gráficos colocados a su derecha.
     Algunas opciones gráficas afectan al aspecto global de la escena.

     La lista de objetos gráficos disponibles para escenas en dos
     dimensiones: `points', `polygon', `rectangle', `ellipse', `label',
     `vector', `explicit', `implicit', `polar', `parametric', `image' y
     `geomap'.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Véanse también las siguientes opciones gráficas: `xrange',
     `yrange', `logx', `logy', `terminal', `grid', `title', `xlabel',
     `ylabel', `xtics', `ytics', `xtics_rotate', `ytics_rotate',
     `xtics_axis', `ytics_axis', `xaxis', `yaxis', `xaxis_width',
     `yaxis_width', `xaxis_type', `yaxis_type', `xaxis_color',
     `yaxis_color', `xy_file', `file_name', `pic_width', `pic_height',
     `eps_width', `eps_height', `user_preamble', `axis_bottom',
     `axis_left', `axis_top' y `axis_right'.

 -- Constructor de escena: gr3d (<Opción gráfica>, ...,
          <graphic_object>, ...)
     La función `gr3d' construye un objeto que describe una escena 3d.
     Los argumentos son opciones gráficas y objetos gráficos. Esta
     escena se interpreta secuencialmente: las opciones gráficas
     afectan a aquellos objetos gráficos colocados a su derecha.
     Algunas opciones gráficas afectan al aspecto global de la escena.

     La lista de objetos gráficos disponibles para escenas en tres
     dimensiones: `points', `label', `vector', `explicit', `implicit',
     `parametric', `parametric_surface' y `geomap'.

     Véanse también las siguientes opciones gráficas: `xrange',
     `yrange', `zrange', `logx', `logy', `logz', `terminal', `grid',
     `title', `xlabel', `ylabel', `zlabel', `xtics', `ytics', `ztics',
     `xtics_rotate', `ytics_rotate', `ztics_rotate', `xtics_axis',
     `ytics_axis', `ztics_axis', `xaxis', `yaxis', `zaxis',
     `xaxis_width', `yaxis_width', `zaxis_width', `xaxis_type',
     `yaxis_type', `zaxis_type', `xaxis_color', `yaxis_color',
     `zaxis_color', `xy_file', `user_preamble', `axis_bottom',
     `axis_left', `axis_top', `file_name', `pic_width', `pic_height',
     `eps_width', `eps_height', `axis_right', `rot_vertical',
     `rot_horizontal', `axis_3d', `xu_grid', `yv_grid', `surface_hide',
     `contour', `contour_levels', `palette', `colorbox' y `enhanced3d'.

     Para utilizar esta función, ejecútese primero `load(draw)'.

 -- Objeto gráfico: points ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Objeto gráfico: points ([<x1>,<x2>,...], [<y1>,<y2>,...])
 -- Objeto gráfico: points ([<y1>,<y2>,...])
 -- Objeto gráfico: points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])
 -- Objeto gráfico: points ([<x1>,<x2>,...], [<y1>,<y2>,...],
          [<z1>,<z2>,...])
 -- Objeto gráfico: points (<matrix>)
 -- Objeto gráfico: points (<1d_y_array>)
 -- Objeto gráfico: points (<1d_x_array>, <1d_y_array>)
 -- Objeto gráfico: points (<1d_x_array>, <1d_y_array>, <1d_z_array>)
 -- Objeto gráfico: points (<2d_xy_array>)
 -- Objeto gráfico: points (<2d_xyz_array>)
     Dibuja puntos en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `point_size', `point_type', `points_joined', `line_width', `key',
     `line_type' y `color'. En modo 3D también se ve afectado por
     `enhanced3d'.

     2D

     `points ([[<x1>,<y1>], [<x2>,<y2>],...])' o `points
     ([<x1>,<x2>,...], [<y1>,<y2>,...])' dibuja los puntos
     `[<x1>,<y1>]', `[<x2>,<y2>]', etc. Si no se dan las abscisas,
     éstas se asignan automáticamente a enteros positivos consecutivos,
     de forma que `points([<y1>,<y2>,...])' dibuja los puntos
     `[1,<y1>]', `[2,<y2>]', etc.  Si <matrix> es una matriz de dos
     columnas o de dos filas, `points (<matrix>)' dibuja los puntos
     asociados.

     Si <1d_y_array> es un array lisp de números en 1D, `points
     (<1d_y_array>)' los dibujará asignando las abscisas a números
     enteros consecutivos.  `points (<1d_x_array>, <1d_y_array>)'
     dibuja los puntos cuyas coordenadas se toman de los dos arrays
     pasados como argumentos. Si <2d_xy_array> es un array lisp 2D de
     dos filas, o de dos columnas, `points (<2d_xy_array>)' dibuja los
     correspondientes puntos del plano.

     Ejemplos:

     Dos tipos de argumentos para `points', una lista de pares ordenados
     y dos listas con las coordenadas separadas.
          (%i1) load(draw)$
          (%i2) draw2d(
                  key = "Small points",
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_type    = circle,
                  point_size    = 3,
                  points_joined = true,
                  key           = "Great points",
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)),
                  point_type    = filled_down_triangle,
                  key           = "Automatic abscissas",
                  color         = red,
                  points([2,12,8]))$

     Dibujando impulsos.
          (%i1) load(draw)$
          (%i2) draw2d(
                  points_joined = impulses,
                  line_width    = 2,
                  color         = red,
                  points(makelist([random(20),random(50)],k,1,10)))$

     Array con ordenadas.
          (%i1) load(draw)$
          (%i2) a: make_array (flonum, 100) $
          (%i3) for i:0 thru 99 do a[i]: random(1.0) $
          (%i4) draw2d(points(a)) $

     Dos arrays con coordenadas separadas.
          (%i1) load(draw)$
          (%i2) x: make_array (flonum, 100) $
          (%i3) y: make_array (fixnum, 100) $
          (%i4) for i:0 thru 99 do (
                  x[i]: float(i/100),
                  y[i]: random(10) ) $
          (%i5) draw2d(points(x, y)) $

     Un array 2D de dos columnas.
          (%i1) load(draw)$
          (%i2) xy: make_array(flonum, 100, 2) $
          (%i3) for i:0 thru 99 do (
                  xy[i, 0]: float(i/100),
                  xy[i, 1]: random(10) ) $
          (%i4) draw2d(points(xy)) $

     Dibujando un array rellenado con la función `read_array'.
          (%i1) load(draw)$
          (%i2) a: make_array(flonum,100) $
          (%i3) read_array (file_search ("pidigits.data"), a) $
          (%i4) draw2d(points(a)) $

     3D

     `points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])' o `points
     ([<x1>,<x2>,...], [<y1>,<y2>,...], [<z1>,<z2>,...])' dibuja los
     puntos `[<x1>,<y1>,<z1>]', `[<x2>,<y2>,<z2>]', etc.  Si <matrix>
     es una matriz de tres columnas o de tres filas, `points (<matrix>)'
     dibuja los puntos asociados. Si <matrix> es una matriz columna o
     fila, las abscisas se asignan automáticamente.

     En caso de que los argumentos sean arrays lisp, `points
     (<1d_x_array>, <1d_y_array>, <1d_z_array>)' toma las coordenadas
     de los tres arrays unidimensionales. Si <2d_xyz_array> es un array
     2D de tres columnas, o de tres filas, entonces `points
     (<2d_xyz_array>)' dibuja los puntos correspondientes.

     Ejemplos:

     Una muestra tridimensional,
          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(title = "Daily average wind speeds",
                       point_size = 2,
                       points(args(submatrix (s2, 4, 5))) )$

     Dos muestras tridimensionales,
          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(
                   title = "Daily average wind speeds. Two data sets",
                   point_size = 2,
                   key        = "Sample from stations 1, 2 and 3",
                   points(args(submatrix (s2, 4, 5))),
                   point_type = 4,
                   key        = "Sample from stations 1, 4 and 5",
                   points(args(submatrix (s2, 2, 3))) )$

     Arrays unidimensionales,
          (%i1) load(draw)$
          (%i2) x: make_array (fixnum, 10) $
          (%i3) y: make_array (fixnum, 10) $
          (%i4) z: make_array (fixnum, 10) $
          (%i5) for i:0 thru 9 do (
                  x[i]: random(10),
                  y[i]: random(10),
                  z[i]: random(10) ) $
          (%i6) draw3d(points(x,y,z)) $

     Array bidimensional coloreado,
          (%i1) load(draw)$
          (%i2) xyz: make_array(fixnum, 10, 3) $
          (%i3) for i:0 thru 9 do (
                  xyz[i, 0]: random(10),
                  xyz[i, 1]: random(10),
                  xyz[i, 2]: random(10) ) $
          (%i4) draw3d(
                   enhanced3d = true,
                   points_joined = true,
                   points(xyz)) $


 -- Objeto gráfico: polygon ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Objeto gráfico: polygon ([<x1>,<x2>,...], [<y1>,<y2>,...])
     Dibuja polígonos en 2D.

     2D

     `polygon ([[<x1>,<y1>], [<x2>,<y2>],...])' o `polygon
     ([<x1>,<x2>,...], [<y1>,<y2>,...])': dibuja en el plano un
     polígono de vértices `[<x1>,<y1>]', `[<x2>,<y2>]', etc..

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `transparent', `fill_color', `border', `line_width', `key',
     `line_type' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color      = "#e245f0",
                       line_width = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = yellow,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Objeto gráfico: rectangle ([<x1>,<y1>], [<x2>,<y2>])
     Dibuja rectángulos en 2D.

     2D

     `rectangle ([<x1>,<y1>], [<x2>,<y2>])' dibuja un rectángulo de
     vértices opuestos `[<x1>,<y1>]' y `[<x2>,<y2>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `transparent', `fill_color', `border', `line_width', `key',
     `line_type' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       line_width  = 6,
                       line_type   = dots,
                       transparent = false,
                       fill_color  = blue,
                       rectangle([-2,-2],[8,-1]), /* opposite vertices */
                       transparent = true,
                       line_type   = solid,
                       line_width  = 1,
                       rectangle([9,4],[2,-1.5]),
                       xrange      = [-3,10],
                       yrange      = [-3,4.5] )$

 -- Objeto gráfico: bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])
     Dibuja barras verticales en 2D.

     2D

     `bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])' dibuja barras
     centradas en los valores <x1>, <x2>, ... de alturas <h1>, <h2>, ...
     y anchos <w1>, <w2>, ...

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `key', `fill_color', `fill_density' y `line_width'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                 key          = "Grupo A",
                 fill_color   = blue,
                 fill_density = 0.2,
                 bars([0.8,5,0.4],[1.8,7,0.4],[2.8,-4,0.4]),
                 key          = "Grupo B",
                 fill_color   = red,
                 fill_density = 0.6,
                 line_width   = 4,
                 bars([1.2,4,0.4],[2.2,-2,0.4],[3.2,5,0.4]),
                 xaxis = true);

 -- Objeto gráfico: ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)
     Dibuja elipses y círculos en 2D.

     2D

     `ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)' dibuja una elipse
     de centro `[<xc>, <yc>]' con semiejes horizontal y vertical <a> y
     <b>, respectivamente, comenzando en el ángulo <ang1> y trazando un
     arco de amplitud igual al ángulo <ang2>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `transparent', `fill_color', `border', `line_width',
     `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = false,
                       fill_color  = red,
                       color       = gray30,
                       transparent = false,
                       line_width  = 5,
                       ellipse(0,6,3,2,270,-270),
                       /* center (x,y), a, b, start & end in degrees */
                       transparent = true,
                       color       = blue,
                       line_width  = 3,
                       ellipse(2.5,6,2,3,30,-90),
                       xrange      = [-3,6],
                       yrange      = [2,9] )$

 -- Objeto gráfico: label ([<string>,<x>,<y>],...)
 -- Objeto gráfico: label ([<string>,<x>,<y>,<z>],...)
     Escribe etiquetas en 2D y 3D.

     Las etiquetas coloreadas sólo trabajan con Gnuplot 4.3. Este es un
     fallo conocido del paquete `draw'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `label_alignment', `label_orientation' y `color'.

     2D

     `label([<string>,<x>,<y>])' escribe la cadena de caracteres
     <string> en el punto `[<x>,<y>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [0.1,1.4],
                       color = "red",
                       label(["Label in red",0,0.3]),
                       color = "#0000ff",
                       label(["Label in blue",0,0.6]),
                       color = "light-blue",
                       label(["Label in light-blue",0,0.9],
                             ["Another light-blue",0,1.2])  )$

     3D

     `label([<string>,<x>,<y>,<z>])' escribe la cadena de caracteres
     <string> en el punto `[<x>,<y>,<z>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = red,
                       label(["UP 1",-2,0,3], ["UP 2",1.5,0,4]),
                       color = blue,
                       label(["DOWN 1",2,0,-3]) )$

 -- Objeto gráfico: vector ([<x>,<y>], [<dx>,<dy>])
 -- Objeto gráfico: vector ([<x>,<y>,<z>], [<dx>,<dy>,<dz>])
     Dibuja vectores en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `head_both', `head_length', `head_angle', `head_type',
     `line_width', `line_type', `key' y `color'.

     2D

     `vector ([<x>,<y>], [<dx>,<dy>])' dibuja el vector `[<dx>,<dy>]'
     con origen en `[<x>,<y>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_both = true,
                       head_type = 'nofilled,
                       line_type = dots,
                       vector([6,1],[5,5]))$

     3D

     `vector([<x>,<y>,<z>], [<dx>,<dy>,<dz>])' dibuja el vector
     `[<dx>,<dy>,<dz>]' con origen en `[<x>,<y>,<z>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(color = cyan,
                       vector([0,0,0],[1,1,1]/sqrt(3)),
                       vector([0,0,0],[1,-1,0]/sqrt(2)),
                       vector([0,0,0],[1,1,-2]/sqrt(6)) )$

 -- Objeto gráfico: explicit (<fcn>,<var>,<minval>,<maxval>)
 -- Objeto gráfico: explicit
          (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)
     Dibuja funciones explícitas en 2D y 3D.

     2D

     `explicit (<fcn>,<var>,<minval>,<maxval>)' dibuja la función
     explícita <fcn>, con la variable <var> tomando valores desde
     <minval> hasta <maxval>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `adapt_depth', `line_width', `line_type', `key',
     `filled_func', `fill_color' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_width = 3,
                       color      = blue,
                       explicit(x^2,x,-3,3) )$
          (%i3) draw2d(fill_color  = brown,
                       filled_func = true,
                       explicit(x^2,x,-3,3) )$

     3D

     `explicit
     (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)'
     dibuja la función explícita <fcn>, con la variable `var1' tomando
     valores desde <minval1> hasta <maxval1> y la variable <var2>
     tomando valores desde <minval2> hasta <maxval2>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `line_width', `key',
     `enhanced3d'  y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(key   = "Gauss",
                       color = "#a02c00",
                       explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                       yv_grid     = 10,
                       color = blue,
                       key   = "Plane",
                       explicit(x+y,x,-5,5,y,-5,5),
                       surface_hide = true)$

     Véase también `filled_func' para el relleno de curvas.

 -- Objeto gráfico: mesh (<mat>,<x0>,<y0>,<width>,<height>)
     Dibuja la matriz <mat> en 3D. Los valores <z> se toman de <mat>,
     las abscisas van desde <x0> hasta <x0> + <width> y las ordenadas
     desde <y0> hasta <y0> + <height>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_type', `line_width', `key', `enhanced3d' y `color'.

     Este objeto gráfico ignora valores de `enhanced3d' distintos de
     `true' o `false'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) m: apply(
                      matrix,
                      makelist(makelist(random(10.0),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   color = blue,
                   mesh(m,0,0,3,2),
                   xlabel = "x",
                   ylabel = "y",
                   surface_hide = true);


 -- Objeto gráfico: implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)
 -- Objeto gráfico: implicit
          (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>,<z>,<zmin>,<zmax>)
     Dibuja funciones implícitas en 2D y 3D.

     2D

     `implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)' dibuja la
     función implícita <fcn>, con la variable `x' tomando valores desde
     <xmin> hasta <xmax>, y la variable <y> tomando valores desde
     <ymin> hasta <ymax>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `ip_grid', `ip_grid_in', `line_width', `line_type', `key' y
     `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal  = eps,
                       grid      = true,
                       line_type = solid,
                       key       = "y^2=x^3-2*x+1",
                       implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,4),
                       line_type = dots,
                       key       = "x^3+y^3 = 3*x*y^2-x-1",
                       implicit(x^3+y^3 = 3*x*y^2-x-1, x,-4,4, y,-4,4),
                       title     = "Two implicit functions" )$

     3D

     `implicit (<fcn>,<x>,<xmin>,<xmax>, <y>,<ymin>,<ymax>,
     <z>,<zmin>,<zmax>)' dibuja la función implícita <fcn>, con la
     variable <x> tomando valores desde <xmin> hasta <xmax>, la
     variable <y> tomando valores desde <ymin> hasta <ymax> y la
     variable <z> tomando valores desde <zmin> hasta <zmax>. Este
     objeto está programado con el algoritmo marching cubes.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `x_voxel', `y_voxel', `z_voxel', `line_width', `line_type', `key'
     y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  color=blue,
                  implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                           x,-1,1,y,-1.2,2.3,z,-1,1),
                  surface_hide=true);

 -- Objeto gráfico: polar (<radius>,<ang>,<minang>,<maxang>)
     Dibuja funciones 2D definidas en coordenadas polares.

     2D

     `polar (<radius>,<ang>,<minang>,<maxang>)' dibuja la función
     `<radius>(<ang>)' definida en coordenadas polares, con la variable
     <ang> tomando valores desde <minang> hasta <maxang>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `line_width', `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(user_preamble = "set grid polar",
                       nticks        = 200,
                       xrange        = [-5,5],
                       yrange        = [-5,5],
                       color         = blue,
                       line_width    = 3,
                       title         = "Hyperbolic Spiral",
                       polar(10/theta,theta,1,10*%pi) )$

 -- Objeto gráfico: spherical
          (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)
     Dibuja funciones 3D definidas en coordenadas esféricas.

     3D

     `spherical
     (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)' dibuja
     la función `<radius>(<azi>,<zen>)' definida en coordenadas
     esféricas, con el azimut <azi> tomando valores desde <minazi>
     hasta <maxazi> y el zenit <zen> tomando valores desde <minzen>
     hasta <maxzen>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(spherical(1,a,0,2*%pi,z,0,%pi))$

 -- Objeto gráfico: cylindrical
          (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)
     Dibuja funciones 3D definidas en coordenadas cilíndricas.

     3D

     `cylindrical (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)'
     dibuja la función `<radius>(<z>,<azi>)' definida en coordenadas
     cilíndricas, con la variable <z> tomando valores desde <minz>
     hasta <maxz> y el azimut <azi> tomando valores desde <minazi>
     hasta <maxazi>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(cylindrical(1,z,-2,2,az,0,2*%pi))$

 -- Objeto gráfico: parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)
 -- Objeto gráfico: parametric
          (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)
     Dibuja funciones paramétricas en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `line_width', `line_type', `key', `color' y `enhanced3d'.

     2D

     `parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)' dibuja la
     función paramétrica `[<xfun>,<yfun>]', con el parámetro <par>
     tomando valores desde <parmin> hasta <parmax>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x),x,-1,3),
                       color = red,
                       key   = "This is the parametric one!!",
                       parametric(2*cos(rrr),rrr^2,rrr,0,2*%pi))$

     3D

     `parametric (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)' dibuja
     la curva paramétrica `[<xfun>,<yfun>,<zfun>]', con el parámetro
     <par> tomando valores desde <parmin> hasta <parmax>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = royalblue,
                       parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2),
                       color      = turquoise,
                       line_width = 2,
                       parametric(t^2,sin(t),2+t,t,0,2),
                       surface_hide = true,
                       title = "Surface & curves" )$

 -- Objeto gráfico: image (<im>,<x0>,<y0>,<width>,<height>)
     Reproduce una imagen en 2D.

     2D

     `image (<im>,<x0>,<y0>,<width>,<height>)': dibuja la imagen <im>
     en la región rectangular desde el vértice <(X0,Y0)> hasta el
     `(x0+<width>,y0+<height>)' del plano real. El argumento <im> debe
     ser una matriz de números reales, una matriz de vectores de
     longitud tres o un objeto de tipo `picture'.

     Si <im> es una matriz de números reales, los valores de los
     píxeles se interpretan según indique la opción gráfica `palette',
     que es un vector de longitud tres con sus componentes tomando
     valores enteros en el rango desde -36 a +36; cada valor es un
     índice para seleccionar una fórmula que transforma los niveles
     numéricos en las componentes cromáticas rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84
          32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de
     las componentes cromáticas.

     `palette = gray' y `palette = color' son atajos para `palette =
     [3,3,3]' y `palette = [7,5,15]', respectivamente.

     Si <im> es una matriz de vectores de longitud tres, éstos se
     interpretarán como las componentes cromáticas rojo, verde y azul.

     Ejemplos:

     Si <im> es una matriz de números reales, los valores de los
     píxeles se interpretan según indique la opción gráfica `palette'.
          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     Véase también `colorbox'.

     Si <im> es una matriz de vectores de longitud tres, éstos se
     interpretarán como las componentes cromáticas rojo, verde y azul.
          (%i1) load(draw)$
          (%i2) im: apply(
                      'matrix,
                       makelist(
                         makelist([random(300),
                                   random(300),
                                   random(300)],i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$

     El paquete `draw' carga automáticamente el paquete `picture'.  En
     este ejemplo, una imagen de niveles se define a mano,
     reproduciéndola a continuación.
          (%i1) load(draw)$
          (%i2) im: make_level_picture([45,87,2,134,204,16],3,2);
          (%o2)       picture(level, 3, 2, {Array:  #(45 87 2 134 204 16)})
          (%i3) /* default color palette */
                draw2d(image(im,0,0,30,30))$
          (%i4) /* gray palette */
                draw2d(palette = gray,
                       image(im,0,0,30,30))$

     Se lee un fichero xpm y se reproduce.
          (%i1) load(draw)$
          (%i2) im: read_xpm("myfile.xpm")$
          (%i3) draw2d(image(im,0,0,10,7))$

     Véanse también `make_level_picture', `make_rgb_picture' y
     `read_xpm'.

     En `http://www.telefonica.net/web2/biomates/maxima/gpdraw/image'
     se encuentran ejemplos más elaborados.

 -- Global variable: boundaries_array
     Valor por defecto: `false'

     `boundaries_array' es donde el objeto gráfico `geomap' lee las
     coordenadas de las líneas fronterizas.

     Cada componente de `boundaries_array' es un array de números
     decimales en coma flotante representando las coordenadas que
     definen un segmento poligonal o línea fronteriza.

     Véase también `geomap'.

 -- Objeto gráfico: geomap (<numlist>)
 -- Objeto gráfico: geomap (<numlist>,<3Dprojection>)
     Dibuja mapas cartográficos en 2D y 3D.

     2D

     Esta función trabaja junto con la variable global
     `boundaries_array'.

     El argumento <numlist> es una lista de números o de listas de
     números. Todos estos números deben ser enteros mayores o iguales
     que cero, representando las componentes del array global
     `boundaries_array'.

     Cada componente de `boundaries_array' es un array de decimales en
     coma flotante, las coordenadas de un segmento poligonal o línea
     fronteriza.

     `geomap (<numlist>)' toma los enteros de sus argumentos y dibuja
     los segmentos poligonales asociados de `boundaries_array'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_width', `line_type' y `color'.

     Ejemplos:

     Un sencillo mapa hecho a mano:
          (%i1) load(draw)$
          (%i2) /* Vertices of boundary #0: {(1,1),(2,5),(4,3)} */
             ( bnd0: make_array(flonum,6),
               bnd0[0]:1.0, bnd0[1]:1.0, bnd0[2]:2.0,
               bnd0[3]:5.0, bnd0[4]:4.0, bnd0[5]:3.0 )$
          (%i3) /* Vertices of boundary #1: {(4,3),(5,4),(6,4),(5,1)} */
             ( bnd1: make_array(flonum,8),
               bnd1[0]:4.0, bnd1[1]:3.0, bnd1[2]:5.0, bnd1[3]:4.0,
               bnd1[4]:6.0, bnd1[5]:4.0, bnd1[6]:5.0, bnd1[7]:1.0)$
          (%i4) /* Vertices of boundary #2: {(5,1), (3,0), (1,1)} */
             ( bnd2: make_array(flonum,6),
               bnd2[0]:5.0, bnd2[1]:1.0, bnd2[2]:3.0,
               bnd2[3]:0.0, bnd2[4]:1.0, bnd2[5]:1.0 )$
          (%i5) /* Vertices of boundary #3: {(1,1), (4,3)} */
             ( bnd3: make_array(flonum,4),
               bnd3[0]:1.0, bnd3[1]:1.0, bnd3[2]:4.0, bnd3[3]:3.0)$
          (%i6) /* Vertices of boundary #4: {(4,3), (5,1)} */
             ( bnd4: make_array(flonum,4),
               bnd4[0]:4.0, bnd4[1]:3.0, bnd4[2]:5.0, bnd4[3]:1.0)$
          (%i7) /* Pack all together in boundaries_array */
             ( boundaries_array: make_array(any,5),
               boundaries_array[0]: bnd0, boundaries_array[1]: bnd1,
               boundaries_array[2]: bnd2, boundaries_array[3]: bnd3,
               boundaries_array[4]: bnd4 )$
          (%i8) draw2d(geomap([0,1,2,3,4]))$

     El paquete auxiliar `worldmap' asigna al array global
     `boundaries_array' líneas fronterizas reales en coordenadas
     (longitud, latitud). Estos datos son de dominio público y proceden
     de `http://www-cger.nies.go.jp/grid-e/gridtxt/grid19.html'.  El
     paquete `worldmap' también define fronteras de países, continentes
     y líneas costeras a partir de las componentes de
     `boundaries_array' (véase el fichero `share/draw/worldmap.mac'
     para más información). El paquete `worldmap' carga automáticamente
     el paquete `draw'.
          (%i1) load(worldmap)$
          (%i2) c1: gr2d(geomap(Canada,United_States,
                                Mexico,Cuba))$
          (%i3) c2: gr2d(geomap(Africa))$
          (%i4) c3: gr2d(geomap(Oceania,China,Japan))$
          (%i5) c4: gr2d(geomap(France,Portugal,Spain,
                                Morocco,Western_Sahara))$
          (%i6) draw(columns  = 2,
                     c1,c2,c3,c4)$

     `worldmap' se puede utilizar para dibujar países como polígonos.
     En este caso, ya no será necesario hacer uso del objeto gráfico
     `geomap', pero sí de `polygon'. Puesto que en este caso se
     utilizan listas en lugar de arrays, los mapas se reproducirán de
     forma más lenta. Véanse también `make_poly_country' y
     `make_poly_continent' para comprender el siguiente código.
          (%i1) load(worldmap)$
          (%i2) mymap: append(
             [color      = white],  /* borders are white */
             [fill_color = red],             make_poly_country(Bolivia),
             [fill_color = cyan],            make_poly_country(Paraguay),
             [fill_color = green],           make_poly_country(Colombia),
             [fill_color = blue],            make_poly_country(Chile),
             [fill_color = "#23ab0f"],       make_poly_country(Brazil),
             [fill_color = goldenrod],       make_poly_country(Argentina),
             [fill_color = "midnight-blue"], make_poly_country(Uruguay))$
          (%i3) apply(draw2d, mymap)$

     3D

     `geomap (<numlist>)' proyecta los mapas sobre la esfera de radio 1
     y centro (0,0,0). Es posible cambiar la esfera o el tipo de
     proyección haciendo uso de `geomap (<numlist>,<3Dprojection>)'.

     Proyecciones 3D disponibles:

        * `[spherical_projection,<x>,<y>,<z>,<r>]': proyecta los mapas
          sobre la esfera de radio <r> y centro (<x>,<y>,<z>).
               (%i1) load(worldmap)$
               (%i2) draw3d(geomap(Australia), /* default projection */
                            geomap(Australia,
                                   [spherical_projection,2,2,2,3]))$

        * `[cylindrical_projection,<x>,<y>,<z>,<r>,<rc>]': re-proyecta
          mapas esféricos sobre el cilindro de radio <rc> cuyo eje pasa
          a través de los polos del globo de radio <r> y centro
          (<x>,<y>,<z>).
               (%i1) load(worldmap)$
               (%i2) draw3d(geomap([America_coastlines,Eurasia_coastlines],
                                   [cylindrical_projection,2,2,2,3,4]))$

        * `[conic_projection,<x>,<y>,<z>,<r>,<alpha>]': re-proyecta
          mapas esféricos sobre los conos de ángulo <alpha>, cuyos ejes
          pasan a través de los polos del globo de radio <r> y centro
          (<x>,<y>,<z>). Ambos conos, norte y sur, son tangentes a la
          esfera.
               (%i1) load(worldmap)$
               (%i2) draw3d(geomap(World_coastlines,
                                   [conic_projection,0,0,0,1,90]))$

     En `http://www.telefonica.net/web2/biomates/maxima/gpdraw/geomap'
     hay ejemplos más elaborados.

 -- Objeto gráfico: parametric_surface
          (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)
     Dibuja superficies paramétricas en 3D.

     3D

     `parametric_surface
     (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)'
     dibuja la superficie paramétrica `[<xfun>,<yfun>,<zfun>]', con el
     parámetro <par1> tomando valores desde <par1min> hasta <par1max> y
     el parámetro <par2> tomando valores desde <par2min> hasta
     <par2max>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `line_width', `key',
     `enhanced3d' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(title          = "Sea shell",
                       xu_grid        = 100,
                       yv_grid        = 25,
                       rot_vertical   = 100,
                       rot_horizontal = 20,
                       surface_hide   = true,
                       parametric_surface(0.5*u*cos(u)*(cos(v)+1),
                                     0.5*u*sin(u)*(cos(v)+1),
                                     u*sin(v) - ((u+3)/8*%pi)^2 - 20,
                                     u, 0, 13*%pi, v, -%pi, %pi) )$

 -- Función: draw (<gr2d>, ..., <gr3d>, ..., <options>, ...)
     Representa gráficamente una serie de escenas; sus argumentos son
     objetos `gr2d' y/o `gr3d', junto con algunas opciones. Por defecto,
     las escenas se representan en una columna.

     La función `draw' acepta las siguientes opciones globales:
     `terminal', `columns', `pic_width', `pic_height', `eps_width',
     `eps_height', `file_name' y `delay'.

     Las funciones `draw2d' y `draw3d' son atajos a utilizar cuando se
     quiere representar una única escena en dos o tres dimensiones,
     respectivamente.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

     Las dos sentencias gráficas siguientes son equivalentes:
          (%i1) load(draw)$
          (%i2) draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)));
          (%o2)                          [gr3d(explicit)]
          (%i3) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1));
          (%o3)                          [gr3d(explicit)]

     Un fichero gif animado:
          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     Véanse también `gr2d', `gr3d', `draw2d' y `draw3d'.

 -- Función: draw2d (<option>, <graphic_object>, ...)
     Esta función es un atajo para `draw(gr2d(<options>, ...,
     <graphic_object>, ...))'.

     Puede utilizarse para representar una única escena en 2d.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Véanse también `draw' y `gr2d'.

 -- Función: draw3d (<option>, <graphic_object>, ...)
     Esta función es un atajo para `draw(gr3d(<options>, ...,
     <graphic_object>, ...))'.

     Puede utilizarse para representar una única escena en 3d.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Véanse también `draw' y `gr3d'.

 -- Función: draw_file (<Opción gráfica>, ..., <Opción gráfica>, ...)
     Almacena el gráfico actual en un fichero. Las opciones gráficas que
     acepta son: `terminal', `pic_width', `pic_height', `eps_width',
     `eps_height', `file_name' y `file_bgcolor'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) /* dibujo en pantalla */
                draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)))$
          (%i3) /* mismo dibujo en formato eps */
                draw_file(terminal  = eps,
                          eps_width = 5,
                          eps_height = 5) $

 -- Función: multiplot_mode (<term>)
     Esta función permite a Maxima trabajar en modo de gráficos
     múltiples en una sola ventana del terminal <term>; argumentos
     válidos para esta función son `screen', `wxt', `aquaterm' y `none'.

     Cuando el modo de gráficos múltiples está activo, cada llamada a
     `draw' envía un nuevo gr'afico a la misma ventana, sin borrar los
     anteriores.  Para desactivar el modo de gráficos múltiples
     escríbase `multiplot_mode(none)'.

     Cuando el modo de gráficos múltiples está activo, la opción global
     `terminal' se bloquea; para desbloquearla y cambiar de terminal es
     necesario desactivar previamente el modo de gráficos múltiples.

     Este modo de trabajo no funciona en plataformas Windows.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) set_draw_defaults(
                   xrange = [-1,1],
                   yrange = [-1,1],
                   grid   = true,
                   title  = "Step by step plot" )$
          (%i3) multiplot_mode(screen)$
          (%i4) draw2d(color=blue,  explicit(x^2,x,-1,1))$
          (%i5) draw2d(color=red,   explicit(x^3,x,-1,1))$
          (%i6) draw2d(color=brown, explicit(x^4,x,-1,1))$
          (%i7) multiplot_mode(none)$


File: maxima.info,  Node: Funciones y variables para picture,  Next: Funciones y variables para worldmap,  Prev: Funciones y variables para draw,  Up: draw

48.3 Funciones y variables para picture
=======================================

 -- Función: make_level_picture (<data>)
 -- Función: make_level_picture (<data>,<width>,<height>)
     Devuelve un objeto `picture' consistente en una imagen de niveles.
     `make_level_picture (<data>)' construye el objeto `picture' a
     partir de la matriz <data>.  `make_level_picture
     (<data>,<width>,<height>)' construye el objeto a partir de una
     lista de números, en cuyo caso deben indicarse el ancho <width> y
     la altura <height> en píxeles.

     El objeto  `picture' devuelto contiene los siguientes cuatro
     elemento:

       1. el símbolo `level'

       2. anchura de la imagen

       3. altura de la imagen

       4. un array de enteros con los valores de los píxeles entre 0 y
          255. El argumento <data> debe contener sólo números entre 0 y
          255; los cantidades negativas se transforman en ceros y las
          que son mayores de 255 se igualan a este número.

     Ejemplo:

     Imagen de niveles a partir de una matriz.
          (%i1) load(draw)$
          (%i2) make_level_picture(matrix([3,2,5],[7,-9,3000]));
          (%o2)         picture(level, 3, 2, {Array:  #(3 2 5 7 0 255)})

     Imagen de niveles a partir de una lista numérica.
          (%i1) load(draw)$
          (%i2) make_level_picture([-2,0,54,%pi],2,2);
          (%o2)            picture(level, 2, 2, {Array:  #(0 0 54 3)})

 -- Función: picturep (<x>)
     Devuelve `true' si el argumento es una imagen bien formada, o
     `false' en caso contrario.

 -- Función: picture_equalp (<x>,<y>)
     Devuelve `true' si los dos argumentos son imágenes idénticas, o
     `false' en caso contrario.

 -- Función: make_rgb_picture (<redlevel>,<greenlevel>,<bluelevel>)
     Devuelve un objeto <picture> conteniendo una imagen en color (RGB).
     Los tres argumentos deben ser imágenes de niveles, para el rojo
     (R), verde (G) y azul (B).

     El objeto  <picture> devuelto contiene los siguientes cuatro
     elemento:

       1. el símbolo `rgb'

       2. anchura de la imagen

       3. altura de la imagen

       4. un array de enteros de <3*ancho*alto> con los valores de los
          píxeles entre 0 y 255. Cada valor de pixel se representa en
          el array con tres números consecutivos (rojo, verde, azul).

     Ejemplo:

          (%i1) load(draw)$
          (%i2) red: make_level_picture(matrix([3,2],[7,260]));
          (%o2)           picture(level, 2, 2, {Array:  #(3 2 7 255)})
          (%i3) green: make_level_picture(matrix([54,23],[73,-9]));
          (%o3)           picture(level, 2, 2, {Array:  #(54 23 73 0)})
          (%i4) blue: make_level_picture(matrix([123,82],[45,32.5698]));
          (%o4)          picture(level, 2, 2, {Array:  #(123 82 45 33)})
          (%i5) make_rgb_picture(red,green,blue);
          (%o5) picture(rgb, 2, 2,
                        {Array:  #(3 54 123 2 23 82 7 73 45 255 0 33)})

 -- Función: take_channel (<im>,<color>)
     Si el argumento <color> es `red', `green' o `blue', la función
     `take_channel' devuelve el canal de color correspondiente de la
     imagen <im>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) red: make_level_picture(matrix([3,2],[7,260]));
          (%o2)           picture(level, 2, 2, {Array:  #(3 2 7 255)})
          (%i3) green: make_level_picture(matrix([54,23],[73,-9]));
          (%o3)           picture(level, 2, 2, {Array:  #(54 23 73 0)})
          (%i4) blue: make_level_picture(matrix([123,82],[45,32.5698]));
          (%o4)          picture(level, 2, 2, {Array:  #(123 82 45 33)})
          (%i5) make_rgb_picture(red,green,blue);
          (%o5) picture(rgb, 2, 2,
                        {Array:  #(3 54 123 2 23 82 7 73 45 255 0 33)})
          (%i6) take_channel(%,'green);  /* simple quote!!! */
          (%o6)           picture(level, 2, 2, {Array:  #(54 23 73 0)})

 -- Función: negative_picture (<pic>)
     Devuelve el negativo de la imagen, sea ésta de tipo nivel (<level>)
     o color (<rgb>).

 -- Función: rgb2level (<pic>)
     Transforma una imagen en color <rgb> a otra de niveles <level>
     promediando los niveles.

 -- Función: get_pixel (<pic>,<x>,<y>)
     Devuelve el pixel de la imagen <pic>. Las coordenadas <x> e <y>
     van desde 0 hasta `ancho-1' y `alto-1', respectivamente.

 -- Función: read_xpm (<xpm_file>)
     Lee el fichero gráfico en formato xpm y devuelve un objeto
     `picture'.


File: maxima.info,  Node: Funciones y variables para worldmap,  Prev: Funciones y variables para picture,  Up: draw

48.4 Funciones y variables para worldmap
========================================

 -- Función: region_boundaries (<x1>,<y1>,<x2>,<y2>)
     Detecta los segmentos poligonales almacenados en la variable global
     `boundaries_array' totalmente contenidos en el rectángulo de
     vértices (<x1>,<y1>) -superior izquierdo- y (<x2>,<y2>) -inferior
     derecho-.

     Ejemplo:

     Devuelve los números de los segmentos necesarios para dibujar el
     sur de Italia.
          (%i1) load(worldmap)$
          (%i2) region_boundaries(10.4,41.5,20.7,35.4);
          (%o2)                [1846, 1863, 1864, 1881, 1888, 1894]
          (%i3) draw2d(geomap(%))$

 -- Función: region_boundaries_plus (<x1>,<y1>,<x2>,<y2>)
     Detecta los segmentos poligonales almacenados en la variable global
     `boundaries_array' con al menos un vértice dentro del rectángulo
     definido por los extremos (<x1>,<y1>) -superior izquierdo- y
     (<x2>,<y2>) -inferior derecho-.

     Ejemplo:

          (%i1) load(worldmap)$
          (%i2) region_boundaries(10.4,41.5,20.7,35.4);
          (%o2)                [1846, 1863, 1864, 1881, 1888, 1894]
          (%i3) draw2d(geomap(%))$

 -- Función: numbered_boundaries (<nlist>)
     Dibuja una lista de segmentos poligonales (líneas fronterizas),
     etiquetadas con sus números correspondientes (coordenadas de
     `boundaries_array'). Esta función es de mucha ayuda a la hora de
     definir nuevas entidades geográficas.

     Ejemplo:

     Mapa de Europa con las fronteras y costas etiquetadas con su
     componente numérica de `boundaries_array'.
          (%i1) load(worldmap)$
          (%i2) european_borders:
                     region_boundaries(-31.81,74.92,49.84,32.06)$
          (%i3) numbered_boundaries(european_borders)$

 -- Función: make_polygon (<nlist>)
     Devuelve un objeto `polygon' a partie de una lista de líneas
     fronterizas y de costas. El argumento <nlist> debe ser una lista
     de componentes de `boundaries_array'.

     Ejemplo:

     La variable Bhutan (Bután) está definida con los números
     fronterizos 171, 173 y 1143, de manera que
     `make_polygon([171,173,1143])' concatena los arrays
     `boundaries_array[171]', `boundaries_array[173]' y
     `boundaries_array[1143]' y devuelve un objeto `polygon' apto para
     ser dibujado por `draw'. A fin de evitar mensajes de errores, los
     arrays deben ser compatibles en el sentido de que dos de ellos
     consecutivos deben tener dos coordenadas comunes en los extremos.
     En este ejemplo, las dos primeras componentes de
     `boundaries_array[171]' son iguales a las dos últimas de
     `boundaries_array[173]', y las dos primeras de
     `boundaries_array[173]' coinciden con las dos primeras de
     `boundaries_array[1143]'; en conclusión, los números de segmentos
     poligonales171, 173 y 1143 (en este orden) son compatibles y el
     polígono coloreado se podrá dibujar.
          (%i1) load(worldmap)$
          (%i2) Bhutan;
          (%o2)                        [[171, 173, 1143]]
          (%i3) boundaries_array[171];
          (%o3) {Array:
                 #(88.750549 27.14727 88.806351 27.25305 88.901367 27.282221
                   88.917877 27.321039)}
          (%i4) boundaries_array[173];
          (%o4) {Array:
                 #(91.659554 27.76511 91.6008 27.66666 91.598022 27.62499
                   91.631348 27.536381 91.765533 27.45694 91.775253 27.4161
                   92.007751 27.471939 92.11441 27.28583 92.015259 27.168051
                   92.015533 27.08083 92.083313 27.02277 92.112183 26.920271
                   92.069977 26.86194 91.997192 26.85194 91.915253 26.893881
                   91.916924 26.85416 91.8358 26.863331 91.712479 26.799999
                   91.542191 26.80444 91.492188 26.87472 91.418854 26.873329
                   91.371353 26.800831 91.307457 26.778049 90.682457 26.77417
                   90.392197 26.903601 90.344131 26.894159 90.143044 26.75333
                   89.98996 26.73583 89.841919 26.70138 89.618301 26.72694
                   89.636093 26.771111 89.360786 26.859989 89.22081 26.81472
                   89.110237 26.829161 88.921631 26.98777 88.873016 26.95499
                   88.867737 27.080549 88.843307 27.108601 88.750549
                   27.14727)}
          (%i5) boundaries_array[1143];
          (%o5) {Array:
                 #(91.659554 27.76511 91.666924 27.88888 91.65831 27.94805
                   91.338028 28.05249 91.314972 28.096661 91.108856 27.971109
                   91.015808 27.97777 90.896927 28.05055 90.382462 28.07972
                   90.396088 28.23555 90.366074 28.257771 89.996353 28.32333
                   89.83165 28.24888 89.58609 28.139999 89.35997 27.87166
                   89.225517 27.795 89.125793 27.56749 88.971077 27.47361
                   88.917877 27.321039)}
          (%i6) Bhutan_polygon: make_polygon([171,173,1143])$
          (%i7) draw2d(Bhutan_polygon)$

 -- Función: make_poly_country (<country_name>)
     Construye los polígonos necesarios para dibujar un país coloreado.
     En caso de contener islas, un país tendrá asociados varios
     polígonos.

     Ejemplo:

          (%i1) load(worldmap)$
          (%i2) make_poly_country(India)$
          (%i3) apply(draw2d, %)$

 -- Función: make_poly_continent (<continent_name>)
 -- Función: make_poly_continent (<country_list>)
     Construye los polígonos necesarios para dibujar un continente o
     lista de países coloreados.

     Ejemplo:

          (%i1) load(worldmap)$
          (%i2) /* A continent */
                make_poly_continent(Africa)$
          (%i3) apply(draw2d, %)$
          (%i4) /* A list of countries */
                make_poly_continent([Germany,Denmark,Poland])$
          (%i5) apply(draw2d, %)$


File: maxima.info,  Node: dynamics,  Next: ezunits,  Prev: draw,  Up: Top

49 dynamics
***********

* Menu:

* Introducción a dynamics::
* Funciones y variables para dynamics::


File: maxima.info,  Node: Introducción a dynamics,  Next: Funciones y variables para dynamics,  Prev: dynamics,  Up: dynamics

49.1 Introducción a dynamics
============================

El paquete adicional `dynamics' incluye varias funciones para crear
diversas representaciones gráficas de sistemas dinámicos y fractales, y
además una implementación del método numérico de Runge-Kutta de cuarto
orden, para resolver sistemas de ecuaciones diferenciales.

   Para usar las funciones en este paquete será necesario primero que
todo cargarlo con `load("dynamics")', y las funciones que crean
gráficas necesitan que Xmaxima esté instalado.


File: maxima.info,  Node: Funciones y variables para dynamics,  Prev: Introducción a dynamics,  Up: dynamics

49.2 Funciones y variables para dynamics
========================================

 -- Función: chaosgame (`[['<x1>, <y1>`]'...`['<xm>, <ym>`]]', `['<x0>,
          <y0>`]', <b>, <n>, ...opciones...);
     Usa el método llamado juego del caos, para producir fractales: se
     dibuja un punto inicial (<x0>, <y0>) y luego se elije
     aleatoriamente uno de los <m> puntos `['<x1>, <y1>`]'...`['<xm>,
     <ym>`]'. Después se dibuja un nuevo punto que estará en el
     segmento entre el último punto dibujado y el punto que se acabó de
     elegir aleatoriamente, a una distancia del punto elegido que será
     <b> veces la longitud del segmento. El proceso se repite <n> veces.


 -- Función: evolution (<F>, <y0>, <n>,...opciones...);
     Dibuja <n+1> puntos en una gráfica bidimensional (serie de
     tiempo), en que las coordenadas horizontales de los puntos son los
     números enteros 0, 1, 2, ..., <n>, y las coordenadas verticales
     son los valores <y(n)> correspondientes, obtenidos a partir de la
     relación de recurrencia
                  y(n+1) = F(y(n))

     Con valor inicial <y(0)> igual a <y0>. <F> deberá ser una
     expresión que dependa únicamente de la variable <y> (y no de <n>),
     <y0> deberá ser un número real y <n> un número entero positivo.


 -- Función: evolution2d (`['<F>, <G>`]', `['<x0>, <y0>`]', <n>,
          ...opciones...);
     Muestra, en una gráfica bidimensional, los primeros <n+1> puntos de
     la sucesión definida a partir del sistema dinámico discreto con
     relaciones de recurrencia:
                  x(n+1) = F(x(n), y(n))    y(n+1) = G(x(n), y(n))

     Con valores iniciales <x0> y <y0>. <F> y <G> deben ser dos
     expresiones que dependan únicamente de <x> y <y>.


 -- Función: ifs (`['<r1>,...,<rm>`]',`['<A1>,...,<Am>`]',
          `[['<x1>,<y1>`]'...`['<xm>, <ym>`]]', `['<x0>,<y0>`]', <n>,
          ...opciones...);
     Usa el método del Sistema de Funciones Iteradas (IFS, en inglés
     Iterated Function System). Ese método es semejante al método
     descrito en la función `chaosgame', pero en vez de aproximar el
     último punto al punto elegido aleatoriamente, las dos coordenadas
     del último punto se multiplican por una matriz 2 por 2 <Ai>
     correspondiente al punto que fue elegido aleatoriamente.

     La selección aleatoria de uno de los <m> puntos atractivos puede
     ser realizada con una función de probabilidad no uniforme, definida
     con los pesos <r1>,...,<rm>. Esos pesos deben ser dados en forma
     acumulada; por ejemplo, si se quieren 3 puntos con probabilidades
     0.2, 0.5 y 0.3, los pesos <r1>, <r2> y <r3> podrían ser 2, 7 y 10,
     o cualquier otro grupo de números que tengan la misma proporción.


 -- Función: julia (<x>, <y>, ...<opciones>...)
     Crea un fichero gráfico con la representación del conjunto de Julia
     del número complejo (<x> + i <y>). Los parámetros <x> y <y> deben
     ser reales. El fichero se crea en el directório actual o en el
     directório del usuario, usando el formato gráfico XPM. El programa
     puede demorar varios segundos a ser ejecutado y cuando termina
     imprime un mensaje con el nombre del fichero creado.

     Se asignan diferentes colores a los puntos que no pertenecen al
     conjunto de Julia, de acuerdo con el número de iteraciones que
     demore la secuencia, comenzando en ese punto, a salir fuera del
     círculo de convergencia con radio 2. El número máximo de
     iteraciones se define con la opción <levels>; después de
     ejecutadas ese número de iteraciones, si la secuencia aun está
     dentro del círculo de convergencia, el punto será coloreado con el
     color definido por la opción <color>.

     Todos los colores usados para los puntos que no pertenecen al
     conjunto de Julia tendrán los mismos valores de saturación
     (<saturation>) y valor (<value>), pero con diferentes ángulos de
     tonalidad, distribuidos uniformemente en el intervalo entre <hue>
     y (<hue> + <huerange>).

     Se puede dar a la función una secuencia de opciones. La lista de
     posibles opciones aparece en una sección más al frente.


 -- Función: mandelbrot (<options>)
     Crea un fichero gráfico con la representación del conjunto de
     Mandelbrot. El fichero se crea en el directório actual o en el
     directório del usuario, usando el formato gráfico XPM. El programa
     puede demorar varios segundos a ser ejecutado y cuando termina
     imprime un mensaje con el nombre del fichero creado.

     Se asignan diferentes colores a los puntos que no pertenecen al
     conjunto de Mandelbrot, de acuerdo con el número de iteraciones
     que demore la secuencia generada por ese punto a salir fuera del
     círculo de convergencia con radio 2. El número máximo de
     iteraciones se define con la opción <levels>; después de
     ejecutadas ese número de iteraciones, si la secuencia aun está
     dentro del círculo de convergencia, el punto será coloreado con el
     color definido por la opción <color>.

     Todos los colores usados para los puntos que no pertenecen al
     conjunto de Mandelbrot tendrán los mismos valores de saturación
     (<saturation>) y valor (<value>), pero con diferentes ángulos de
     tonalidad, distribuidos uniformemente en el intervalo entre <hue>
     y (<hue> + <huerange>).

     Se puede dar a la función una secuencia de opciones. La lista de
     posibles opciones aparece en una sección más al frente.


 -- Función: orbits (<F>, <y0>, <n1>, <n2>, [<x>, <x0>, <xf>, <xstep>],
          ...opciones...);
     Dibuja el diagrama de órbitas de una familia de sistemas dinámicos
     discretos unidimensionales, con un parámetro <x>; ese tipo de
     diagrama se usa para mostrar las bifurcaciones de un sistema
     discreto unidimensional.

     La función <F(y)> define una secuencia que comienza con un valor
     inicial <y0>, igual que en el caso de la función `evolution', pero
     en este caso la función también dependerá del parámetro <x>, el
     cual tomará valores comprendidos en el intervalo de <x0> a <xf>,
     con incrementos <xstep>. Cada valor usado para el parámetro <x> se
     muestra en el eje horizontal. En el eje vertical se mostrarán <n2>
     valores de la sucesión <y(n1+1)>,..., <y(n1+n2+1)>, obtenidos
     después de dejarla evolucionar durante <n1> iteraciones iniciales.


 -- Función: rk (EDO, var, inicial, dominio)
 -- Función: rk ([EDO1,...,EDOm], [v1,...,vm], [inic1,...,inicm],
          dominio)
     La primera forma se usa para resolver numéricamente una ecuación
     diferencial ordinaria de primer orden (EDO), y la segunda forma
     resuelve numéricamente un sistema de <m> de esas ecuaciones,
     usando el método de Runge-Kutta de cuarto orden. <var> representa
     la variable dependiente.  EDO debe ser una expresión que dependa
     únicamente de las variables independiente y dependente, y define
     la derivada de la variable dependiente en función de la variable
     independiente.

     La variable independiente se representa con <dominio>, que debe ser
     una lista con cuatro elementos, como por ejemplo:
          [t, 0, 10, 0.1]
     el primer elemento de la lista identifica la variable
     independiente, el segundo y tercer elementos son los valores
     inicial y final para esa variable, y el último elemento da el
     valor de los incrementos que deberán ser usados dentro de ese
     intervalo.

     Si se van a resolver <m> ecuaciones, deberá haber <m> variables
     dependientes <v1>, <v2>, ..., <vm>. Los valores iniciales para
     esas variables serán <inic1>, <inic2>, ..., <inicm>. Continuará
     existiendo apenas una variable independiente definida por la lista
     <domain>, como en el caso anterior. <EDO1>, ..., <EDOm> son las
     expresiones que definen las derivadas de cada una de las variables
     dependientes en función de la variable independiente. Las únicas
     variables que pueden aparecer en cada una de esas expresiones son
     la variable independiente y cualquiera de las variables
     dependientes. Es importante que las derivadas <EDO1>, ..., <EDOm>
     sean colocadas en la lista en el mismo orden en que fueron
     agrupadas las variables dependientes; por ejemplo, el tercer
     elemento de la lista será interpretado como la derivada de la
     tercera variable dependiente.

     El programa intenta integrar las ecuaciones desde el valor inicial
     de la variable independiente, hasta el valor final, usando
     incrementos fijos. Si en algún paso una de las variables
     dependientes toma un valor absoluto muy grande, la integración
     será suspendida en ese punto.  El resultado será una lista con un
     número de elementos igual al número de iteraciones realizadas.
     Cada elemento en la lista de resultados es también una lista con
     <m>+1 elementos: el valor de la variable independiente, seguido de
     los valores de las variables dependientes correspondientes a ese
     punto.


 -- Función: staircase (<F>, <y0>, <n>, ...opciones...);
     Dibuja un diagrama de escalera (o diagrama de red) para la sucesión
     definida por la ecuación de recurrencia
                  y(n+1) = F(y(n))

     La interpretación y valores permitidos de los parámetros de entrada
     es la misma que para la función `evolution'. Un diagrama de
     escalera consiste en una gráfica de la función <F(y)>, junto con
     la recta <G(y)> `=' <y>. Se comienza por dibujar un segmento
     vertical desde el punto (<y0>, <y0>) en la recta, hasta el punto
     de intersección con la función <F>. En seguida, desde ese punto se
     dibuja un segmento horizontal hasta el punto de intersección con
     la recta, (<y1>, <y1>); el procedimiento se repite <n> veces hasta
     alcanzar el punto (<yn>, <yn>).


   Opciones

   Cada opción es una lista con dos o más elementos. El primer elemento
en la lista es el nombre de la opción y el resto consiste en los
argumentos para esa opción.

   Las opciones aceptadas por las funciones evolution, evolution2,
staircase, orbits, ifs y chaosgame son las siguientes:

   * "domain" especifica los valores mínimo y máximo de la variable
     independiente para la gráfica de la función <F> representada por
     `staircase'.

   * "pointsize" define el radio de cada punto dibujado, en unidades de
     puntos.  El valor por omisión es 1.

   * "xaxislabel" es la etiqueta que se escribirá en el eje horizontal.

   * "xcenter" es la coordenada x del punto que deberá aparecer en el
     centro de la gráfica. Esta opción no es usada por la función
     `orbits'.

   * "xradius" es mitad de la longitud del intervalo de valores de x que
     será representado. Esta opción no es usada por la función `orbits'.

   * "yaxislabel" es la etiqueta que se escribirá en el eje vertical.

   * "ycenter" es la coordenada y del punto que deberá aparecer en el
     centro de la gráfica.

   * "yradius" es mitad de la longitud del intervalo de valores de y que
     será representado.


   Las opciones aceptadas por los programas julia y mandelbrot son las
siguientes:

   * "size" acepta uno o dos argumentos. Si se da solo un argumento, el
     ancho y la altura del fichero gráfico creado serán iguales a ese
     valor en pixels. Si se dan dos argumentos, esos dos valores serán
     usados para el ancho y la altura. El valor por omisión es 400
     pixels tanto para el ancho como para la altura. Si los dos valores
     no son iguales, el conjunto aparecerá distorcionado.

   * "levels" define el número máximo de iteraciones, que es también el
     número de colores usado para los puntos que no pertenecem al
     conjunto. El valor por omisión es 12; valores mayores implican
     tiempos de procesamiento más elevados.

   * "huerange" define el intervalo de ángulos usados para la tonalidad
     de los puntos que no pertenecen al conjunto. El valor por omisión
     es 360, que hace que los colores usados abarcarán todo el rango de
     tonalidades. Valores mayores que 360 implican repetición de algunos
     valores de la tonalidad, y pueden usarse valores negativos para
     que el ángulo de tonalidad sea menor a medida que el número de
     iteraciones aumente.

   * "hue" define la tonalidad, en grados, del primer color usado para
     representar los puntos que no pertenecen al conjunto.  Su valor por
     omisión es 300 grados, que corresponde al color magenta; el color
     correspondiente para otros valores estandar es rojo 0, naranja 45,
     amarillo 60, verde 120, cian 180 y azul 240. Consulte también la
     opción <huerange>.

   * "saturation" define el nivel de saturación que será usado para los
     colores de los puntos que no pertenecen al conjunto. Debe ser un
     valor entre 0 y 1. El valor por omisión es 0.46.

   * "value" define el valor de los colores usados para puntos que no
     pertenezcan al conjunto. Debe estar comprendido entre 0 y 1; cuanto
     mayor sea, mas brilhantes serán los colores. Su valor por omisión
     es 0.96.

   * "color" debe ir seguido de tres parámetros que definen la
     tonalidad, saturación y valor del color que será usado para los
     puntos del conjunto. El valor por omisión es 0 para los tres
     parámetros, que corresponde al negro. Consulte las explicación
     sobre el rango de valores aceptados en la explicación de las
     opciones <hue>, <saturation> y <value>.

   * "center" deberá tener dos parámetros reales que dan las
     coordenadas, en el plano complejo, del punto en el centro de la
     región representada. El valor por omisión es 0 para las dos
     coordenadas (el origen).

   * "radius" es el radio de el mayor círculo que cabe dentro de la
     región quadrada que será representada. El valor por omisión es 2.

   * "filename" da el nombre del fichero donde se guardará la gráfica
     producida. A ese nombre se le acrecentará la terminación .xpm. Si
     el fichero ya existe, será substituido por el fichero producido
     por la función. El valor por omisión es julia para el conjunto de
     Julia y mandelbrot para el conjunto de Mandelbrot.


   Ejemplos

   Representación gráfica y diagrama de escalera de la secuencia: 2,
cos(2), cos(cos(2)),...

     (%i1) load("dynamics")$
     (%i2) evolution(cos(y), 2, 11, [yaxislabel, "y"], [xaxislabel,"n"]);
     (%i3) staircase(cos(y), 1, 11, [domain, 0, 1.2]);

   Si su procesador es lento, tendrá que reducir el número de
iteraciones usado en los ejemplos siguientes. Y el valor de <pointsize>
que da mejores resultados depende del monitor y de la resolución que
use. Tendrá que experimentar con diferentes valores.

   Diagrama de órbitas para el mapa cuadrático
             y(n+1) = x + y(n)^2

     (%i4) orbits(y^2+x, 0, 50, 200, [x, -2, 0.25, 0.01], [pointsize, 0.9]);

   Para ampliar la región alrededor de la bifurcación en la parte de
abajo, cerca de x `=' -1.25, use el comando:
     (%i5) orbits(x+y^2, 0, 100, 400, [x,-1,-1.53,-0.001], [pointsize,0.9],
                  [ycenter,-1.2], [yradius,0.4]);

   Evolución de un sistema en dos dimensiones, que conduce a un fractal:

     (%i6) f: 0.6*x*(1+2*x)+0.8*y*(x-1)-y^2-0.9$
     (%i7) g: 0.1*x*(1-6*x+4*y)+0.1*y*(1+9*y)-0.4$
     (%i8) evolution2d([f,g],[-0.5,0],50000,[pointsize,0.7]);

   Y una ampliación de una pequeña región en el fractal:

     (%i9) evolution2d([f,g],[-0.5,0],300000,[pointsize,0.7], [xcenter,-0.7],
                       [ycenter,-0.3],[xradius,0.1],[yradius,0.1]);

   Una gráfica del triangulo de Sierpinsky, obtenida con el juego del
caos:

     (%i9) chaosgame([[0, 0], [1, 0], [0.5, sqrt(3)/2]], [0.1, 0.1], 1/2,
                      30000, [pointsize,0.7]);

   El helecho de Barnsley, obtenido con el Sistema de Funciones
Iteradas:

     (%i10) a1: matrix([0.85,0.04],[-0.04,0.85])$
     (%i11) a2: matrix([0.2,-0.26],[0.23,0.22])$
     (%i12) a3: matrix([-0.15,0.28],[0.26,0.24])$
     (%i13) a4: matrix([0,0],[0,0.16])$
     (%i14) p1: [0,1.6]$
     (%i15) p2: [0,1.6]$
     (%i16) p3: [0,0.44]$
     (%i17) p4: [0,0]$
     (%i18) w: [85,92,99,100]$
     (%i19) ifs(w,[a1,a2,a3,a4],[p1,p2,p3,p4],[5,0],50000,[pointsize,0.9]);

   Para crear un fichero llamado _dinamica9.xpm_ con la representación
gráfica del conjunto de Mandelbrot, con 12 colores, use el comando:

     mandelbrot([filename,"dinamica9"])$

   y el conjunto de Julia del número (-0.55 + i 0.6) puede ser obtenido
con:
     julia(-0.55, 0.6, [levels, 36], [center, 0, 0.6], [radius, 0.3],
           [hue, 240], [huerange, -180], [filename, "dinamica10"])$

   la gráfica se guardará en el fichero _dinamica10.xpm_ y mostrará la
región desde -0.3 hasta 0.3 en la dirección x, y desde 0.3 hasta 0.9 en
la dirección y. Serán usados 36 colores, comenzando con azul e
terminando con amarillo.

   Para resolver numéricamente la ecuación diferencial

               dx/dt = t - x^2

   Con valor inicial x(t=0) = 1, en el intervalo de t desde 0 hasta 8, y
con incrementos de 0.1, se usa:

     (%i20) resultados: rk(t-x^2,x,1,[t,0,8,0.1])$

   los resultados quedarán guardados en la lista resultados.

   Para resolver numéricamente el sistema:

             dx/dt = 4-x^2-4*y^2     dy/dt = y^2-x^2+1

   para t entre 0 y 4, con valores iniciales -1.25 y 0.75 para (x, y)
en t=0:

     (%i21) sol: rk([4-x^2-4*y^2,y^2-x^2+1],[x,y],[-1.25,0.75],[t,0,4,0.02])$


File: maxima.info,  Node: ezunits,  Next: f90,  Prev: dynamics,  Up: Top

50 ezunits
**********

* Menu:

* Introducción a ezunits::
* Introducción a physical_constants::
* Funciones y variables para ezunits::


File: maxima.info,  Node: Introducción a ezunits,  Next: Introducción a physical_constants,  Prev: ezunits,  Up: ezunits

50.1 Introducción a ezunits
===========================

`ezunits' es un paquete para trabajar con magnitudes dimensionales,
incluyendo algunas funciones para realizar análisis dimensional.
`ezunits' puede hacer operaciones aritméticas con magnitudes
dimensionales y efectuar conversiones entre unidades.  Las unidades que
se definen son las del Sistema Internacional (SI) y otras comunes en
los Estados Unidos, siendo posible declarar otras nuevas.

   Véase también `physical_constants', una colección de constantes
físicas.

   Es necesario ejecutar primero `load(ezunits)' para utilizar este
paquete.  Con `demo(ezunits)' se podrán ver algunos ejemplos de
utilización.  La función `known_units' devuelve una lista con todas las
unidades que están definidas y `display_known_unit_conversions' muestra
las conversiones conocidas por el sistema en un formato de lectura
sencilla.

   Una expresión tal como a ` b representa una magnitud dimensional,
siendo `a' una magnitud adimensional y `b' las unidades.  Se puede
utilizar un símbolo como unidad, sin necesidad de declararlo como tal
ni de que deba cumplir propiedades especiales.  Tanto la magnitud como
la unidad de una expresión de la forma a ` b pueden extraerse invocando
las funciones `qty' y `units', respectivamente.

   Una expresión tal como `a ` b `` c' convierte las unidades `b' en
`c'. El paquete `ezunits' contiene funciones conversoras para unidades
fundamentales del SI, unidades derivadas, así como algunas otras
unidades ajenas al SI.  Las conversiones entre unidades que no estén
programadas en `ezunits' podrán declararse a posteriori.  Las
conversiones conocidas por `ezunits' están especificadas en la variable
global `known_unit_conversions', incluyendo tanto las ya declaradas por
defecto como aquéllas introducidas por el usuario.  Las conversiones
para los productos, cocientes y potencias de unidades se derivan del
conjunto de conversiones ya conocidas.

   En general, Maxima prefiere números exactos (enteros o racionales) a
inexactos (decimales en coma flotante), por lo que `ezunits' respetará
los exactos cuando aparezcan en expresiones de magnitudes
dimensionales. Todas las conversiones del paquete se han definido en
términos de números exactos.

   No hay un sistema de representación de unidades que se considere
preferible, razón por la cual las unidades no se convierten a otras a
menos que se indique de forma explícita. `ezunits' reconoce los prefijos
m-, k-, M y G- para mili-, kilo-, mega- y giga-, respectivamente, tal
como se utilizan en el SI; estos prefijos sólo se utilizan cuando así
se indica de forma explícita.

   Las operaciones aritméticas con magnitudes dimensionales se realizan
de la forma convencional.

   * `(x ` a) * (y ` b)' es igual a (x * y) ` (a * b).

   * `(x ` a) + (y ` a)' es igual a (x + y) ` a.

   * `(x ` a)^y' es igual a x^y ` a^y si `y' es adimensional.

   `ezunits' no necesita que las unidades en una suma tengan las mismas
dimensiones; estos términos serán sumados sin emitirse mensaje de error.

   `ezunits' incluye funciones para el análisis dimensional elemental,
como las dimensiones fundamentales, las unidades fundamentales de una
magnitud dimensional o el cálculo de magnitudes adimensionales y
unidades naturales. Las funciones de análisis dimensional son
adaptaciones de funciones semejantes escritas por Barton Willis en otro
paquete.

   Con el fin de poder llevar a cabo análisis dimensionales, se
mantiene una lista de dimensiones fundamentales y otra lista asociada
de unidades fundamentales; por defecto, las dimensiones fundamentales
son longitud, masa, tiempo, carga, temperatura y cantidad de materia,
siendo las unidades fundamentales las propias del Sistema Internacional.
En cualquier caso, es posible declarar otras dimensiones y unidades
fundamentales.


File: maxima.info,  Node: Introducción a physical_constants,  Next: Funciones y variables para ezunits,  Prev: Introducción a ezunits,  Up: ezunits

50.2 Introducción a physical_constants
======================================

`physical_constants' contiene constantes físicas recomendadas por el
CODATA 2006 (`http://physics.nist.gov/constants').  La instrucción
`load(physical_constants)' carga este paquete en memoria junto con el
propio `ezunits', si éste no estaba previamente cargado.

   Una constante física se representa por un símbolo con la propiedad
de ser un valor constante. El valor constante es una magnitud
dimensional en la sintaxis de `ezunits'. La función `constvalue' extrae
el valor constante, el cual no es el valor ordinario del símbolo, por
lo que las constantes físicas se mantienen inalteradas en las
expresiones evaluadas hasta que sus valores sea extraído con la función
`constvalue'.

   `physical_constants' incluye cierta información adicional, como la
descripción de cada constante, una estimación del error de su valor
numérico y una propiedad para ser representada en TeX.  Para
identificar constantes físicas, cada símbolo tiene la propiedad
`physical_constant', de forma que `propvars(physical_constant)' muestra
la lista de todas las constantes físicas.

   `physical_constants' contiene las siguientes constantes:

`%c'
     velocidad de la luz en el vacío

`%mu_0'
     constante magnética

`%e_0'
     constante eléctrica

`%Z_0'
     impedancia característica del vacío

`%G'
     constante gravitatoria de Newton

`%h'
     constante de Planck

`%h_bar'
     constante de Planck

`%m_P'
     masa de Planck

`%T_P'
     temperature de Planck

`%l_P'
     longitud de Planck

`%t_P'
     tiempo de Planck

`%%e'
     carga elemental

`%Phi_0'
     flujo magnético cuántico

`%G_0'
     conductancia cuántica

`%K_J'
     constante de Josephson

`%R_K'
     constante de von Klitzing

`%mu_B'
     magnetón de Bohr

`%mu_N'
     magnetón nuclear

`%alpha'
     constante de estructura fina

`%R_inf'
     constante de Rydberg

`%a_0'
     radio de Bohr

`%E_h'
     energía de Hartree

`%ratio_h_me'
     cuanto de circulación

`%m_e'
     masa del electrón

`%N_A'
     número de Avogadro

`%m_u'
     constante de masa atómica atomic mass constant

`%F'
     constante de Faraday

`%R'
     constante molar de los gases

`%%k'
     constante de Boltzmann

`%V_m'
     volumen molar del gas ideal

`%n_0'
     constante de Loschmidt

`%ratio_S0_R'
     constante de Sackur-Tetrode (constante de entropía absoluta)

`%sigma'
     constante de Stefan-Boltzmann

`%c_1'
     primera constante de radiación

`%c_1L'
     primera constante de radiación para radiancia espectral

`%c_2'
     segunda constante de radiación

`%b'
     Constante de la ley del desplazamiento de Wien

`%b_prime'
     Constante de la ley del desplazamiento de Wien

   Ejemplos:

   Lista de todos los símbolos que tienen la propiedad
`physical_constant'.

     (%i1) load (physical_constants)$
     (%i2) propvars (physical_constant);
     (%o2) [%c, %mu_0, %e_0, %Z_0, %G, %h, %h_bar, %m_P, %T_P, %l_P,
     %t_P, %%e, %Phi_0, %G_0, %K_J, %R_K, %mu_B, %mu_N, %alpha,
     %R_inf, %a_0, %E_h, %ratio_h_me, %m_e, %N_A, %m_u, %F, %R, %%k,
     %V_m, %n_0, %ratio_S0_R, %sigma, %c_1, %c_1L, %c_2, %b, %b_prime]

   Propiedades de la constante física `%c'.

     (%i1) load (physical_constants)$
     (%i2) constantp (%c);
     (%o2)                         true
     (%i3) get (%c, description);
     (%o3)               speed of light in vacuum
     (%i4) constvalue (%c);
                                           m
     (%o4)                     299792458 ` -
                                           s
     (%i5) get (%c, RSU);
     (%o5)                           0
     (%i6) tex (%c);
     $$c$$
     (%o6)                         false

   Energía equivalente de una libra-masa. El símbolo `%c' se mantiene
hasta que su valor es extraído con la llamada a la función `constvalue'.

     (%i1) load (physical_constants)$
     (%i2) m * %c^2;
                                     2
     (%o2)                         %c  m
     (%i3) %, m = 1 ` lbm;
                                   2
     (%o3)                       %c  ` lbm
     (%i4) constvalue (%);
                                                 2
                                            lbm m
     (%o4)              89875517873681764 ` ------
                                               2
                                              s
     (%i5) E : % `` J;
     Computing conversions to base units; may take a moment.
                          366838848464007200
     (%o5)                ------------------ ` J
                                  9
     (%i6) E `` GJ;
                           458548560580009
     (%o6)                 --------------- ` GJ
                              11250000
     (%i7) float (%);
     (%o7)              4.0759872051556356e+7 ` GJ



Local Variables:
coding: iso-8859-1
End:
