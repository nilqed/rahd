This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Ver. 5.20 Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Funciones y variables para gráficos,  Prev: Gráficos,  Up: Gráficos

8.1 Funciones y variables para gráficos
=======================================

 -- Función: contour_plot (<expr>, <x_range>, <y_range>, <options>, ...)
     Dibuja las curvas de nivel <expr> en el rectángulo <x_range> por
     <y_range>.  Cualesquiera otros argumentos adicionales se tratan
     como en `plot3d'.

     `contour_plot' sólo trabaja cuando se utilizan `gnuplot' o
     `gnuplot_pipes'.

     Véase también `implicit_plot'.

     Ejemplos:

          (%i1) contour_plot (x^2 + y^2, [x, -4, 4], [y, -4, 4]);
          (%o1)
          (%i2) contour_plot (sin(y) * cos(x)^2, [x, -4, 4], [y, -4, 4]);
          (%o2)
          (%i3) F(x, y) := x^3 + y^2;
                                             3    2
          (%o3)                  F(x, y) := x  + y
          (%i4) contour_plot (F, [u, -4, 4], [v, -4, 4]);
          (%o4)
          (%i5) contour_plot (F, [u, -4, 4], [v, -4, 4],
                   [gnuplot_preamble, "set size ratio -1"]);
          (%o5)
          (%i6) set_plot_option ([gnuplot_preamble,
                                  "set cntrparam levels 12"])$
          (%i7) contour_plot (F, [u, -4, 4], [v, -4, 4]);


 -- Variable opcional: in_netmath
     Valor por defecto: `false'

     Si `in_netmath' vale `true', `plot3d' imprime salida de OpenMath
     en la consola si `plot_format' vale `openmath', en caso contrario,
     `in_netmath' (incluso si vale `true') deja de tener efecto alguno.

     La variable `in_netmath' no afecta a `plot2d'.


 -- Función: plot2d (<expr>, <x_range>, ..., <options>, ...)
 -- Función: plot2d ([<expr_1>, ..., <expr_n>], ..., <options>, ...)
 -- Función: plot2d ([<expr_1>, ..., <expr_n>], <x_range>,...,
          <options>, ...)
     Donde <expr>, <expr_1>, ..., <expr_n> pueden ser expresiones,
     funciones u operadores de Maxima o Lisp, o una lista de cualquiera
     de las siguientes formas: `[discrete, [<x1>, ..., <xn>], [<y1>,
     ..., <yn>]]', `[discrete, [[<x1>, <y1>], ..., [<xn>, ..., <yn>]]'
     o `[parametric, <x_expr>, <y_expr>, <t_range>]'.

     Muestra un gráfico de una o más expresiones como función de una
     variable.

     La función `plot2d' representa gráficamente la expresión <expr> o
     expresiones `[<name_1>, ..., <name_n>]'. Las expresiones que no
     sean de tipo paramétrico o discreto deben depender todas ellas de
     una única variable <var>, siendo obligatorio utilizar <x_range>
     para nombrar la variable y darle sus valores mínimo y máximo
     usando la siguiente sintaxis: `[<variable>, <min>, <max>]'.  El
     gráfico mostrará el eje horizontal acotado por los valores <min> y
     <max>.

     La expresión a ser representada puede ser dada en la forma discreta
     o paramétrica, esto es, como una lista que comienza con las
     palabras `discrete' o `parametric'. La clave <discrete> debe
     seguirse de dos listas de valores, ambas de igual longitud,
     conteniendo las coordenadas horizontales y verticales del conjunto
     de puntos; alternativamente, las coordenadas de cada punto pueden
     darse como listas de dos valores, todas ellas formando a su vez
     una lista. La clave <parametric> debe seguirse de dos expresiones,
     <x_expr> y <y_expr>, junto con un rango de la forma `[<var>,
     <min>, <max>]'; ambas expresiones deben depender únicamente de la
     variable cuyo nombre aparece en el rango.  El gráfico mostrará los
     pares `[<x_expr>, <y_expr>]' según <var> varía de <min> a <max>.

     El rango del eje vertical no es necesario especificarlo. Es una más
     de las opciones de la función, siendo su sintaxis `[y, <min>,
     <max>]', mostrando entonces la gráfica el rango completo, incluso
     si la función no alcanza estos valores. En caso de no
     especificarse el rango vertical en `set_plot_option', se
     establecerá de forma automática como aquel rango en el que la
     función toma sus valores.

     Cualesquiera otras opciones deben ser listas, comenzando con el
     nombre de la opción.

     La opción <xlabel> puede utilizarse para darle una etiqueta al eje
     horizontal; si no se usa esta opción, el eje horizontal será
     etiquetado con el nombre de la variable especificada en <x_range>.

     Del mismo modo se puede asignar una etiqueta al eje vertical con
     la opción <ylabel>. Si sólo hay una expresión a ser representada y
     no se ha hecho uso de la opción <ylabel>, el eje vertical será
     etiquetado con la expresión a ser representada, a menos que sea
     muy larga, o con el texto "discrete data", en caso de gráficos de
     puntos. Si la expresión es de tipo paramétrico, las dos
     expresiones que dan las coordenadas horizontal y vertical serán
     utilizadas para etiquetar ambos ejes.

     Las opciones `[logx]' y `[logy]' no necesitan parámetros,
     permitiendo que los ejes horizontal y vertical se dibujen en la
     escala logarítmica.

     Si hay varias expresiones para ser dibujadas, se mostrará una
     leyenda que identifique a cada una de ellas. Las etiquetas a
     utilizar pueden especificarse con la opción <legend>. Si no se
     utiliza esta opción, Maxima creará etiquetas a partir de las
     expresiones.

     Por defecto, las funciones se dibujarán como un conjunto de
     segmentos lineales uniendo los puntos que bien se dan en formato
     <discrete>, o que se calculan automáticamente a partir de la
     expresión dada, de acuerdo con el tamaño muestral indicado por la
     opción <nticks>.  Asimismo, la opción <style> puede utilizarse
     para mostrar los puntos aislados, o éstos junto con los segmentos
     que los unen.

     Hay varias opciones globales almacenadas en la lista
     <plot_options>, las cuales se pueden modificar con la función
     `set_plot_option'; cualquiera de estas opciones puede ignorarse
     con las opciones que se utilicen desde el comando <plot2d>.

     Las funciones a ser representadas pueden especificarse con el
     nombre de una función u operador de Maxima o de Lisp, con una
     expresión lambda de MAxima, o con una expresión válida de maxima.
     En caso de especificarse con un nombre o expresión lambda, la
     función debe ser tal que dependa de un solo argumento.

     Ejemplos:

     Gráficos de funciones ordinarias.

          (%i1) plot2d (sin(x), [x, -5, 5])$

          (%i2) plot2d (sec(x), [x, -2, 2], [y, -20, 20], [nticks, 200])$

     Especificación de funciones por su nombre.

          (%i3) F(x) := x^2 $

          (%i4) :lisp (defun |$g| (x) (m* x x x))

          $g
          (%i5) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $

          (%i6) plot2d (F, [u, -1, 1])$

          (%i7) plot2d ([F, G, H], [u, -1, 1], [y, -1.5, 1.5])$

     Se puede representar una circunferencia como una función
     paramétrica de parámetro <t>. No es necesario especificar el rango
     del eje horizontal, pues el propio rango de <t> determina el
     dominio. No obstante, ya que las longitudes de los ejes horizontal
     y vertical están en una proporción de 4 a 3, se utilizará la
     opción <xrange> para conseguir la misma escala en ambos ejes:

          (%i8) plot2d ([parametric, cos(t), sin(t), [t,-%pi,%pi],
                       [nticks,80]], [x, -4/3, 4/3])$

     Si se repite el mismo gráfico con solo 8 puntos y se extiende el
     rango del parámetro para que dé dos vueltas, se tiene el dibujo de
     una estrella:

          (%i9) plot2d ([parametric, cos(t), sin(t), [t, -%pi*2, %pi*2],
                  [nticks, 8]], [x, -2, 2], [y, -1.5, 1.5])$

     Combinación del gráfico de un polinomio cúbico y de una
     circunferencia paramétrica:

          (%i10) plot2d ([x^3+2, [parametric, cos(t), sin(t), [t, -5, 5],
                  [nticks, 80]]], [x, -3, 3])$

     Ejemplo de gráfico logarítmico:

          (%i11) plot2d (exp(3*s), [s, -2, 2], [logy])$

     Ejemplos de gráficos de puntos, empezando por la definición de las
     coordenadas de cinco puntos en los dos formatos admisibles:

          (%i12) xx:[10, 20, 30, 40, 50]$
          (%i13) yy:[.6, .9, 1.1, 1.3, 1.4]$
          (%i14) xy:[[10,.6], [20,.9], [30,1.1], [40,1.3], [50,1.4]]$

     Representación de los puntos unidos por segmentos:

          (%i15) plot2d([discrete,xx,yy])$

     Representación de los puntos aislados, ilustrando también la
     segunda forma de especificar las coordenadas:

          (%i16) plot2d([discrete, xy], [style, points])$

     El gráfico de los puntos se puede mostrar conjuntamente con el de
     la función ter'ica que los predice:

          (%i17) plot2d([[discrete,xy], 2*%pi*sqrt(l/980)], [l,0,50],
                  [style, [points,5,2,6], [lines,1,1]],
                  [legend,"experiment","theory"],
                  [xlabel,"pendulum's length (cm)"], [ylabel,"period (s)"])$

     El significado de los tres números después de la opción "points"
     es el siguiente: 5, radio de los puntos; 2, índice del color
     (rojo); 6, tipo de objeto utilizado (cuadrados sólidos). Los dos
     números después de la opción "lines" hacen referencia al ancho de
     la línea (1 punto) y al color (1 para el azul).

     Véase también `plot_options', que describe las opciones gráficas,
     junto con más ejemplos.


 -- Función: xgraph_curves (<list>)
     Dibuja el conjunto de puntos de la lista del argumento <list> con
     el programa xgraph. Si el programa xgraph no está instalado, este
     comando producirá un error.

     El conjunto de puntos puede ser de la forma

          [x0, y0, x1, y1, x2, y2, ...]
     o
          [[x0, y0], [x1, y1], ...]

     Un conjunto de puntos también puede contener símbolos con
     etiquetas u otra información.

          xgraph_curves ([pt_set1, pt_set2, pt_set3]);

     dibuja los tres conjuntos de puntos como tres curvas.

          pt_set: append (["NoLines: True", "LargePixels: true"],
                                    [x0, y0, x1, y1, ...]);

     construye el conjunto de puntos, declara que no haya segmentos
     rectilíneos entre ellos y que se utilicen píxeles grandes. Véase
     el manual de xgraph para más opciones.

          pt_set: append ([concat ("\"", "x^2+y")], [x0, y0, x1, y1, ...]);

     construye una etiqueta con el contenido "x^2+y" para este conjunto
     particular de puntos. Las comillas dobles `"' al comienzo son las
     que le indican a xgraph que se trata de una etiqueta.

          pt_set: append ([concat ("TitleText: Datos muestrales")], [x0, ...])$

     establece el título principal del gráfico como "Datos muestrales"
     en lugar de "Maxima Plot".

     Para hacer un gráfico de barras con columnas de 0.2 unidades de
     ancho y para dibujar dos diagramas diferentes de este tipo:
          (%i1) xgraph_curves ([append (["BarGraph: true", "NoLines: true",
                "BarWidth: .2"], create_list ([i - .2, i^2], i, 1, 3)),
                append (["BarGraph: true", "NoLines: true", "BarWidth: .2"],
                create_list ([i + .2, .7*i^2], i, 1, 3))]);

     Se utiliza un fichero temporal `xgraph-out'.


 -- Variable del sistema: plot_options
     Los elementos de esta lista establecen las opciones por defecto
     para los gráficos.  Si una opción está presente en una llamada a
     `plot2d' o a `plot3d', este valor adquiere prevalencia sobre las
     opciones por defecto.  En otro caso se utilizará el valor que
     tenga en `plot_options'.  Las opciones por defecto se asignan
     mediante la función `set_plot_option'.

     Cada elemento de `plot_options' es una lista de dos o más
     elementos, el primero de los cuales es el nombre de la opción,
     siendo los siguientes los valores de aquélla. En algunos casos el
     valor asignado es a su vez una lista, que puede contener varios
     elementos.

     Las opciones gráficas que reconocen `plot2d' y `plot3d' son:

        * Opción: `plot_format'

          Determina qué programa gráfico se va a utilizar con `plot2d'
          y `plot3d'.

             * Valor: `gnuplot' (es el valor por defecto en Windows)
               Gnuplot es el programa por defecto y el más avanzado.
               Requiere de una instalación externa de gnuplot.

             * Value: `gnuplot_pipes' (es el valor por defecto en
               sistemas distintos de Windows) Es similar al formato
               `gnuplot', excepto que la comunicación con Gnuplot se
               hace por medio de una tubería. Se debería utilizar para
               ver gráficos en pantalla; para guardar gráficos en
               srchivos, mejor utilizar el formato `gnuplot'.

             * Valor: `mgnuplot' Mgnuplot es una interfaz para Gnuplot
               basada en Tk. Se incluye en la distribución de Maxima.
               Mgnuplot ofrece una interface gráfica de usuario
               rudimentaria para gnuplot, pero tiene algunas mejoras
               respecto de la interface propia de gnuplot. Mgnuplot
               requiere de una instalación externa de gnuplot y de
               Tcl/Tk.

             * Valor: `openmath' Openmath es un programa gráfico
               escrito en Tcl/Tk. Este formato lo suministra el paquete
               Xmaxima, que se distribuye junto con Maxima; se deberá
               instalar Xmaxima si se quiere usar este formato. No sólo
               se puede utilizar Openmath desde Xmaxima, sino también
               desde cualquier otro interfaz gráfico para Maxima.


        * Opción: `run_viewer'

          Controla si el visor apropiado para la salida gráfica debe
          ejecutarse o no.

             * Valor por defecto: `true'

               Ejecuta el visor.

             * Valor: `false'

               No ejecuta el visor.

        * Opción: `y'

          Rango vertical del gráfico.

          Ejemplo:

               [y, - 3, 3]
          Establece el rango vertical como [-3, 3].

        * Opción: `plot_realpart' Si `plot_realpart' vale `true', se
          representará la parte real de un valor complejo <x>, lo cual
          equivale a representar `realpart(<x>)' en lugar de <x>.  Si
          vale `false', sólo se representarán aquellos valores con
          parte imaginaria nula, ignorando así cualesquiera valores
          complejos.

          Ejemplo:

               plot2d (log(x), [x, -5, 5], [plot_realpart, false]);
               plot2d (log(x), [x, -5, 5], [plot_realpart, true]);
          El valor por defecto es `false'.

        * Opción: `nticks'

          En `plot2d', es el número inicial de puntos utilizados por el
          procedimiento adaptativo para la representación de funciones.
          También es el número de puntos a ser calculados en los
          gráficos paramétricos.

          Ejemplo:

               [nticks, 20]
          El valor por defecto para `nticks' es 29.

        * Opción: `adapt_depth'

          Número máximo de particiones utilizado por el algoritmo
          adaptativo de representación gráfica.

          Ejemplo:

               [adapt_depth, 5]
          El valor por defecto para `adapt_depth' es 10.

        * Opción: `xlabel'

          Etiqueta del eje horizontal en gráficos 2d.

          Ejemplo:

               [xlabel, "Time in seconds"]

        * Opción: `ylabel'

          Etiqueta del eje vertical en gráficos 2d.

          Ejemplo:

               [ylabel, "Temperature"]

        * Opción: `logx'

          Hace que el eje horizontal en los gráficos 2d se dibuje en la
          escala logarítmica. No necesita de parámetros adicionales.

        * Opción: `logy'

          Hace que el eje vertical en los gráficos 2d se dibuje en la
          escala logarítmica. No necesita de parámetros adicionales.

        * Opción: `legend'

          Etiquetas para las expresiones de los gráficos 2d. Si hay más
          expresiones que etiquetas, éstas se repetirán. Por defecto se
          pasarán los nombres de las expresiones o funciones, o las
          palabras `discrete1', `discrete2', ..., para gráficos de
          puntos.

          Ejemplo:

               [legend, "Set 1", "Set 2", "Set 3"]

        * Opción: `box'

          Actualmente esta opción sólo puede ir seguida del símbolo
          _false_, pero será utilizada en el futuro para eliminar el
          marco alrededor del gráfico.

          Ejemplo:

               [box, false]

        * Opción: `style'

          Estilos a utilizar para las funciones o conjuntos de datos en
          gráficos 2d. A la palabra `style' debe seguirle uno o más
          estilos. Si hay más funciones o conjuntos de datos que
          estilos, éstos se repetirán. Los estilos que se admiten son:
          <lines> para segmentos lineales, <points> para puntos
          aislados, <linespoints> para segmentos y puntos, <dots> para
          pequeños puntos aislados. Gnuplot también acepta el estilo
          <impulses>.

          Los estilos se pueden escribir como elementos de una lista,
          junto con algunos parámetros adicionales. <lines> acepta uno
          o dos números: el ancho de la línea y un entero que identifica
          el color. Los códigos de color por defecto son: 1, azul; 2,
          rojo; 3, magenta; 4, naranja; 5, marrón; 6, verde lima; 7,
          aguamarina.  En caso de utilizar Gnuplot con un terminal
          diferente de X11, estos colores pueden cambiar; por ejemplo,
          bajo la opción [<gnuplot_term>,<ps>], el índice 4 se
          corresponde con el negro en lugar del naranja.

          <points> acepta uno, dos o tres parámetros; el primer
          parámetro es el radio de los puntos, el segundo es un entero
          para seleccionar el color, con igual codificación que en
          <lines> y el tercer parámetro sólo es utilizado por Gnuplot y
          hace referencia a varios objetos para representar los puntos.
          Los tipos de objetos disponibles son: 1, círculos rellenos;
          2, circunferencias; 3, +; 4, x; 5, *; 6, cuadrados rellenos;
          7, cuadrados huecos; 8, triángulos rellenos; 9, triángulos
          huecos; 10, triángulos rellenos invertidos; 11, triángulos
          huecos invertidos; 12, rombos rellenos; 13, rombos huecos.

          <linesdots> acepta hasta cuatro parámetros: ancho de línea,
          radio de los puntos, color y tipo de objetos para representar
          puntos.

          Ejemplo:
               [style,[lines,2,3],[points,1,4,3]]

          En este ejemplo se representará la primera (tercera, quinta,
          etc. ) expresión con segmentos rectilíneos magenta de ancho
          2, la segunda (cuarta, sexta, etc.) expresión con símbolos de
          suma naranja de tamanõ 1 (círculos naranja en el caso de
          Openmath).

          El estilo por defecto es <lines> de ancho 1 y diferentes
          colores.

        * Opción: `grid' Establece el número de puntos de la retícula a
          utilizar en las direcciones x e y en los gráficos de tres
          dimensiones.

          Ejemplo:

               [grid, 50, 50]

          establece la retícula en 50 por 50 puntos. El valor por
          defecto es 30 por 30.

        * Opción: `transform_xy'

          Permite que se realicen transformaciones en los gráficos de
          tres dimensiones.

          Ejemplo:

               [transform_xy, false]
          El valor por defecto de `transform_xy' es `false'. Cuando
          vale `false', da el resultado de

               make_transform([x,y,z], f1(x,y,z), f2(x,y,z), f3(x,y,z))$
          La transformación `polar_xy' está definida en Maxima.
          Devuelve la misma transformación que

               make_transform ([r, th, z], r*cos(th), r*sin(th), z)$

     Opciones de Gnuplot:

     Hay varias opciones gráficas que son específicas de gnuplot.
     Algunas de ellas son comandos propios de gnuplot que se
     especifican como cadenas alfanuméricas.  Consúltese la
     documentación de Gnuplot para más detalles.

        * Opción: `gnuplot_term'

          Establece el terminal de salida para Gnuplot.

             * Valor por defecto: `default'

               Gnuplot muestra el gráfico en una ventana gráfica.

             * Valor: `dumb'

               Gnuplot muestra el gráfico en la consola de Maxima en
               estilo ASCII artístico.

             * Valor: `ps'

               Gnuplot genera código en lenguaje PostScript.  Si a la
               opción `gnuplot_out_file' se le da el valor <filename>,
               Gnuplot escribe el código PostScript en <filename>. En
               caso contrario, se guarda en el archivo `maxplot.ps'.

             * Valor: Cualquier otro terminal admitido por Gnuplot.

               Gnuplot puede generar gráficos en otros muchos formatos,
               tales como png, jpeg, svg etc. Para crear gráficos en
               cualquera de estos formatos, a la opción `gnuplot_term'
               se le puede asignar cualquiera de los terminales
               admitidos por Gnuplot, bien por su nombre (símbolo) bien
               con la especificación completa del terminal (cadena).
               Por ejemplo, `[gnuplot_term,png]' guarda el gráfico en
               formato PNG (Portable Network Graphics), mientras que
               `[gnuplot_term,"png size 1000,1000"]' lo hace con
               dimensiones 1000x1000 píxeles.  Si a la opción
               `gnuplot_out_file' se le da el valor <filename>, Gnuplot
               escribe el código PostScript en <filename>. En caso
               contrario, se guarda en el archivo `maxplot.<term>',
               siendo <term> el nombre del terminal.


        * Opción: `gnuplot_out_file'

          Guarda el gráfico generado por Gnuplot en un archivo.

             * Valor por defecto: `false'

               No se especifica nombre de fichero.

             * Valor: <filename>

               Con `[gnuplot_out_file, "myplot.ps"]' se envía código
               PostScript al archivo `myplot.ps' cuando se utiliza
               conjuntamente con el terminal PostScript de Gnuplot.

        * Opción: `gnuplot_pm3d'

          Controla la utilización del modo PM3D, que tiene capacidades
          avanzadas para gráficos tridimensionales. PM3D sólo está
          disponible en versiones de Gnuplot posteriores a la 3.7. El
          valor por defecto de `gnuplot_pm3d' es `false'.

          Ejemplo:

               [gnuplot_pm3d, true]

        * Opción: `gnuplot_preamble'

          Introduce instrucciones de gnuplot antes de que se haga el
          dibujo. Puede utilizarse cualquier comando válido de gnuplot.
          Si interesa introducir varios comandos se separarán con punto
          y coma. El ejemplo que se muestra produce un gráfico en
          escala logarítmica. El valor por defecto de
          `gnuplot_preamble' es la cadena vacía `""'.

          Ejemplo:

               [gnuplot_preamble, "set log y"]

        * Opción: `gnuplot_curve_titles'

          Controla los títulos dados a la clave del gráfico. El valor
          por defecto es  `[default]', el cual establece
          automáticamente los títulos para cada curva representada. Si
          no es `[default]', `gnuplot_curve_titles' debe contener una
          lista de cadenas, cada una de las cuales es `"title
          '<title_string>'"'. (Para desactivar la clave del gráfico,
          añádase `"set nokey"' a `gnuplot_preamble'.)

          Ejemplo:

               [gnuplot_curve_titles, ["title 'My first function'", "title 'My second function'"]]

        * Opción: `gnuplot_curve_styles'

          Es una lista de cadenas que controlan el aspecto de las
          curvas, como el color, el ancho, la discontinuidad, etc., y
          que deben enviarse al comando `plot' de gnuplot. El valor por
          defecto es `["with lines 3", "with lines 1", "with lines 2",
          "with lines 5", "with lines 4", "with lines 6", "with lines
          7"]', que realiza un ciclo sobre un conjunto de colores
          diferentes. Consúltese la documentación de gnuplot sobre
          `plot' para más información.

          Ejemplo:

               [gnuplot_curve_styles, ["with lines 7", "with lines 2"]]

        * Opción: `gnuplot_default_term_command'

          Comando de gnuplot para establecer el tipo de terminal por
          defecto.  El valor por defecto es `set term windows "Verdana"
          15' en sistemas Windows, y `set term x11 font "Helvetica,16"'
          en sistemas X11.

          Ejemplo:

               [gnuplot_default_term_command, "set term x11"]

        * Opción: `gnuplot_dumb_term_command'

          Comando de gnuplot para establecer el tipo de terminal para
          el terminal oculto. El valor por defecto es `"set term dumb
          79 22"', que da una salida de texto de 79 por 22 caracteres.

          Ejemplo:

               [gnuplot_dumb_term_command, "set term dumb 132 50"]

        * Opción: `gnuplot_ps_term_command'

          Comando de gnuplot para establecer el tipo de terminal para
          el terminal PostScript. El valor por defecto es `"set size
          1.5, 1.5;set term postscript eps enhanced color solid 24"',
          que establece un tamaño de 1.5 veces el valor por defecto de
          gnuplot, junto con un tamaño de fuente de 24, entre otras
          cosas. Consúltese la documentación de gnuplot para más
          información sobre `set term postscript'.

          Ejemplo:

          Todas las figuras de los ejemplos de la función <plot2d> de
          este manual se obtuvieron a partir de archivos Postscript
          generados asignándole a `gnuplot_ps_term_command' el valor

               [gnuplot_ps_term_command,"set size 1.3, 1.3;\
                set term postscript eps color solid lw 2.5 30"]


     Ejemplos:

        * Almacena un gráfico de `sin(x)' en el fichero `sin.eps'.

          (%i1) plot2d (sin(x), [x, 0, 2*%pi], [gnuplot_term, ps],
                                  [gnuplot_out_file, "sin.eps"])$

        * Utiliza la opción y para saltarse las singularidades, así
          como la opción `gnuplot_preamble' para colocar la clave en la
          parte inferior del dibujo.

          (%i2) plot2d ([gamma(x), 1/gamma(x)], [x, -4.5, 5], [y, -10, 10],
                               [gnuplot_preamble, "set key bottom"])$

        * Utiliza un `gnuplot_preamble' bastante complicado a fin de
          producir etiquetas en el eje x.  (Nótese que la cadena de
          `gnuplot_preamble' debe introducirse sin saltos de línea.)

          (%i3) my_preamble: "set xzeroaxis; set xtics ('-2pi' -6.283, \
          '-3pi/2' -4.712, '-pi' -3.1415, '-pi/2' -1.5708, '0' 0, \
          'pi/2' 1.5708, 'pi' 3.1415,'3pi/2' 4.712, '2pi' 6.283)"$

          (%i4) plot2d([cos(x), sin(x), tan(x), cot(x)],
                 [x, -2*%pi, 2.1*%pi], [y, -2, 2],
                 [gnuplot_preamble, my_preamble]);

        * Utiliza un `gnuplot_preamble' bastante complicado a fin de
          producir etiquetas en el eje x, produciendo una salida
          PostScript que aprovecha el formateo avanzado de texto
          disponible en gnuplot.  (Nótese que la cadena de
          `gnuplot_preamble' debe introducirse sin saltos de línea.)

          (%i5) my_preamble: "set xzeroaxis; set xtics ('-2{/Symbol p}' \
          -6.283, '-3{/Symbol p}/2' -4.712, '-{/Symbol p}' -3.1415, \
          '-{/Symbol p}/2' -1.5708, '0' 0,'{/Symbol p}/2' 1.5708, \
          '{/Symbol p}' 3.1415,'3{/Symbol p}/2' 4.712, '2{/Symbol p}' \
          6.283)"$

          (%i6) plot2d ([cos(x), sin(x), tan(x)], [x, -2*%pi, 2*%pi],
              [y, -2, 2], [gnuplot_preamble, my_preamble],
              [gnuplot_term, ps], [gnuplot_out_file, "trig.eps"]);

        * Un gráfico tridimensional utilizando el terminal pm3d de
          gnuplot.

          (%i7) plot3d (atan (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
                  [grid, 50, 50], [gnuplot_pm3d, true])$

        * Un gráfico tridimensional sin malla y con contornos
          proyectados sobre el plano inferior.

          (%i8) my_preamble: "set pm3d at s;unset surface;set contour;\
          set cntrparam levels 20;unset key"$
          (%i9) plot3d(atan(-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [grid, 50, 50], [gnuplot_pm3d, true],
              [gnuplot_preamble, my_preamble])$

        * Un gráfico en el que el eje z sólo se representa por el color.
          (Nótese que la cadena de `gnuplot_preamble' debe introducirse
          sin saltos de línea.)

          (%i10) plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [gnuplot_preamble, "set view map; unset surface"],
              [gnuplot_pm3d, true], [grid, 150, 150])$


 -- Function: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_range>,
          <y_range>, ..., <options>, ...)
 -- Función: plot3d (<expr>, <x_range>, <y_range>, ..., <options>, ...)
 -- Función: plot3d (<name>, <x_range>, <y_range>, ..., <options>, ...)
 -- Función: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_rge>, <y_rge>)
 -- Función: plot3d ([<name_1>, <name_2>, <name_3>], <x_range>,
          <y_range>, ..., <options>, ...)
     Representa gráficamente una o tres expresiones como funciones de
     dos variables.

          (%i1) plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2]);

     dibuja `z = 2^(-u^2+v^2)' con `u' y `v' variando en [-3,3] y
     [-2,2] respectivamente, y con <u> sobre el eje x, y con `v' sobre
     el eje y.

     El mismo gráfico se puede dibujar usando openmath (si Xmaxima fué
     instalado):

          (%i2)  plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2],
                         [plot_format, openmath]);

     en este caso el ratón se puede usar para rotar el gráfico y ver la
     superficie desde diferentes lados.

     Un ejemplo del tercer patrón de argumentos es

          (%i3) plot3d ([cos(x)*(3 + y*cos(x/2)), sin(x)*(3 + y*cos(x/2)),
             y*sin(x/2)], [x, -%pi, %pi], [y, -1, 1], ['grid, 50, 15]);

     que dibuja una banda de Moebius, parametrizada por las tres
     expresiones dadas como primer argumento a `plot3d'. Un argumento
     opcional `['grid, 50, 15]' da el número de intervalos en las
     direcciones x e y, respectivamente.

     Cuando la función a representar ha sido definida en Maxima
     mediante  `:=' o `define', o en Lisp por DEFUN o DEFMFUN, entonces
     se podrá especificar por su nombre. Las funciones definidas a
     nivel de LISP por DEFMSPEC, las funciones de simplificación, junto
     con muchas otras funciones, no pueden especificarse directamente
     por su nombre.

     Este ejemplo muestra un gráfico de la parte real de `z^1/3'.

          (%i4) plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
                ['grid, 12, 80], ['transform_xy, polar_to_xy]);

     Otros ejemplos son la botella de Klein:

          (%i5) expr_1: 5*cos(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y)
                + 3.0) - 10.0$
          (%i6) expr_2: -5*sin(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y)
                + 3.0)$
          (%i7) expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y))$

          (%i8) plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi],
                [y, -%pi, %pi], ['grid, 40, 40]);

     y un toro:

          (%i9) expr_1: cos(y)*(10.0+6*cos(x))$
          (%i10) expr_2: sin(y)*(10.0+6*cos(x))$
          (%i11) expr_3: -6*sin(x)$
          (%i12) plot3d ([expr_1, expr_2, expr_3], [x, 0, 2*%pi],
                 [y, 0, 2*%pi], ['grid, 40, 40]);

     En ocasiones puede ser necesario definir una función para
     representarla. Todos los argumentos de `plot3d' se evalúan, de
     manera que puede ser difícil escribir una expresión que haga lo
     que el usuario realmente quiere; en tales casos facilita las cosas
     definir previamente la función.

          (%i13) M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4],
                 [1, 2, 3, 3])$
          (%i14) f(x, y) := float (M [?round(x), ?round(y)])$
          (%i15) plot3d (f, [x, 1, 4], [y, 1, 4], ['grid, 4, 4])$

     Véase  `plot_options' para más ejemplos.


 -- Función: make_transform (<vars>, <fx>, <fy>, <fz>)
     Devuelve una función apropiada para la función de transformación
     de `plot3d'. Debe usarse con la opción gráfica `transform_xy'.
          make_transform ([r, th, z], r*cos(th), r*sin(th), z)$
     es una transformación para pasar a coordenadas polares.

 -- Función: set_plot_option (<option>)
     Asigna un valor a una de las variables globales que controlan los
     gráficos. El argumento <option> se especifica como una lista de
     dos o más elementos, en la que el primero es el nombre de una de
     las opciones de la lista `plot_options'.

     La función `set_plot_option' evalúa sus argumentos y devuelve
     `plot_options' tal como queda después de la actualización.

     Véanse también `plot_options', `plot2d' y `plot3d'.

     Ejemplos:

     Se modifican los valores de `grid' y `x'.  Si a un nombre de
     opción de `plot_options' tiene ya un valor asignado, hacerlo
     preceder de un apóstrofo para evitar su evaluación.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[x, - 1.755559702014E+305, 1.755559702014E+305],
          [y, - 1.755559702014E+305, 1.755559702014E+305], [t, - 3, 3],
          [grid, 30, 40], [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]
          (%i2) x: 42;
          (%o2)                          42
          (%i3) set_plot_option (['x, -100, 100]);
          (%o3) [[x, - 100.0, 100.0], [y, - 1.755559702014E+305,
          1.755559702014E+305], [t, - 3, 3], [grid, 30, 40],
          [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]


   Funciones para trabajar con el formato gnuplot_pipes:

 -- Función: gnuplot_start ()
     Inicializa una tubería hacia Gnuplot, con el fin de ser utilizada
     para utilizar el formato `gnuplot_pipes'.  No es necesario
     inicializarla manualmente antes de hacer gráficos.


 -- Función: gnuplot_close ()
     Cierra la tubería hacia Gnuplot que haya sido utilizada para hacer
     gráficos.


 -- Función: gnuplot_restart ()
     Cierra la tubería hacia Gnuplot que haya sido utilizada para hacer
     gráficos e inicializa una nueva.


 -- Función: gnuplot_replot ()
 -- Función: gnuplot_replot (<s>)
     Actualiza la ventana de Gnuplot. Si `gnuplot_replot' es invocada
     con un comando de Gnuplot en la cadena <s>, entonces <s> es
     enviada a Gnuplot antes de redibujar la ventana.


 -- Función: gnuplot_reset ()
     Resetea Gnuplot cuando se utiliza el formato `gnuplot_pipes'.
     Para actualizar la ventana de Gnuplot invóquese a `gnuplot_replot'
     después de `gnuplot_reset'.



File: maxima.info,  Node: Lectura y escritura,  Next: Aritmética de punto flotante,  Prev: Gráficos,  Up: Top

9 Lectura y escritura
*********************

* Menu:

* Comentarios::
* Archivos::
* Funciones y variables para lectura y escritura::


File: maxima.info,  Node: Comentarios,  Next: Archivos,  Prev: Lectura y escritura,  Up: Lectura y escritura

9.1 Comentarios
===============

En Maxima, un comentario es cualquier texto encerrado entre las marcas
`/*' y `*/'.

   El analizador sintáctico de Maxima trata los comentarios como
espacios en blanco a efectos de encontrar tokens en el flujo de
entrada. Una entrada tal como `a/* foo */b' contiene dos tokens, `a' y
`b', no un único token `ab'.  En cualquier otro contexto, los
comentarios son ignorados por Maxima; no se almacenan ni sus contenidos
ni sus localizaciones.

   Los comentarios pueden anidarse hasta una profundidad arbitraria.
Las marcas  `/*' y `*/' deben emparejarse y debe haber igual número de
ambos.

   Ejemplos:

     (%i1) /* aa is a variable of interest */  aa : 1234;
     (%o1)                         1234
     (%i2) /* Value of bb depends on aa */  bb : aa^2;
     (%o2)                        1522756
     (%i3) /* User-defined infix operator */  infix ("b");
     (%o3)                           b
     (%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
     (%o4)                         a b c
     (%i5) /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
     (%o5)                        xyz + 1


File: maxima.info,  Node: Archivos,  Next: Funciones y variables para lectura y escritura,  Prev: Comentarios,  Up: Lectura y escritura

9.2 Archivos
============

Un archivo no es más que una área de un cierto dispositivo de
almacenamiento que contiene datos o texto.  Los archivos se agrupan en
los discos en "directorios", que son listas de archivos.  Instrucciones
que operan con archivos son: `save', `load', `loadfile', `stringout',
`batch', `demo', `writefile', `closefile' y `appendfile'.


File: maxima.info,  Node: Funciones y variables para lectura y escritura,  Prev: Archivos,  Up: Lectura y escritura

9.3 Funciones y variables para lectura y escritura
==================================================

 -- Variable del sistema: __
     `__' es la expresión de entrada que está siendo actualmente
     evaluada.  Esto es, mientras se está evaluando una expresión de
     entrada, `__' es igual a <expr>.

     A `__' se le asigna la expresión de entrada antes de que ésta sea
     simplificada o evaluada. Sin embargo, el valor de `__' es
     simplificado, pero no evaluado, cuando su valor es mostrado en el
     terminal.

     La variable `__' es reconocida por  `batch' y por `load'.  Cuando
     un fichero es procesado por `batch', la variable `__' tiene el
     mismo significado que en el modo interactivo.  Cuando un fichero
     es procesado por `load', a la variable `__' se le asigna la última
     expresión introducida, bien desde el modo interactivo, bien en un
     fichero por lotes; en ningún caso se le asigna a `__' una
     expresión de entrada del fichero que está siendo procesado.  En
     particular, si `load (<filename>)' es ejecutado desde el modo
     interactivo, entonces `__' almacena la expresión `load
     (<filename>)' mientras el fichero está siendo procesado.

     Véanse también `_' y `%'.

     Ejemplos:

          (%i1) print ("I was called as", __);
          I was called as print(I was called as, __)
          (%o1)              print(I was called as, __)
          (%i2) foo (__);
          (%o2)                     foo(foo(__))
          (%i3) g (x) := (print ("Current input expression =", __), 0);
          (%o3) g(x) := (print("Current input expression =", __), 0)
          (%i4) [aa : 1, bb : 2, cc : 3];
          (%o4)                       [1, 2, 3]
          (%i5) (aa + bb + cc)/(dd + ee + g(x));
                                      cc + bb + aa
          Current input expression = --------------
                                     g(x) + ee + dd
                                          6
          (%o5)                        -------
                                       ee + dd


 -- Variable del sistema: _
     El símbolo `_' representa la última expresión de entrada (esto es,
     `%i1', `%i2', `%i3', ...).

     Al símbolo `_' se le asigna la expresión de entrada antes de que
     ésta sea simplificada o evaluada. Sin embargo, el valor de `_' se
     simplifica (pero no se evalúa) cuando se muestra en el terminal.

     La variable `_' es reconocida por  `batch' y por `load'.  Cuando
     un fichero es procesado por `batch', la variable `_' tiene el
     mismo significado que en el modo interactivo.  Cuando un fichero
     es procesado por `load', a la variable `_' se le asigna la última
     expresión introducida, bien desde el modo interactivo, bien en un
     fichero por lotes; en ningún caso se le asigna a `_' una expresión
     de entrada del fichero que está siendo procesado.

     Véanse también `__' y `%'.

     Ejemplos:

          (%i1) 13 + 29;
          (%o1)                          42
          (%i2) :lisp $_
          ((MPLUS) 13 29)
          (%i2) _;
          (%o2)                          42
          (%i3) sin (%pi/2);
          (%o3)                           1
          (%i4) :lisp $_
          ((%SIN) ((MQUOTIENT) $%PI 2))
          (%i4) _;
          (%o4)                           1
          (%i5) a: 13$
          (%i6) b: 29$
          (%i7) a + b;
          (%o7)                          42
          (%i8) :lisp $_
          ((MPLUS) $A $B)
          (%i8) _;
          (%o8)                         b + a
          (%i9) a + b;
          (%o9)                          42
          (%i10) ev (_);
          (%o10)                         42


 -- Variable del sistema: %
     El símbolo `%' representa la expresión de salida (esto es, `%o1',
     `%o2', `%o3', ...)  más reciente calculada por Maxima,
     independientemente de que la haya mostrado o no.

     La variable `%' es reconocida por  `batch' y por `load'.  Cuando
     un fichero es procesado por `batch', la variable `%' tiene el
     mismo significado que en el modo interactivo.  Cuando un fichero
     es procesado por `load', a la variable `%' se le asigna la última
     expresión introducida, bien desde el modo interactivo, bien en un
     fichero por lotes; en ningún caso se le asigna a `%' una expresión
     de entrada del fichero que está siendo procesado.

     Véanse también `_', `%%' y `%th'.


 -- Variable del sistema: %%
     En una sentencia compuesta, como `block', `lambda' o `(<s_1>, ...,
     <s_n>)', `%%' es el valor de la sentencia previa.  Por ejemplo,

          block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
          block ([prev], prev: integrate (x^5, x),
                         ev (prev, x=2) - ev (prev, x=1));

     devuelven el mismo resultado  `21/2'.

     Una sentencia compuesta puede contener otras sentencias compuestas.
     Independientemente de que una sentencia sea simple o compuesta,
     `%%' es el valor de la sentencia previa.  Por ejemplo,

          block (block (a^n, %%*42), %%/6)

     devuelve `7*a^n'.

     Dentro de una sentencia compuesta, el valor de `%%' puede
     inspeccionarse en un punto de interrupción que se abra ejecutando
     la función `break'. Por ejemplo, en el punto de interrupción
     abierto por

          block (a: 42, break ())$

     introduciendo `%%;' se obtiene `42'.

     En la primera sentencia de una sentencia compuesta, o fuera de una
     sentencia compuesta, `%%' no está definido.

     La variable `%%' es reconocida por  `batch' y por `load'.  Cuando
     un fichero es procesado por `batch', la variable `%%' tiene el
     mismo significado que en el modo interactivo.

     Véase también `%'.


 -- Variable opcional: %edispflag
     Valor por defecto: `false'

     Si `%edispflag' vale `true', Maxima muestra `%e' elevado a un
     exponente negativo como un cociente.  Por ejemplo, `%e^-x' se
     muestra como `1/%e^x'.


 -- Función: %th (<i>)
     Es el valor de la expresión de la <i>-ésima salida anterior.  Esto
     es, si la siguiente expresión a calcular es la salida <n>-ésima,
     `%th (<m>)' es la salida  (<n> - <m>)-ésima.

     La función `%th' es útil en archivos tipo `batch' o para hacer
     referencia a un grupo de expresiones de salida.  Por ejemplo,

          block (s: 0, for i:1 thru 10 do s: s + %th (i))$

     asigna a `s' la suma de las diez últimas expresiones de salida.

     La variable `%th' es reconocida por  `batch' y por `load'.  Cuando
     un fichero es procesado por `batch', la variable `%th' tiene el
     mismo significado que en el modo interactivo.  Cuando un fichero
     es procesado por `load', a la variable `%th' se le asigna la
     última expresión introducida, bien desde el modo interactivo, bien
     en un fichero por lotes; en ningún caso se le asigna a `%th' una
     expresión de entrada del fichero que está siendo procesado.

     Véase también `%'.


 -- Símbolo especial: ?
     Como prefijo de una función o nombre de variable, `?' significa
     que el nombre es de Lisp, no de Maxima.  Por ejemplo, `?round'
     representa la función de Lisp `ROUND'.  Véase `Lisp y Maxima' para
     más información.

     La notación `? word' (un símbolo de interrogación seguido de una
     palabra y separados por un espacio) equivale a `describe ("word")'.
     El símbolo de interrogación debe escribirse al comienzo de la
     línea de entrada; en caso contrario no se reconoce como una
     solicitud de documentación.


 -- Símbolo especial: ??
     La notación `?? palabra' (`??' seguido de un espacio y una
     palabra) equivale a `describe("palabra", inexact)'.  El símbolo de
     interrogación debe escribirse al comienzo de la línea de entrada;
     en caso contrario no se reconoce como una solicitud de
     documentación.


 -- Variable opcional: absboxchar
     Valor por defecto: `!'

     La variable `absboxchar' es el carácter utilizado para representar
     el valor absoluto de una expresión que ocupa más de una línea de
     altura.


 -- Variable opcional: file_output_append
     Valor por defecto: `false'

     La variable `file_output_append' controla si las funciones de
     escritura de ficheros añaden información o sustituyen el fichero
     de salida. Cuando `file_output_append' toma el valor `true', estas
     funciones amplían el contenido de sus ficheros de salida; en otro
     caso, sustituyen el fichero anterior de igual nombre por otro con
     el nuevo contenido.

     Las funciones `save', `stringout' y `with_stdout' se ven afectadas
     por el valor que tome la variable `file_output_append'. Otras
     funciones que también escriben en ficheros de salida no tienen en
     cuenta este valor; en concreto, las funciones para la
     representación de gráficos y las de traducción siempre sustituyen
     el fichero anterior por uno nuevo de igual nombre, mientras que
     las funciones `tex' y `appendfile' siempre añaden información al
     fichero de salida sin eliminar la información anterior.


 -- Función: appendfile (<filename>)
     Añade información de la consola a <filename>, de igual manera que
     lo hace `writefile', pero con la salvedad de que si el archivo ya
     existe la información queda añadida al final de su contenido.

     La función `closefile' cierra los archivos abiertos por
     `appendfile' o `writefile'.


 -- Función: batch (<filename>)
     Lee expresiones de Maxima desde <filename> y las evalúa. La función
     `batch' busca <filename> en la lista `file_search_maxima'.  Véase
     `file_search'.

     El contenido de <filename> debe ser una secuencia de expresiones
     de Maxima, cada una de las cuales termina en `;' o `$'.  La
     variable especial `%' y la función `%th' se refieren a resultados
     previos dentro del archivo.  El archivo puede incluir
     construcciones del tipo `:lisp'.  Espacios, tabulaciones y saltos
     de línea en el archivo se ignoran.  Un archivo de entrada válido
     puede crearse con un editor de texto o con la función `stringout'.

     La función `batch' lee las expresiones del archivo <filename>,
     muestra las entradas en la consola, realiza los cálculos
     solicitados y muestra las expresiones de los resultados.  A las
     expresiones de entrada se les asignan etiquetas, así como a las de
     salida. La función `batch' evalúa todas las expresiones de entrada
     del archivo a menos que se produzca un error.  Si se le solicita
     información al usuario (con `asksign' o `askinteger', por ejemplo)
     `batch' se detiene para leer la nueva información para luego
     continuar.

     Es posible detener  `batch' tecleando `control-C' desde la consola.
     El efecto de `control-C' depende del entorno Lisp instalado.

     La función `batch' tiene diversas aplicaciones, tales como servir
     de almacén de líneas de instrucciones, suministrar demostraciones
     libres de errores o ayudar a organizar el trabajo del usuario en
     la resolución de problemas complejos.

     La función `batch' evalúa su argumento.

     Véanse también  `load', `batchload' y `demo'.


 -- Función: batchload (<filename>)
     Lee expresiones de Maxima desde <filename> y las evalúa sin
     mostrar las entradas ni las salidas y sin asignarles etiquetas.
     Sin embargo, las salidas producidas por  `print' o `describe' sí
     se muestran.

     La variable especial `%' y la función `%th' se refieren a
     resultados previos del intérprete interactivo, no a los del propio
     archivo. El archivo no puede incluir construcciones del tipo
     `:lisp'.

     La función `batchload' devuelve la ruta de <filename> en formato
     de cadena.

     La función `batchload' evalúa sus argumentos.

     Véanse también `batch' y `load'.


 -- Función: closefile ()
     La función `closefile' cierra los archivos abiertos por
     `appendfile' o `writefile'.


 -- Función: concat (<arg_1>, <arg_2>, ...)
     Concatena sus argumentos, que deben ser todos átomos.  El valor
     devuelto es un símbolo si el primer argumento es a su vez un
     símbolo, o una cadena en caso contrario.

     La función `concat' evalúa sus argumentos.  El apátrofo  `'' evita
     la evaluación.

          (%i1) y: 7$
          (%i2) z: 88$
          (%i3) concat (y, z/2);
          (%o3)                          744
          (%i4) concat ('y, z/2);
          (%o4)                          y44

     A un símbolo construido por `concat' se le puede asignar un valor
     y ser utilizado posteriormente en expresiones.  La asignación con
     el operador `::' evalúa su expresión izquierda.

          (%i5) a: concat ('y, z/2);
          (%o5)                          y44
          (%i6) a:: 123;
          (%o6)                          123
          (%i7) y44;
          (%o7)                          123
          (%i8) b^a;
                                         y44
          (%o8)                         b
          (%i9) %, numer;
                                         123
          (%o9)                         b

     Nótese que aunque `concat (1, 2)' parezca un número, se trata de
     una cadena.

          (%i10) concat (1, 2) + 3;
          (%o10)                       12 + 3


 -- Función: sconcat (<arg_1>, <arg_2>, ...)
     Concatena sus argumentos para producir una cadena.  Al contrario
     que `concat', sus argumentos no necesitan ser átomos.

     El resultado es una cadena.

          (%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
          (%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3


 -- Función: disp (<expr_1>, <expr_2>, ...)
     Es como `display' pero sólo se muestran los valores de los
     argumentos, no las ecuaciones. Es útil para argumentos complicados
     que no tienen nombre o en situaciones en las que solamente es de
     interés el valor del argumento pero no su nombre.


 -- Función: dispcon (<tensor_1>, <tensor_2>, ...)
 -- Función: dispcon (all)
     Muestra las propiedades contractivas de sus argumentos tal como
     fueron asignadas por `defcon'. La llamada `dispcon (all)' muestra
     todas propiedades contractivas que fueron definidas.


 -- Función: display (<expr_1>, <expr_2>, ...)
     Muestra las ecuaciones cuyos miembros izquierdos son <expr_i> sin
     evaluar y cuyos miembros derechos son los valores de las
     expresiones. Esta función es útil en los bloques y en las
     sentencias `for' para mostrar resultados intermedios.  Los
     argumentos de `display' suelen ser átomos, variables subindicadas
     o llamadas a funciones. Véase también `disp'.

          (%i1) display(B[1,2]);
                                                2
                                   B     = X - X
                                    1, 2
          (%o1)                            done


 -- Variable opcional: display2d
     Valor por defecto: `true'

     Si `display2d' vale `false', la salida por consola es una cadena
     unidimensional, en lugar de una expresión bidimensional.


 -- Variable opcional: display_format_internal
     Valor por defecto: `false'

     Si `display_format_internal' vale `true', las expresiones se
     muestran sin ser transformadas de manera que oculten su
     representación matemática interna. Se representa lo que la función
     `inpart' devolvería, en oposición a `part'.

     Ejemplos:

          User     part       inpart
          a-b;      a - b     a + (- 1) b

                     a            - 1
          a/b;       -         a b
                     b
                                 1/2
          sqrt(x);   sqrt(x)    x

                    4 X        4
          X*4/3;    ---        - X
                     3         3


 -- Función: dispterms (<expr>)
     Muestra <expr> en partes, una debajo de la otra.  Esto es, primero
     se muestra el operador de <expr>, luego cada término si se trata
     de una suma, o cada factor si es un producto, o si no se muestra
     separadamente la parte de una expresión más general. Es útil si
     <expr> es demasiado grande para representarla de otra forma.  Por
     ejemplo, si `P1', `P2', ...  son expresiones muy grandes, entonces
     el programa de representación puede superar el espacio de
     almacenamiento tratando de mostrar `P1 + P2 + ...' todo junto.
     Sin embargo, `dispterms (P1 + P2 + ...)' muestra `P1', debajo
     `P2', etc.  Cuando una expresión exponencial es demasiado ancha
     para ser representada como `A^B', si no se utiliza `dispterms',
     entonces aparecerá como `expt (A, B)' (o como `ncexpt (A, B)', en
     lugar de `A^^B').


 -- Variable opcional: error_size
     Valor por defecto: 10

     La variable `error_size' modifica los mensajes de error de acuerdo
     con el tamaño de las expresiones que aparecen en él. Si el tamaño
     de una expresión (tal como lo determina la función Lisp
     `ERROR-SIZE') es mayor que `error_size', la expresión se reemplaza
     en el mensaje por un símbolo, asignándole a éste una expresión.
     Los símbolos se toman de la lista `error_syms'.

     En caso contrario, si la expresión es menor que `error_size', la
     expresión se muestra en el propio mensaje.

     Véanse también `error' y `error_syms'.

     Ejemplo:

     El tamaño de `U', tal como lo determina `ERROR-SIZE', es 24.

          (%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

          (%i2) error_size: 20$

          (%i3) error ("Example expression is", U);

          Example expression is errexp1
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) errexp1;
                                      E
                                     D
                                    C   + B + A
          (%o4)                    --------------
                                   cos(X - 1) + 1
          (%i5) error_size: 30$

          (%i6) error ("Example expression is", U);

                                   E
                                  D
                                 C   + B + A
          Example expression is --------------
                                cos(X - 1) + 1
           -- an error.  Quitting.  To debug this try debugmode(true);


 -- Variable opcional: error_syms
     Valor por defecto: `[errexp1, errexp2, errexp3]'

     En los mensajes de error, las expresiones mayores que `error_size'
     son reemplazadas por símbolos a los cuales se les asignas estas
     expresiones.  Los símbolos se toman de la lista `error_syms'. La
     primera expresión que resulte ser demasiado larga se reemplaza por
     `error_syms[1]', la segunda por `error_syms[2]' y así
     sucesivamente.

     Si hay más expresiones largas que elementos en `error_syms', los
     símbolos se construyen automáticamente, siendo el <n>-ésimo
     símbolo equivalente a `concat ('errexp, <n>)'.

     Véanse también `error' y `error_size'.


 -- Función: expt (<a>, <b>)
     Si una expresión exponencial es demasiado ancha para ser mostrada
     como `<a>^<b>' aparecerá como `expt (<a>, <b>)' (o como `ncexpt
     (<a>, <b>)' en lugar de `<a>^^<b>').

     Las funciones `expt' y `ncexpt' no se reconocen en una entrada.


 -- Variable opcional: exptdispflag
     Valor por defecto: `true'

     Si `exptdispflag' vale `true', Maxima muestra las expresiones con
     exponentes negativos como cocientes; por ejemplo, `X^(-1)' se
     muestra como `1/X'.


 -- Función: filename_merge (<path>, <filename>)
     Construye una ruta modificada a partir de <path> y <filename>.  Si
     la componente final de <path> es de la forma `###.<something>', la
     componente se reemplaza con `<filename>.<something>'.  En otro
     caso, la componente final se reemplaza simplemente por <filename>.

     El resultado es un objeto Lisp de tipo pathname.

 -- Función: file_search (<filename>)
 -- Función: file_search (<filename>, <pathlist>)
     La función `file_search' busca el archivo <filename> y devuelve su
     ruta como una cadena; si no lo encuentra,  `file_search' devuelve
     `false'. La llamada `file_search (<filename>)' busca en los
     directorios de búsqueda por defecto, que son los especificados por
     las variables `file_search_maxima', `file_search_lisp' y
     `file_search_demo'.

     La función `file_search' analiza primero si el nombre del
     argumento existe antes de hacerlo coincidir con los comodines de
     los patrones de búsqueda de archivos.  Véase `file_search_maxima'
     para más información sobre patrones de búsqueda de archivos.

     El argumento <filename> puede ser una ruta con nombre de archivo,
     o simplemente el nombre del archivo, o, si el directorio de
     búsqueda de archivo incluye un patrón de búsqueda, es suficiente
     con el nombre de archivo sin extensión.  Por ejemplo,

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     todos buscan el mismo archivo, dando por hecho que el archivo
     existe y que `/home/wfs/special/###.mac' está en
     `file_search_maxima'.

     La llamada `file_search (<filename>, <pathlist>)' busca solamente
     en los directorios especificados por <pathlist>, que es una lista
     de cadenas.  El argumento <pathlist> ignora los directorios de
     búsqueda por defecto, de manera que si se da la lista de rutas,
     `file_search' busca solamente en ellas y no en los directorios por
     defecto.  Incluso si hay un único directorio en <pathlist>, debe
     ser suministrado como una lista de un único elemento.

     El usuario puede modificar los directorios de búsqueda por
     defecto; véase para ello See `file_search_maxima'.

     La función `file_search' es llamada por `load' con los directorios
     de búsqueda `file_search_maxima' y `file_search_lisp'.


 -- Variable opcional: file_search_maxima
 -- Variable opcional: file_search_lisp
 -- Variable opcional: file_search_demo
     Estas variables especifican listas de directorios en los que deben
     buscar la funciones  `load', `demo' y algunas otras. Los valores
     por defecto de estas variables nombran directorios de la
     instalación de Maxima.

     El usuario puede modificar estas variables, bien reemplazando los
     valores por defecto, bien añadiendo nuevos directorios.  Por
     ejemplo,

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     reemplaza el valor por defecto de `file_search_maxima', mintras que

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     añade dos directorios más. Puede ser conveniente colocar una
     expresión como esta en el archivo `maxima-init.mac', de manera que
     la ruta de búsqueda de ficheros se asigne automáticamente cada vez
     que arranca Maxima.

     Se pueden especificar varias extensiones de archivos y rutas con
     comodines especiales.  La cadena `###' representa el nombre del
     archivo buscado y una lista separada de comas y encerrada entre
     llaves,  `{foo,bar,baz}' representa múltiples cadenas.  Por
     ejemplo, suponiendo que se busca el nombre `neumann',

          "/home/{wfs,gcj}/###.{lisp,mac}"

     se interpreta como `/home/wfs/neumann.lisp',
     `/home/gcj/neumann.lisp', `/home/wfs/neumann.mac' y
     `/home/gcj/neumann.mac'.


 -- Función: file_type (<filename>)
     Devuelve una descripción del contenido de <filename> basada en la
     extensión, sin intentar abrir el archivo para inspeccionar su
     contenido.

     El valor que la función retorna puede ser cualquiera de los
     siguientes: `object', `lisp' o `maxima'.  Si la extensión comienza
     por `m' o `d', `file_type' devuelve `maxima'.  Si la extensión
     comienza por `l', `file_type' devuelve `lisp'.  En cualquier otro
     caso, `file_type' devuelve `object'.


 -- Función: grind (<expr>)
 -- Variable opcional: grind
     La función `grind' imprime <expr> en la consola en un formato
     admisible como entrada para Maxima. La función `grind' devuelve
     siempre `done'.

     Cuando <expr> es el nombre de una función o macro, `grind' muestra
     la definición de la función o de la macro en lugar de sólo su
     nombre.

     Véase también `string', que devuelve una cadena en lugar de
     imprimir la salida. La función `grind' intenta imprimir la
     expresión de forma que sea lago más sencilla de leer que la salida
     de `string'.

     Cuando la variable `grind' vale `true', la salida de `string' y
     `stringout' tienen el mismo formato que la de `grind'; en caso
     contrario no se formatea la salida de esas funciones.  El valor
     por defecto de la variable `grind' es `false'.

     La variable `grind' también se puede utilizar como  argumento en
     `playback'.  Si `grind' está presente, `playback' imprime las
     expresiones de entrada en el mismo formato que lo hace la función
     `grind'; en caso contrario no se formatean la expresiones de
     entrada.

     La función `grind' evalúa sus argumentos.

     Ejemplos:

          (%i1) aa + 1729;
          (%o1)                       aa + 1729
          (%i2) grind (%);
          aa+1729$
          (%o2)                         done
          (%i3) [aa, 1729, aa + 1729];
          (%o3)                 [aa, 1729, aa + 1729]
          (%i4) grind (%);
          [aa,1729,aa+1729]$
          (%o4)                         done
          (%i5) matrix ([aa, 17], [29, bb]);
                                     [ aa  17 ]
          (%o5)                      [        ]
                                     [ 29  bb ]
          (%i6) grind (%);
          matrix([aa,17],[29,bb])$
          (%o6)                         done
          (%i7) set (aa, 17, 29, bb);
          (%o7)                   {17, 29, aa, bb}
          (%i8) grind (%);
          {17,29,aa,bb}$
          (%o8)                         done
          (%i9) exp (aa / (bb + 17)^29);
                                          aa
                                      -----------
                                               29
                                      (bb + 17)
          (%o9)                     %e
          (%i10) grind (%);
          %e^(aa/(bb+17)^29)$
          (%o10)                        done
          (%i11) expr: expand ((aa + bb)^10);
                   10           9        2   8         3   7         4   6
          (%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
                   5   5         6   4         7   3        8   2
           + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
                  9        10
           + 10 aa  bb + aa
          (%i12) grind (expr);
          bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
               +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
               +10*aa^9*bb+aa^10$
          (%o12)                        done
          (%i13) string (expr);
          (%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
          +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
          bb+aa^10
          (%i14) cholesky (A):= block ([n : length (A), L : copymatrix (A),
            p : makelist (0, i, 1, length (A))], for i thru n do
            for j : i thru n do
            (x : L[i, j], x : x - sum (L[j, k] * L[i, k], k, 1, i - 1),
            if i = j then p[i] : 1 / sqrt(x) else L[j, i] : x * p[i]),
            for i thru n do L[i, i] : 1 / p[i],
            for i thru n do for j : i + 1 thru n do L[i, j] : 0, L)$
          (%i15) grind (cholesky);
          cholesky(A):=block(
                   [n:length(A),L:copymatrix(A),
                    p:makelist(0,i,1,length(A))],
                   for i thru n do
                       (for j from i thru n do
                            (x:L[i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),
                             if i = j then p[i]:1/sqrt(x)
                                 else L[j,i]:x*p[i])),
                   for i thru n do L[i,i]:1/p[i],
                   for i thru n do (for j from i+1 thru n do L[i,j]:0),L)$
          (%o15)                        done
          (%i16) string (fundef (cholesky));
          (%o16) cholesky(A):=block([n:length(A),L:copymatrix(A),p:makelis\
          t(0,i,1,length(A))],for i thru n do (for j from i thru n do (x:L\
          [i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),if i = j then p[i]:1/sqrt(x\
          ) else L[j,i]:x*p[i])),for i thru n do L[i,i]:1/p[i],for i thru \
          n do (for j from i+1 thru n do L[i,j]:0),L)

 -- Variable opcional: ibase
     Valor por defecto: 10

     `ibase' es la base en la que Maxima lee valores enteros.

     A `ibase' se le puede asignar cualquier entero entre 2 y 36 (base
     decimal), ambos inclusive.  Si `ibase' es mayor que 10, las cifras
     a utilizar serán los dígitos de 0 a 9, junto con las letras del
     alfabeto A, B, C, ..., tantas como sean necesarias para completar
     la base `ibase'.  Las letras se interpretarán como cifras sólo
     cuando el primer dígito sea un valor entre 9.  Es indiferente
     hacer uso de letras mayúsculas o minúsculas.  Las cifras para la
     base 36, la mayor posible, son los dígitos numéricos de 0 a 9 y
     las letras desde la A hasta la Z.

     Cualquiera que sea el valor de `ibase', si un entero termina con
     un punto decimal, se interpretará en base 10.

     Véase también `obase'.

     Ejemplos:

     `ibase' menor que 10.

          (%i1) ibase : 2 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1111111111111111;
          (%o3)                         65535

     `ibase' mayor que 10.  Las letras se interpretan como dígitos sólo
     si el primer dígito es una cifra entre 0 y 9.

          (%i1) ibase : 16 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1000;
          (%o3)                         4096
          (%i4) abcd;
          (%o4)                         abcd
          (%i5) symbolp (abcd);
          (%o5)                         true
          (%i6) 0abcd;
          (%o6)                         43981
          (%i7) symbolp (0abcd);
          (%o7)                         false

     Independientemente del valor de `ibase', si el entero termina con
     un punto decimal, se interpretará en base diez.

          (%i1) ibase : 36 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1234;
          (%o3)                         49360
          (%i4) 1234.;
          (%o4)                         1234

 -- Variable opcional: inchar
     Valor por defecto: `%i'

     La variable `inchar' es el prefijo de las etiquetas de las
     expresiones introducidas por el usuario. Maxima crea
     automáticamente una etiqueta para cada expresión de entrada
     concatenando `inchar' y `linenum'.

     A `inchar' se le puede asignar cualquier símbolo o cadena, no
     necesariamente un caracácter sencillo. Puesto que internamente
     Maxima solo tiene en cuenta el primer carácter del prefijo, los
     prefijos `inchar', `outchar' y `linechar' deben comenzar con
     caracteres diferentes; en caso contrario, sentencias como
     `kill(inlables)' pueden dar resultados inesperados.

          (%i1) inchar: "input";
          (%o1)                                input
          (input1) expand ((a+b)^3);
                                      3        2      2      3
          (%o1)                      b  + 3 a b  + 3 a  b + a
          (input2)

     Véase también `labels'.


 -- Función: ldisp (<expr_1>, ..., <expr_n>)
     Muestra las expresiones <expr_1>, ..., <expr_n> en la consola con
     el formato de salida; `ldisp' asigna una etiqueta a cada argumento
     y devuelve la lista de etiquetas.

     Véase también `disp'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisp (e, f);
                                             3
          (%t3)                       (b + a)

                               3        2      2      3
          (%t4)               b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                             3
          (%o4)                       (b + a)
          (%i5) %t4;
                               3        2      2      3
          (%o5)               b  + 3 a b  + 3 a  b + a


 -- Función: ldisplay (<expr_1>, ..., <expr_n>)
     Muestra las expresiones <expr_1>, ..., <expr_n> en la consola con
     el formato de salida.  Cad expresión se muestra como una ecuación
     de la forma `lhs = rhs' en la que `lhs' es uno de los argumentos
     de `ldisplay' y `rhs' su valor. Normalmente, cada argumento será
     el nombre de una variable. La función `ldisp' asigna una etiqueta
     a cada ecuación y devuelve la lista de etiquetas.

     Véase también `display'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisplay (e, f);
                                               3
          (%t3)                     e = (b + a)

                                 3        2      2      3
          (%t4)             f = b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                               3
          (%o4)                     e = (b + a)
          (%i5) %t4;
                                 3        2      2      3
          (%o5)             f = b  + 3 a b  + 3 a  b + a


 -- Variable opcional: linechar
     Valor por defecto: `%t'

     La variable `linechar' es el prefijo de las etiquetas que genera
     Maxima para expresiones intermedias. Cuando sea necesario, Maxima
     creará una etiqueta para cada expresión intermedia concatenando
     `linechar' y `linenum'.

     A `linechar' se le puede asignar cualquier símbolo o cadena, no
     necesariamente un caracácter sencillo. Puesto que internamente
     Maxima solo tiene en cuenta el primer carácter del prefijo, los
     prefijos `inchar', `outchar' y `linechar' deben comenzar con
     caracteres diferentes; en caso contrario, sentencias como
     `kill(inlables)' pueden dar resultados inesperados.

     Las expresiones intermedias pueden ser mostradas o no.  Véanse
     también `programmode' y `labels'.


 -- Variable opcional: linel
     Valor por defecto: 79

     La variable `linel' es la anchura (medida en número de caracteres)
     de la consola que se le da a Maxima para que muestre las
     expresiones. A `linel' se le puede asignar cualquier valor, pero
     si éste es muy pequeño o grande resultará de poca utilidad. El
     texto que impriman las funciones internas de Maxima, como los
     mensajes de error y las salidas de la función `describe', no se ve
     afectado por el valor de `linel'.


 -- Variable opcional: lispdisp
     Valor por defecto: `false'

     Si `lispdisp' vale `true', los símbolos de Lisp se muestran
     precedidos del carácter de interrogación `?'. En caso contrario,
     los símbolos de Lisp se muestran sin esta marca.

     Ejemplos:

          (%i1) lispdisp: false$
          (%i2) ?foo + ?bar;
          (%o2)                       foo + bar
          (%i3) lispdisp: true$
          (%i4) ?foo + ?bar;
          (%o4)                      ?foo + ?bar


 -- Función: load (<filename>)
     Evalúa las expresiones del archivo <filename>, trayendo variables,
     funciones y otros objetos a Maxima.  Una asignación hecha
     previamente a una variable en Maxima será destruida por otra
     asignación que se le haga en <filename>. Para encontrar el
     fichero, `load' llama a `file_search' con `file_search_maxima' y
     `file_search_lisp' como directorios de búsqueda. Si la llamada a
     `load' funciona correctamente, devuelve el nombre del fichero; en
     caso contrario, `load' muestra un mensaje de error.

     La función `load' trabaja indistintamente con código Lisp y Maxima.
     Los ficheros creados con `save', `translate_file' y
     `compile_file', que crea código Lisp, y `stringout', que crea
     código Maxima, todos ellos pueden ser procesados por `load'. La
     función `load' llama a `loadfile' para cargar archivos en Lisp y a
     `batchload' para cargar archivos en Maxima.

     La función `load' no reconoce las construcciones de tipo `:lisp' en
     ficheros de Maxima. Además, mientras se está procesando <filename>,
     las variables globales `_', `__', `%' y `%th' mantienen los
     valores que tenían cuando se realizó la llamada a `load'.

     Véanse también `loadfile', `batch', `batchload' y `demo';
     `loadfile' procesa archivos en Lisp; `batch', `batchload' y `demo'
     procesan archivos en Maxima.

     Véase `file_search' para más detalles sobre el mecanismo de
     búsqueda de archivos.

     La función `load' evalúa sus argumentos.


 -- Función: loadfile (<filename>)
     Evalúa las expresiones Lisp del archivo <filename>. La función
     `loadfile' no llama a `file_search', de manera que `filename' debe
     incluir la extensión del archivo y su ruta completa.

     La función `loadfile' puede procesar ficheros creados por  `save',
     `translate_file' y `compile_file'.  Puede ser más conveniente
     utilizar `load' en lugar de `loadfile'.


 -- Variable opcional: loadprint
     Valor por defecto: `true'

     La variable `loadprint' indica si mostrar un mensaje cuando se
     carga un archivo.

        * Si `loadprint' vale `true', se muestra siempre un mensaje.

        * Si `loadprint' vale `'loadfile', muestra un mensaje sólo si
          el archivo es cargado con la función `loadfile'.

        * Si `loadprint' vale `'autoload', muestra un mensaje sólo
          cuandi un archivo se carga automáticamente. Véase
          `setup_autoload'.

        * Si `loadprint' vale `false', nunca mostrará mensajes.


 -- Variable opcional: obase
     Valor por defecto: 10

     `obase' es la base en la que Maxima imprime los números enteros.

     A `obase' se le puede asignar cualquier entero entre 2 y 36 (base
     decimal), ambos inclusive.  Si `obase' es mayor que 10, las cifras
     a utilizar serán los dígitos de 0 a 9, junto con las letras del
     alfabeto A, B, C, ..., tantas como sean necesarias para completar
     la base `obase'.  Si el primer dígito resulta ser una letra, se le
     añadirá el cero como prefijo.  Las cifras para la base 36, la
     mayor posible, son los dígitos numéricos de 0 a 9 y las letras
     desde la A hasta la Z.

     Véase también `ibase'.

     Ejemplos:

          (%i1) obase : 2;
          (%o1)                          10
          (%i2) 2^8 - 1;
          (%o10)                      11111111
          (%i3) obase : 8;
          (%o3)                          10
          (%i4) 8^8 - 1;
          (%o4)                       77777777
          (%i5) obase : 16;
          (%o5)                          10
          (%i6) 16^8 - 1;
          (%o6)                       0FFFFFFFF
          (%i7) obase : 36;
          (%o7)                          10
          (%i8) 36^8 - 1;
          (%o8)                       0ZZZZZZZZ

 -- Variable opcional: outchar
     Valor por defecto: `%o'

     La variable `outchar' es el prefijo de las etiquetas de las
     expresiones calculadas por Maxima. Maxima crea automáticamente una
     etiqueta para cada expresión calculada concatenando `outchar' y
     `linenum'.

     A `outchar' se le puede asignar cualquier símbolo o cadena, no
     necesariamente un caracácter sencillo. Puesto que internamente
     Maxima solo tiene en cuenta el primer carácter del prefijo, los
     prefijos `inchar', `outchar' y `linechar' deben comenzar con
     caracteres diferentes; en caso contrario, sentencias como
     `kill(inlables)' pueden dar resultados inesperados.

          (%i1) outchar: "output";
          (output1)                           output
          (%i2) expand ((a+b)^3);
                                      3        2      2      3
          (output2)                  b  + 3 a b  + 3 a  b + a
          (%i3)

     Véase también `labels'.


 -- Variable opcional: packagefile
     Valor por defecto: `false'

     Los desarrolladores de paquetes que utilizan  `save' o `translate'
     para crear paquetes (ficheros) que van a ser utilizados por
     terceros pueden hacer `packagefile: true' para evitar que se añada
     información a la listas de información de Maxima (por ejemplo,
     `values', `functions') excepto allí donde sea necesario cuando el
     archivo sea cargado en memoria.


 -- Variable opcional: pfeformat
     Valor por defecto: `false'

     Si `pfeformat' vale `true', una fracción de enteros será mostrada
     con el carácter de barra inclinada `/' entre ellos.

          (%i1) pfeformat: false$
          (%i2) 2^16/7^3;
                                        65536
          (%o2)                         -----
                                         343
          (%i3) (a+b)/8;
                                        b + a
          (%o3)                         -----
                                          8
          (%i4) pfeformat: true$
          (%i5) 2^16/7^3;
          (%o5)                       65536/343
          (%i6) (a+b)/8;
          (%o6)                      1/8 (b + a)


 -- Función: print (<expr_1>, ..., <expr_n>)
     Evalúa y muestra las expresiones  <expr_1>, ..., <expr_n>
     secuencialmente de izquierda a derecha, comenzando la impresión
     por el borde izquierdo de la consola.

     El valor devuelto por `print' es el valor de su último argumento.
     La función `print' no genera etiquetas para las expresiones
     intermedias.

     Véanse también `display', `disp', `ldisplay' y `ldisp', que
     muestran una expresión por línea, mientras que `print' trata de
     mostrar dos o más expresiones por línea.

     Para mostrar el contenido de un archivo véase `printfile'.

          (%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
                radcan (log (a^10/b)))$
                      3        2      2      3
          (a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is

                                                        10 log(a) - log(b)
          (%i2) r;
          (%o2)                  10 log(a) - log(b)
          (%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
                radcan (log (a^10/b)))$
                                     (a+b)^3 is

                               3        2      2      3
                              b  + 3 a b  + 3 a  b + a

                                   log (a^10/b) is

                                 10 log(a) - log(b)


 -- Función: printfile (<path>)
     Envía el fichero al que hace referncia la ruta <path> a la
     consola. <path> puede ser una cadena o un símbolo, en cuyo caso se
     convertirá en una cadena.

     Si <path> hace referencia a un fichero accesible desde el
     directorio actual de trabajo, entonces se enviará a la consola; en
     caso contrario, `printfile' intentará localizar el fichero
     añadiéndole <path> a cada uno de los elementos de
     `file_search_usage' a través de `filename_merge'.

     `printfile' devuelve la ruta del fichero encontado.


 -- Función: read (<expr_1>, ..., <expr_n>)
     Imprime <expr_1>, ..., <expr_n> y a continuación lee una expresión
     desde la consola y devuelve la expresión evaluada. La expresión
     termina con un punto y coma `;' o con el símbolo de dólar `$'.

     Véase también `readonly'.

          (%i1) foo: 42$
          (%i2) foo: read ("foo vale", foo, " -- nuevo valor.")$
          foo vale 42  -- nuevo valor.
          (a+b)^3;
          (%i3) foo;
                                               3
          (%o3)                         (b + a)


 -- Función: readonly (<expr_1>, ..., <expr_n>)
     Imprime <expr_1>, ..., <expr_n> y a continuación lee una expresión
     desde la consola y devuelve la expresión sin evaluar. La expresión
     termina con un punto y coma `;' o con el símbolo de dólar `$'.

          (%i1) aa: 7$
          (%i2) foo: readonly ("Introducir expresion:");
          Introducir expresion:
          2^aa;
                                            aa
          (%o2)                            2
          (%i3) foo: read ("Introducir expresion:");
          Introducir expresion:
          2^aa;
          (%o3)                            128

     Véase también `read'.


 -- Función: reveal (<expr>, <nivel>)
     Reemplaza partes de <expr> al <nivel> especificado y las sutituye
     por descripciones cortas.

        * Las sumas y restas se reemplazan por `Sum(<n>)', siendo <n>
          el número de términos de la suma.

        * Los productos se reemplazan por `Product(<n>)', siendo <n> el
          número de factores del producto.

        * Las potencias se reemplazan por `Expt'.

        * Los cocientes se reemplazan por `Quotient'.

        * El símbolo negativo se reemplaza por `Negterm'.

     Si el entero  <depth> es mayor o igual que la profundidad máxima
     de <expr>, `reveal (<expr>, <depth>)' devuelve <expr> sin
     modificar.

     La función `reveal' evalúa sus argumentos y devuelve la expresión
     con las modificaciones solicitadas.

     Ejemplo:

          (%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                                    2            2
                                   b  - 2 a b + a
          (%o1)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e
          (%i2) reveal (e, 1);
          (%o2)                       Quotient
          (%i3) reveal (e, 2);
                                       Sum(3)
          (%o3)                        ------
                                       Sum(3)
          (%i4) reveal (e, 3);
                               Expt + Negterm + Expt
          (%o4)               ------------------------
                              Product(2) + Expt + Expt
          (%i5) reveal (e, 4);
                                 2                 2
                                b  - Product(3) + a
          (%o5)         ------------------------------------
                                   Product(2)     Product(2)
                        2 Expt + %e           + %e
          (%i6) reveal (e, 5);
                                   2            2
                                  b  - 2 a b + a
          (%o6)              --------------------------
                                 Sum(2)     2 b     2 a
                             2 %e       + %e    + %e
          (%i7) reveal (e, 6);
                                    2            2
                                   b  - 2 a b + a
          (%o7)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e


 -- Variable opcional: rmxchar
     Valor por defecto: `]'

     La variable `rmxchar' es el carácter que se dibuja al lado derecho
     de una matriz.

     Véase también `lmxchar'.


 -- Función: save (<filename>, <name_1>, <name_2>, <name_3>, ...)
 -- Función: save (<filename>, values, functions, labels, ...)
 -- Función: save (<filename>, [<m>, <n>])
 -- Función: save (<filename>, <name_1>=<expr_1>, ...)
 -- Función: save (<filename>, all)
 -- Función: save (<filename>, <name_1>=<expr_1>, <name_2>=<expr_2>,
          ...)
     Alamacena los valores actuales de <name_1>, <name_2>, <name_3>,
     ..., en el archivo <filename>.  Los argumentos son nombres de
     variables, funciones u otros objetos.  Si un nombre no tiene un
     valor o una función asociado a él, entonces se ignora.

     La función `save' devuelve <filename>.

     La función `save' almacena datos en forma de expresiones Lisp.
     Los datos almacenados por `save' pueden recuperarse con `load
     (<filename>)'.  El resultado de ejecutar  `save' cuando <filename>
     ya existe depende del soporte Lisp implementado; el archivo puede
     ser sobreescrito o que `save' envíe un mesaje de error.

     La llamada `save (<filename>, values, functions, labels, ...)'
     almacena los elementos cuyos nombres son `values', `functions',
     `labels', etc.  Los nombres pueden ser cualesquiera de los
     especificados por la variable `infolists'; `values' incluye todas
     las variables definidas por el usuario.

     La llamada `save (<filename>, [<m>, <n>])' almacena los valores de
     las etiquetas de entrada y salida desde <m> hasta <n>.  Nótese que
     <m> y <n> deben ser números.  Las etiquetas de entrada y salida
     también se pueden almacenar una a una, por ejemplo, `save
     ("foo.1", %i42, %o42)'.  La llamada `save (<filename>, labels)'
     almacena todas las etiquetas de entrada y salida.  Cuando las
     etiquetas almacenadas en el archivo sean posteriormente
     recuperadas, se sobreescribirán las activas en ese momento.

     La llamada `save (<filename>, <name_1>=<expr_1>,
     <name_2>=<expr_2>, ...)' almacena los valores de <expr_1>,
     <expr_2>, ..., con los nombres <name_1>, <name_2>, ....  Es útil
     hacer este tipo de llamada para con etiquetas de entrada y salida,
     por ejemplo, `save ("foo.1", aa=%o88)'.  El miembro derecho de la
     igualdad puede ser cualquier expresión, que será evaluada.  Esta
     llamada a la función `save' no incorpora nuevos nombres a la
     sesión actual de Maxima, simplemente los almacena en el archivo
     <filename>.

     Todas estas formas de llamar a la función `save' se pueden
     combinar a voluntad.  Por ejemplo, `save (<filename>, aa, bb,
     cc=42, functions, [11, 17])'.

     La llamada `save (<filename>, all)' almacena el estado actual de
     Maxima, lo que incluye todas las variables definidas por el
     usuario, funciones, arreglos, etc., así como algunos objetos
     definidos automáticamente.  Los elementos almacenados incluyen
     variables del sistema, como `file_search_maxima' o `showtime', si
     han sido modificadas por el usuario. Véase `myoptions'.

     `save' evalúa <filename> pero no el resto de argumentos.

 -- Variable opcional: savedef
     Valor por defecto: `true'

     Si `savedef' vale `true', se mantiene la versión Maxima de una
     función definida por el usuario cuando ésta se traduce, lo que
     permite mostrar su código con `dispfun' y que la función pueda ser
     editada.

     Si `savedef' vale `false', los nombres de las funciones traducidas
     se eliminan de la lista `functions'.


 -- Función: show (<expr>)
     Muestra `expr' con sus objetos indexados que tengan índices
     covariantes como subíndices y los contravariantes como
     superíndices.  Los índices derivados se muestran como subíndices,
     separados por una coma de los covariantes.


 -- Función: showratvars (<expr>)
     Devuelve una lista de las variables de expresiones canónicas
     racionales (CRE) en la expresión `expr'.

     Véase también `ratvars'.


 -- Variable opcional: stardisp
     Valor por defecto: `false'

     Si `stardisp' vale `true', la multiplicación se muestra con un
     asterisco `*' entre los operandos.


 -- Función: string (<expr>)
     Convierte `expr' a la notación lineal de Maxima, tal como si fuese
     tecleada.

     El valor que retorna la función `string' es una cadena, por lo que
     no puede ser utilizada en los cálculos.


 -- Variable opcional: stringdisp
     Valor por defecto: `false'

     Si `stringdisp' vale `true', las cadenas alfanuméricas se muestran
     encerradas entre comillas dobles. En caso contrario, no se
     nuestran las comillas.

     La variable `stringdisp' vale siempre `true' cuando se muestra la
     definición de una función.

     Ejemplos:

          (%i1) stringdisp: false$
          (%i2) "This is an example string.";
          (%o2)              This is an example string.
          (%i3) foo () :=
                print ("This is a string in a function definition.");
          (%o3) foo() :=
                        print("This is a string in a function definition.")
          (%i4) stringdisp: true$
          (%i5) "This is an example string.";
          (%o5)             "This is an example string."


 -- Función: stringout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Función: stringout (<filename>, [<m>, <n>])
 -- Función: stringout (<filename>, input)
 -- Función: stringout (<filename>, functions)
 -- Función: stringout (<filename>, values)
     La función `stringout' escribe expresiones en un archivo de la
     misma forma en que se escribirían como expresiones de entrada. El
     archivo puede ser utilizado entonces como entrada a las funciones
     `batch' o `demo', y puede ser editado para cualquier otro
     propósito.

     La forma general de `stringout' escribe los valores de una o más
     expresiones en el archivo de salida. Nótese que si una expresión
     es una variable, solamente se escribirá el valor de la variable y
     no el nombre de ésta. Como caso especial, y muy útil en algunas
     ocasiones, las expresiones pueden ser etiquetas de entrada (`%i1',
     `%i2', `%i3', ...) o de salida (`%o1', `%o2', `%o3', ...).

     Si `grind' vale `true', `stringout' formatea la salida utilizando
     `grind'. En caso contrario, se utilizará el formato `string'.
     Véanse `grind' y `string'.

     La forma especial `stringout (<filename>, [<m>, <n>])' escribe los
     valores de las etiquetas de entrada desde la m hasta la n, ambas
     inclusive.

     La forma especial `stringout (<filename>, input)' escribe todas
     las etiquetas de entrada en el archivo.

     La forma especial `stringout (<filename>, functions)' escribe
     todas las funciones definidas por el usuario, contenidas en la
     lista global `functions', en el archivo.

     La forma especial `stringout (<filename>, values)' escribe todas
     las variables asignadas por el usuario, contenidas en la lista
     global `values', en el archivo. Cada variable se escribe como una
     sentencia de asignación, con el nombre de la variable seguida de
     dos puntos y a continuación su valor. Nótese que la forma general
     de `stringout' no escribe las variables como sentencias de
     asignación.


 -- Función: tex (<expr>)
 -- Función: tex (<expr>, <destination>)
 -- Función: tex (<expr>, false)
 -- Función: tex (<label>)
 -- Función: tex (<label>, <destination>)
 -- Función: tex (<label>, false)
     Devuelve la expresión en un formato apropiado para para ser
     incorporado a un documento basado en TeX.  El resultado que se
     obtiene es un fragmento de código que puede incluirse en un
     documento mayor, pero que no puede ser procesado aisladamente.

     La instrucción `tex (<expr>)' imprime en la consola la
     representación en TeX de <expr>.

     La instrucción `tex (<label>)' imprime en la consola la
     representación en TeX de la expresión a la que hace referencia la
     etiqueta <label>, asignándole a su vez una etiqueta de ecuación
     que será mostrada al lado izquierdo de la misma. La etiqueta de la
     expresión en TeX es la misma que la de Maxima.

     <destination> puede ser tanto un flujo de salida como el nombre de
     un fichero.

     Si <destination> es el nombre de un fichero, `tex' añade la salida
     al fichero.  Las funciones `openw' y `opena' crean flujos de
     salida.

     Las instrucciones `tex (<expr>, false)' y `tex (<label>, false)'
     devuelven el código TeX en formato de cadena.

     La función `tex' evalúa su primer argumento tras comprobar si se
     trata de una etiqueta. La doble comilla simple `''' fuerza la
     evaluación del argumento, anulando la comprobación sobre la
     etiqueta.

     Véase también `texput'.

     Ejemplos:

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)

     `tex (<expr>, false)' devuelve el código TeX en formato de cadena.

          (%i1) S : tex (x * y * z, false);
          (%o1) $$x\,y\,z$$
          (%i2) S;
          (%o2) $$x\,y\,z$$

 -- Función: tex1 (<e>)
     Devuelve una cadena con el código TeX de la expresión <e>.  El
     código TeX no se encierra entre delimitadores para una ecuación ni
     cualesquiera otros entornos.

     Ejemplo:

          (%i1) tex1 (sin(x) + cos(x));
          (%o1)                     \sin x+\cos x

 -- Función: texput (<a>, <s>)
 -- Función: texput (<a>, <f>)
 -- Función: texput (<a>, <s>, <operator_type>)
 -- Función: texput (<a>, [<s_1>, <s_2>], matchfix)
 -- Función: texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)
     Establece el formato en TeX del átomo <a>, el cual puede ser un
     símbolo o el nombre de un operador.

     La instrucción `texput (<a>, <s>)' hace que la función `tex'
     introduzca <s> en la salida TeX en el lugar de <a>.

     La instrucción `texput (<a>, <f>)' hace que `tex' llame a la
     función <f> para que genere código TeX. La función <f> debe
     aceptar un único argumento, el cual es una expresión que tenga como
     operador <a> y que devuelva una cadena con el código TeX. Esta
     función puede llamar a `tex1' para generar el código TeX para los
     argumentos de la expresión de entrada.

     La instrucción `texput (<a>, <s>, <operator_type>)', en la que
     <operator_type> es `prefix', `infix' o `postfix', `nary' o
     `nofix',hace que la función `tex' introduzca <s> en la salida TeX
     en el lugar de <a>, colocándolo en el lugar correcto.

     La instrucción `texput (<a>, [<s_1>, <s_2>], matchfix)' hace que
     la función `tex' introduzca <s_1> y <s_2> en la salida TeX a los
     lados de los argumentos de <a>. Si son más de uno, los argumentos
     se separan por comas.

     La instrucción `texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)'
     hace que la función `tex' introduzca <s_1> y <s_2> en la salida
     TeX a los lados de los argumentos de <a>, con <s_3> separando los
     argumentos.

     Ejemplos:

     Asigna código TeX para una variable.

     Llama a una función que genera código TeX.

          (%i1) texfoo (e) := block ([a, b], [a, b] : args (e),
            concat ("\\left[\\stackrel{", tex1 (b),
                    "}{", tex1 (a), "}\\right]"))$
          (%i2) texput (foo, texfoo);
          (%o2)                        texfoo
          (%i3) tex (foo (2^x, %pi));
          $$\left[\stackrel{\pi}{2^{x}}\right]$$
          (%o3)                         false

          (%i1) texput (me,"\\mu_e");
          (%o1)                         \mu_e
          (%i2) tex (me);
          $$\mu_e$$
          (%o2)                         false

     Asigna código TeX para una función ordinaria (no para un operador).

          (%i1) texput (lcm, "\\mathrm{lcm}");
          (%o1)                     \mathrm{lcm}
          (%i2) tex (lcm (a, b));
          $$\mathrm{lcm}\left(a , b\right)$$
          (%o2)                         false

     Asigna código TeX para un operador prefijo.

          (%i1) prefix ("grad");
          (%o1)                         grad
          (%i2) texput ("grad", " \\nabla ", prefix);
          (%o2)                        \nabla
          (%i3) tex (grad f);
          $$ \nabla f$$
          (%o3)                         false

     Asigna código TeX para un operador infijo.

          (%i1) infix ("~");
          (%o1)                           ~
          (%i2) texput ("~", " \\times ", infix);
          (%o2)                        \times
          (%i3) tex (a ~ b);
          $$a \times b$$
          (%o3)                         false

     Asigna código TeX para un operador postfijo..

          (%i1) postfix ("##");
          (%o1)                          ##
          (%i2) texput ("##", "!!", postfix);
          (%o2)                          !!
          (%i3) tex (x ##);
          $$x!!$$
          (%o3)                         false

     Asigna código TeX para un operador n-ario.

          (%i1) nary ("@@");
          (%o1)                          @@
          (%i2) texput ("@@", " \\circ ", nary);
          (%o2)                         \circ
          (%i3) tex (a @@ b @@ c @@ d);
          $$a \circ b \circ c \circ d$$
          (%o3)                         false

     Asigna código TeX para un operador "no-fijo".

          (%i1) nofix ("foo");
          (%o1)                          foo
          (%i2) texput ("foo", "\\mathsc{foo}", nofix);
          (%o2)                     \mathsc{foo}
          (%i3) tex (foo);
          $$\mathsc{foo}$$
          (%o3)                         false

     Asigna código TeX para un operador "bi-fijo" (matchfix).

          (%i1) matchfix ("<<", ">>");
          (%o1)                          <<
          (%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
          (%o2)                [ \langle ,  \rangle ]
          (%i3) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o3)                         false
          (%i4) tex (<<a, b>>);
          $$ \langle a , b \rangle $$
          (%o4)                         false
          (%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"],
                matchfix);
          (%o5)           [ \langle ,  \rangle ,  \, | \,]
          (%i6) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o6)                         false
          (%i7) tex (<<a, b>>);
          $$ \langle a \, | \,b \rangle $$
          (%o7)                         false


 -- Función: get_tex_environment (<op>)
 -- Función: set_tex_environment (<op>, <before>, <after>)
     Gestiona el entorno de las salidas TeX que se obtienen de la
     función `tex'.  El entorno TeX está formado por dos cadenas: una
     que se escribe antes que cualquier salida en TeX, y otra que se
     escribe después.

     `get_tex_environment' devuelve el entorno TeX que se aplica al
     operador <op>.  Si no se ha asignado ningún entorno, devolverá el
     que tenga por defecto.

     `set_tex_environment' asigna el entorno TeX al operador <op>.

     Ejemplos:

          (%i1) get_tex_environment (":=");
          (%o1) [
          \begin{verbatim}
          , ;
          \end{verbatim}
          ]
          (%i2) tex (f (x) := 1 - x);

          \begin{verbatim}
          f(x):=1-x;
          \end{verbatim}

          (%o2)                         false
          (%i3) set_tex_environment (":=", "$$", "$$");
          (%o3)                       [$$, $$]
          (%i4) tex (f (x) := 1 - x);
          $$f(x):=1-x$$
          (%o4)                         false

 -- Función: get_tex_environment_default ()
 -- Función: set_tex_environment_default (<before>, <after>)
     Gestiona el entorno de las salidas TeX que se obtienen de la
     función `tex'.  El entorno TeX está formado por dos cadenas: una
     que se escribe antes que cualquier salida en TeX, y otra que se
     escribe después.

     `get_tex_environment_default' devuelve el entorno TeX que se aplica
     a expresiones para las cuales el operador de mayor rango no tiene
     entorno TeX asignado (mediante `set_tex_environment').

     `set_tex_environment_default' asigna el entorno TeX por defecto.

     Ejemplos:

          (%i1) get_tex_environment_default ();
          (%o1)                       [$$, $$]
          (%i2) tex (f(x) + g(x));
          $$g\left(x\right)+f\left(x\right)$$
          (%o2)                         false
          (%i3) set_tex_environment_default ("\\begin{equation}
          ", "
          \\end{equation}");
          (%o3) [\begin{equation}
          ,
          \end{equation}]
          (%i4) tex (f(x) + g(x));
          \begin{equation}
          g\left(x\right)+f\left(x\right)
          \end{equation}
          (%o4)                         false

 -- Función: system (<command>)
     Ejecuta la instrucción <command> como un proceso independiente de
     Maxima.  La instrucción se le pasa a la consola del sistema para
     su ejecución.  La función `system' no está soportada por todos los
     sistemas operativos, pero suele estarlo en todos los entornos
     Unix y similares.

     Suponiendo que `_hist.out' es una lista de frecuencias que se
     quieren representar en un diagrama de barras utilizando el
     programa `xgraph',

          (%i1) (with_stdout("_hist.out",
                     for i:1 thru length(hist) do (
                       print(i,hist[i]))),
                 system("xgraph -bar -brw .7 -nl < _hist.out"));

     A fin de hacer el diagrama y eliminar el archivo temporal
     posteriormente, hágase:

          system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")


 -- Variable opcional: ttyoff
     Valor por defecto: `false'

     Si `ttyoff' vale `true', no se muestran las expresiones
     resultantes, pero éstas se calculan de todos modos y se les
     asignan etiquetas. Véase `labels'.

     El texto que escriban las funciones internas de Maxima, tales como
     los mensajes de error y las salidas de `describe', no se ven
     afectadas por `ttyoff'.


 -- Función: with_stdout (<f>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Función: with_stdout (<s>, <expr_1>, <expr_2>, <expr_3>, ...)
     Evalúa  <expr_1>, <expr_2>, <expr_3>, ...  y escribe los
     resultados en el fichero <f> o flujo de salida <s>.  Las
     expresiones que se evalúan no se escriben. La salida puede
     generarse por medio de `print', `display', `grind' entre otras
     funciones.

     La variable global `file_output_append' controla si `with_stdout'
     añade o reinicia el contenido del fichero de salida <f>.  Si
     `file_output_append' vale `true', `with_stdout' añade contenido al
     fichero de salida. En cualquier caso, `with_stdout' crea el
     fichero si éste no existe.

     La función `with_stdout' devuelve el valor de su último argumento.

     Véase también `writefile'.

          (%i1) with_stdout ("tmp.out",
                             for i:5 thru 10 do print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800


 -- Función: writefile (<filename>)
     Comienza escribiendo una transcripción de la sesión de Maxima en
     el archivo <filename>.  Cualquier interacción entre Maxima y el
     usuario se almacena también en este archivo, tal como aparece en
     la consola.

     Puesto que la transcripción se escribe en el formato de salida a
     la consola, su contenido no es interpretable por Maxima.  Para
     hacer un archivo que contenga expresiones que puedan ser
     nuevamente cargadas en Maxima, véanse `save' y `stringout'; la
     función `save' almacena expresiones en formato Lisp, mientras que
     `stringout' lo hace en formato Maxima.

     El resultado de ejecutar `writefile' cuando el archivo <filename>
     ya existe depende del entorno Lisp operativo; el contenido
     anterior puede ser sobreescrito o ampliado con la sesión actual.
     La función `appendfile' siempre añade la sesión al contenido
     actual.

     Puede ser útil ejecutar `playback' después de `writefile' para
     guardar las interacciones previas de la sesión. Puesto que
     `playback' muestra solamente las variables de entrada y salida
     (`%i1', `%o1', etc.), cualquier salida generada por una sentencia
     de impresión desde dentro de una función no es mostrada por
     `playback'.

     La función `closefile' cierra los archivos abiertos por
     `writefile' o `appendfile'.



File: maxima.info,  Node: Aritmética de punto flotante,  Next: Contextos,  Prev: Lectura y escritura,  Up: Top

10 Aritmética de punto flotante
*******************************

* Menu:

* Funciones y variables para la aritmética de punto flotante::


File: maxima.info,  Node: Funciones y variables para la aritmética de punto flotante,  Prev: Aritmética de punto flotante,  Up: Aritmética de punto flotante

10.1 Funciones y variables para la aritmética de punto flotante
===============================================================

 -- Función: bffac (<expr>, <n>)
     Versión para "bigfloat" de la función factorial (Gamma
     desplazada). El segundo argumento indica cuántos dígitos se
     conservan y devuelven, pudiendo utilizarse para obtener algunas
     cifras extra.


 -- Variable optativa: algepsilon
     Valor por defecto: 10^8

     El valor de `algepsilon' es usado por `algsys'.


 -- Función: bfloat (<expr>)
     Convierte todos los números y  funciones numéricas a números
     decimales de punto flotante grandes ("bigfloats").  El número de
     dígitos significativos de los "bigfloats" resultantes se
     especifica mediante la variable global `fpprec'.

     Si `float2bf' vale `false' se mostrará un mensaje de aviso cuando
     un número en punto flotante se convierte a decimal de tipo
     "bigfloats", puesto que tal transformación puede conllevar pérdida
     de precisión.


 -- Función: bfloatp (<expr>)
     Devuelve `true' si <expr> es un número decimal en punto flotante
     grande ("bigfloats"), en caso contrario devuelve `false'.


 -- Función: bfpsi (<n>, <z>, <fpprec>)
 -- Función: bfpsi0 (<z>, <fpprec>)
     La función `bfpsi' es la poligamma de argumento real <z> y de
     orden el entero <n>. La función `bfpsi0' es la digamma.  La
     llamada `bfpsi0 (<z>, <fpprec>)' equivale a `bfpsi (0, <z>,
     <fpprec>)'.

     Estas funciones devuelven valores "bigfloat". La variable <fpprec>
     es la precisión "bigfloat" del valor de retorno.


 -- Variable optativa: bftorat
     Valor por defecto: `false'

     La variable `bftorat' controla la conversión de números decimales
     de punto flotante grandes ("bigfloats") a números racionales. Si
     `bftorat' vale `false', se utilizará `ratepsilon' para controlar
     la conversión  (lo cual resulta en números racionales
     relativamente pequeños). Si  `bftorat' vale `true', el número
     racional generado representará exactamente al número decimal de
     punto flotante grande ("bigfloat").


 -- Variable optativa: bftrunc
     Valor por defecto: `true'

     La variable `bftrunc' provoca la eliminación de ceros en números
     decimales grandes no nulos para que no se muestren.  Así, si
     `bftrunc' vale `false', `bfloat (1)' se muestra como
     `1.000000000000000B0'. En otro caso, se mostrará como `1.0B0'.


 -- Función: cbffac (<z>, <fpprec>)
     Calcula el factorial de números complejos de punto flotante
     grandes.

     La instrucción `load ("bffac")' carga esta función.


 -- Función: float (<expr>)
     Convierte los enteros, números racionales y los decimales de punto
     flotante grandes ("bigfloats") que están presentes en <expr> a
     números de punto flotante. También actúa como símbolo `evflag'.


 -- Variable optativa: float2bf
     Valor por defecto: `false'

     Si `float2bf' vale `false' se mostrará un mensaje de aviso cuando
     un número en punto flotante se convierte a decimal de tipo
     "bigfloats", puesto que tal transformación puede conllevar pérdida
     de precisión.


 -- Función: floatnump (<expr>)
     Devuelve `true' si <expr> es un número de punto flotante, en caso
     contario retorna `false'.


 -- Variable optativa: fpprec
     Valor por defecto: 16

     La variable `fpprec' guarda el número de dígitos significativos en
     la aritmética con números decimales de punto flotante grandes
     ("bigfloats"). La variable `fpprec' no afecta a los cálculos con
     números decimales de punto flotante ordinarios.

     Véanse también `bfloat' y `fpprintprec'.


 -- Variable optativa: fpprintprec
     Valor por defecto: 0

     La variable `fpprintprec' guarda el número de dígitos a imprimir
     de los números decimales en coma flotante, tanto los ordinarios
     como los de precisión ilimitada (bigfloats).

     En el caso de los decimales ordinarios, si `fpprintprec' toma un
     valor entre 2 y 16 (inclusive), el número de dígitos que se
     imprimen es igual a `fpprintprec'. En caso contrario,
     `fpprintprec' es 0 o mayor que 16, siendo el número de dígitos a
     imprimir en todos loa casos igual a 16.

     En el caso de los decimales de precisión ilimitada (bigfloats), si
     `fpprintprec' toma un valor entre 2 y 16 (inclusive), el número de
     dígitos que se imprimen es igual a `fpprintprec'. En caso
     contrario, `fpprintprec' es 0 o mayor que `fpprec', siendo el
     número de dígitos a imprimir igual a `fpprec'.

     La variable `fpprintprec' no admite el valor 1.


File: maxima.info,  Node: Contextos,  Next: Polinomios,  Prev: Aritmética de punto flotante,  Up: Top

11 Contextos
************

* Menu:

* Funciones y variables para Contextos::


File: maxima.info,  Node: Funciones y variables para Contextos,  Prev: Contextos,  Up: Contextos

11.1 Funciones y variables para Contextos
=========================================

 -- Función: activate (<context_1>, ..., <context_n>)
     Activa los contextos <context_1>, ..., <context_n>.  Los hechos en
     estos contextos están disponibles para hacer deducciones y extraer
     información.  Los hechos en estos contextos no se listan al
     invocar `facts ()'.

     La variable `activecontexts' es la lista de contextos que se han
     activado por medio de la función `activate'.


 -- Variable del sistema: activecontexts
     Valor por defecto: `[]'

     La variable `activecontexts' es la lista de contextos que se han
     activado por medio de la función `activate', pero que no se han
     activado por ser subcontextos del contexto actual.


 -- Función: assume (<pred_1>, ..., <pred_n>)
     Añade los predicados <pred_1>, ..., <pred_n> al contexto actual.
     Si un predicado es inconsistente o redundante con los otros
     predicados del contexto actual, entonces no es añadido al contexto.
     El contexto va acumulando predicados con cada llamada a `assume'.

     La función `assume' devuelve una lista cuyos miembros son los
     predicados que han sido añadidos al contexto, o los átomos
     `redundant' o `inconsistent' si fuere necesario.

     Los predicados <pred_1>, ..., <pred_n> tan solo pueden ser
     expresiones formadas con los operadores relacionales `< <= equal
     notequal >=' y `>'. Los predicados no pueden estar formados por
     expresiones que sean del tipo igualdad `=' ni del tipo desigualdad
     `#', ni tampoco pueden ser funciones de predicado como `integerp'.

     En cambio, sí se reconocen predicados compuestos de la forma
     `<pred_1> and ... and <pred_n>', pero no `<pred_1> or ... or
     <pred_n>'.  También se reconoce `not <pred_k>' si <pred_k> es un
     predicado relacional. Expresiones de la forma `not (<pred_1> and
     <pred_2>)' y `not (<pred_1> or <pred_2>)' no son reconocidas.

     El mecanismo deductivo de Maxima no es muy potente; existen muchas
     consecuencias que, siendo obvias, no pueden ser obtenidas por `is'.
     Se trata de una debilidad reconocida.

     La función `assume' evalúa sus argumentos.

     Véanse también `is', `facts', `forget', `context' y `declare'.

     Ejemplos:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown


 -- Variable opcional: assumescalar
     Valor por defecto: `true'

     La variable `assumescalar' ayuda a controlar si una expresión
     `expr' para la cual `nonscalarp (expr)' es `false' va a tener un
     comportamiento similar a un escalar bajo ciertas transformaciones.

     Sea `expr' cualquier expresión distinta de una lista o matriz, y
     sea también `[1, 2, 3]' una lista o una matriz. Entonces, `expr .
     [1, 2, 3]' dará como resultado `[expr, 2 expr, 3 expr]' si
     `assumescalar' es `true', o si `scalarp (expr)' es `true', o si
     `constantp (expr)' es `true'.

     Si `assumescalar' vale `true', la expresión se comportará como un
     escalar sólo en operaciones conmutativas, pero no en el caso de la
     multiplicación no conmutativa o producto matricial `.'.

     Si `assumescalar' vale `false', la expresión se comportará como un
     no escalar.

     Si `assumescalar' vale `all', la expresión se comportará como un
     escalar para todas las operaciones.


 -- Variable opcional: assume_pos
     Valor por defecto: `false'

     Si `assume_pos' vale `true' y el signo de un parámetro <x> no
     puede ser determinado a partir del contexto actual o de otras
     consideraciones, `sign' y `asksign (<x>)' devolverán `true'. Con
     esto se pueden evitar algunas preguntas al usuario que se generan
     automáticamente, como las que hacen `integrate' y otras funciones.

     By default, a parameter is <x> such that `symbolp (<x>)' or
     `subvarp (<x>)'.

     Por defecto, un parámetro <x> es aquel para el que `symbolp (<x>)'
     o `subvarp (<x>)' devuelven `true'.  La clase de expresiones que
     se consideran parámetros se puede extender mediante la utilización
     de la variable `assume_pos_pred'.

     Las funciones `sign' y `asksign' intentan deducir el signo de una
     expresión a partir de los signos de los operandos que contiene.
     Por ejemplo, si `a' y `b' son ambos positivos, entonces `a + b'
     también es positivo.

     Sin embargo, no es posible obviar todas las preguntas que hace
     `asksign'. En particular, cuando el argumento de `asksign' es una
     diferencia `<x> - <y>' o un logaritmo `log(<x>)', `asksign'
     siempre solicita una respuesta por parte del usuario, incluso
     cuando `assume_pos' vale `true' y `assume_pos_pred' es una función
     que devuelve `true' para todos los argumentos.


 -- Variable opcional: assume_pos_pred
     Valor por defecto: `false'

     Cuando a `assume_pos_pred' se le asigna el nombre de una función o
     una expresión lambda de un único argumento <x>, ésta será invocada
     para determinar si <x> se considera un parámetro por `assume_pos'.
     La variable `assume_pos_pred' se ignora cuando `assume_pos' vale
     `false'.

     La función `assume_pos_pred' es invocada por  `sign' y por
     `asksign' con un argumento <x>, el cual puede ser un átomo, una
     variable subindicada o una expresión de llamada a una función. Si
     la función `assume_pos_pred' devuelve `true', <x> será considerada
     como un parámetro por `assume_pos'.

     Por defecto, un parámetro <x> es aquel para el que `symbolp (<x>)'
     o `subvarp (<x>)' devuelven `true'.

     Véanse también `assume' y `assume_pos'.

     Ejemplos:

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz
          (%i5) assume_pos_pred: lambda ([x], display (x), true)$
          (%i6) asksign (a);
                                        x = a

          (%o6)                          pos
          (%i7) asksign (a[1]);
                                       x = a
                                            1

          (%o7)                          pos
          (%i8) asksign (foo (a));
                                     x = foo(a)

          (%o8)                          pos
          (%i9) asksign (foo (a) + bar (b));
                                     x = foo(a)

                                     x = bar(b)

          (%o9)                          pos
          (%i10) asksign (log (a));
                                        x = a

          Is  a - 1  positive, negative, or zero?

          p;
          (%o10)                         pos
          (%i11) asksign (a - b);
                                        x = a

                                        x = b

                                        x = a

                                        x = b

          Is  b - a  positive, negative, or zero?

          p;
          (%o11)                         neg


 -- Variable opcional: context
     Valor por defecto: `initial'

     La variable `context' da nombre al conjunto de hechos establecidos
     desde `assume' y `forget'. La función `assume' añade nuevos hechos
     al conjunto nombrado por `context', mientras que `forget' los va
     eliminando.  Asignando a `context' un nuevo nombre <foo> cambia el
     contexto actual a <foo>. Si el contexto <foo> no existe todavía,
     se crea automáticamente mediante una llamada a `newcontext'.

     Véase `contexts' para una descripción general del mecanismo que
     siguen los contextos.


 -- Variable opcional: contexts
     Valor por defecto: `[initial, global]'

     La variable `contexts' es una lista que contiene los contextos
     existentes, incluyendo el actualmente activo.

     El mecanismo que siguen los contextos permiten al usuario agrupar
     y nombrar un conjunto de hechos, que recibe el nombre de contexto.
     Una vez hecho esto, el usuario puede hacer que Maxima tenga en
     cuenta o que olvide cualquier número de hechos sin más que activar
     o desactivar su contexto.

     Cualquier átomo simbólico puede ser el nombre de un contexto, y
     los hechos contenidos en tal contexto pueden ser almacenados hasta
     que se destruyan uno a uno mediante llamadas a la función
     `forget', o que se destruyan conjuntamente invocando a `kill' para
     eliminar el contexto al que pertenecen.

     Los contextos tienen estructura jerárquica, siendo su raíz el
     contexto `global', el cual contiene información sobre Maxima que
     necesitan algunas funciones. Cuando en un contexto todos los
     hechos están activos (lo que significa que están siendo utilizados
     en deducciones) lo estarán también en cualquier subcontexto del
     contexto actual.

     Cuando se comienza una sesión de Maxima, el usuario estará
     trabajando en un contexto llamado `initial', el cual tiene un
     subcontexto de nombre `global'.

     Véanse también `facts', `newcontext', `supcontext', `killcontext',
     `activate', `deactivate', `assume' y `forget'.


 -- Función: deactivate (<contexto_1>, ..., <contexto_n>)
     Desactiva los contextos especificados <contexto_1>, ...,
     <contexto_n>.


 -- Función: facts (<item>)
 -- Función: facts ()
     Si <item> es el nombre de un contexto, `facts (<item>)' devuelve
     una lista con los hechos asociados al contexto especificado.

     Si <item> no es el nombre de un contexto, `facts (<item>)'
     devuelve una lista con los hechos conocidos acerca de <item> en el
     contexto actual. Los hechos que estén activos en contextos
     diferentes no aparecen en la lista.

     La lamada `facts ()', sin argumentos, muestra el contexto actual.


 -- Declaración: features
     Maxima reconoce ciertas propiedades matemáticas sobre funciones y
     variables.

     La llamada `declare (<x>, <foo>)' asocia la propiedad <foo> a la
     función o variable <x>.

     La llamada `declare (<foo>, feature)' declara una nueva propiedad
     <foo>. Por ejemplo, `declare ([rojo, verde, azul], feature)'
     declara tres nuevas propiedades, `rojo', `verde' y `azul'.

     El predicado `featurep (<x>, <foo>)' devuelve `true' si <x> goza
     de la propiedad <foo>, y `false' en caso contrario.

     La lista `features' contiene las propiedades que reconoce Maxima;
     a saber, `integer', `noninteger', `even', `odd', `rational',
     `irrational', `real', `imaginary', `complex', `analytic',
     `increasing', `decreasing', `oddfun', `evenfun', `posfun',
     `commutative', `lassociative', `rassociative', `symmetric', and
     `antisymmetric', junto con las definidas por el usuario.

     La lista `features' sólo contiene propiedades matemáticas. Hay
     otra lista con propiedades no matemáticas; Véase `status'.


 -- Función: forget (<pred_1>, ..., <pred_n>)
 -- Función: forget (<L>)
     Borra los predicados establecidos por `assume'. Los predicados
     pueden ser expresiones equivalentes, pero no necesariamente
     idénticas, a las establecidas por `assume'.  The predicates may be
     expressions equivalent to (but not necessarily identical to) those
     previously assumed.

     La llamada `forget (<L>)', siendo <L> una lista de predicados,
     borra todos los predicados contenidos en ella.


 -- Función: killcontext (<contexto_1>, ..., <contexto_n>)
     Elimina los contextos <contexto_1>, ..., <contexto_n>.

     Si alguno de estos contextos es el actual, el nuevo contexto
     activo será el primer subcontexto disponible del actual que no
     haya sido eliminado. Si el primer contexto no eliminado disponible
     es `global' entonces `initial' será usado en su lugar.  Si el
     contexto `initial' es eliminado, se creará un nuevo contexto
     `initial' completamente vacío.

     La función `killcontext' no elimina un contexto actualmente activo
     si es un subcontexto del contexto actual, o si se hace uso de la
     función `activate'.

     La función `killcontext' evalúa sus argumentos y devuelve `done'.


 -- Función: newcontext (<nombre>)
     Crea un nuevo contexto vacío <nombre>, el cual tiene a `global'
     como su único subcontexto. El recién creado contexto pasa a ser el
     contexto actualmente activo.

     La función `newcontext' evalúa sus argumentos y devuelve <nombre>.


 -- Función: supcontext (<nombre>, <contexto>)
 -- Función: supcontext (<nombre>)
     Crea un nuevo contexto <nombre>, que tiene a <contexto> como
     subcontexto. El argumento <contexto> debe existir ya.

     Si no se especifica <context>, se tomará como tal el actual.



File: maxima.info,  Node: Polinomios,  Next: Constantes,  Prev: Contextos,  Up: Top

12 Polinomios
*************

* Menu:

* Introducción a los polinomios::
* Funciones y variables para polinomios::


File: maxima.info,  Node: Introducción a los polinomios,  Next: Funciones y variables para polinomios,  Prev: Polinomios,  Up: Polinomios

12.1 Introducción a los polinomios
==================================

Los polinomios se almacenan en Maxima, bien en un formato general, bien
en una forma conocida como canónica (Cannonical Rational Expressions,
CRE). La última corresponde al formato estándar y se utiliza
internamente para realizar operaciones como `factor', `ratsimp' y demás.

   Las Expresiones Racionales Canónicas (CRE) constituyen un tipo de
representación que es especialmente apropiado para expandir polinomios
y funciones racionales (así como para polinomios parcialmente
factorizados y funciones racionales cuando a la variable `ratfac' se le
asigna el valor `true'). En esta forma CRE las variables se ordenan de
mayor a menor. Los polinomios se representan recursivamente como una
lista compuesta por la variable principal seguida por una serie de
pares de expresiones, una por cada término del polinomio. El primer
miembro de cada par es el exponente de la variable principal en ese
término y el segundo miembro es el coeficiente de ese término, el cual
puede ser un número o un polinomio en otra variable representado
también de esta forma. Así, la parte principal de la forma CRE de
3*X^2-1 es (X 2 3 0 -1) y la de 2*X*Y+X-3 es (Y 1 (X 1 2) 0 (X 1 1 0
-3)) asumiendo que Y es la variable principal, y será (X 1 (Y 1 2 0 1)
0 -3) si se asume que la variable principal es X. Qué variable se
considera "principal" se determinada en orden alfabético inverso.  Las
"variables" de la expresión CRE no son necesariamente atómicas. De hecho
cualquier subexpresión cuyo operador principal no es + - * / ni ^ con
potencia entera puede ser considerada como una "variable" de la
expresión (en forma CRE) en el cual aparezca. Por ejemplo las variables
CRE de la expresión X+SIN(X+1)+2*SQRT(X)+1 son X, SQRT(X)  y SIN(X+1).
Si el usuario no especifica una ordenación de las variables mediante la
función `ratvars' Maxima escogerá una alfabéticamente. En general, laa
CRE representan expresiones racionales, esto es, fracciones de
polinomios, donde el numerador y el denominador  no tienen factores
comunes, siendo el denominador es positivo. La forma interna es
esencialmente un par de polinomios (el numerador y el denominador)
precedida por la lista de variables ordenadas. Si una expresión a ser
mostrada está en la forma CRE o contiene alguna subexpresión en forma
de CRE, el simbolo /R/ será seguido por la etiqueta de la línea de
comando.  Véase la función `rat' para convertir una expresión a la
forma CRE. Una extensión de la forma CRE se utiliza para la
representación de las series de Taylor. La noción de una expresión
racional se extiende de manera que los exponentes de las variables
pueden ser números racionales positivos o negativos y no sólo enteros
positivos y los coeficientes pueden ser también expresiones racionales
y no sólo polinomios. Estas expresiones se representan internamente por
una forma polinomial recursiva que es similar a la forma CRE, pero que
la generaliza, aportando información adicional como el grado de
truncamiento. Como con la forma CRE, el símbolo /T/ sigue la etiqueta
de línea de comando en la que se encuentra dicha expresión.


File: maxima.info,  Node: Funciones y variables para polinomios,  Prev: Introducción a los polinomios,  Up: Polinomios

12.2 Funciones y variables para polinomios
==========================================

 -- Variable opcional: algebraic
     Valor por defecto: `false'

     La variable `algebraic' debe valer `true' para que se pueda hacer
     la simplificación de enteros algebraicos.


 -- Variable opcional: berlefact
     Valor por defecto: `true'

     Si `berlefact' vale `false' entonces se utiliza el algoritmo de
     factorización de Kronecker, en caso contrario se utilizará el
     algoritmo de Berlekamp, que es el que se aplica por defecto.


 -- Función: bezout (<p1>, <p2>, <x>)
     Es una alternativa a la función `resultant'.  Devuelve una matriz.


 -- Función: bothcoef (<expr>, <x>)
     Devuelve una lista cuyo primer miembro es el coeficiente de <x> en
     <expr> (que coincide con el que devuelve `ratcoef' si <expr> está
     en formato CRE, o el que devuelve `coeff' si no está en este
     formato) y cuyo segundo miembro es la parte restante de <expr>.
     Esto es, `[A, B]' donde `<expr> = A*<x> + B'.

     Ejemplo:

          (%i1) islinear (expr, x) := block ([c],
                  c: bothcoef (rat (expr, x), x),
                  is (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true


 -- Función: coeff (<expr>, <x>, <n>)
     Devuelve el coeficiente de `<x>^<n>' en <expr>. El argumento <n>
     puede omitirse si es igual a la unidad. El argumento <x> puede ser
     un átomo  o una subexpresión completa de <expr>, por ejemplo
     `sin(x)', `a[i+1]', `x + y', etc. (En este último caso, la
     expresión `(x + y)' debe aparecer en <expr>).  En ocasiones puede
     ser necesario expandir o factorizar <expr> para hacer `<x>^<n>'
     explícito, lo cual no hace `coeff' automáticamente.

     Ejemplos:

          (%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
          (%o1)                      2 a + 1 = 5
          (%i2) coeff (y + x*%e^x + 1, x, 0);
          (%o2)                         y + 1


 -- Función: combine (<expr>)
     Simplifica la suma <expr> combinando términos de con igual
     denominador reduciéndolos a un único término.


 -- Función: content (<p_1>, <x_1>, ..., <x_n>)
     Devuelve una lista cuyo primer miembro es el máximo común divisor
     de los coeficientes de los términos del polinomio <p_1> de
     variable <x_n> (este es el contenido) y cuyo segundo miembro es el
     polinomio <p_1> dividido por el contenido.

     Ejemplos:

          (%i1) content (2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]


 -- Función: denom (<expr>)
     Devuelve el denominador de la expresión racional <expr>.


 -- Función: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Calcula el cociente y el resto del polinomio <p_1> dividido por el
     polinomio <p_2>, siendo la variable principal <x_n>.  Las otras
     funciones son como en la función `ratvars'. El resultado es una
     lista cuyo primer miembro es el cociente y el segundo miembro el
     resto.

     Ejemplos:

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Nótese que `y' es la variable principal en el segundo ejemplo.


 -- Función: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])
     Elimina variables de ecuaciones (o de expresiones que se supone
     valen cero) tomando resultantes sucesivas. Devuelve una lista con
     `<n> - <k>' expresiones y <k> variables <x_1>, ..., <x_k>
     eliminadas.  Primero se elimina  <x_1> dando `<n> - 1'
     expresiones, después se elimina `x_2', etc.  Si `<k> = <n>'
     entonces se devuelve una lista con una única expresión, libre de
     las variables <x_1>, ..., <x_k>. En este caso se llama a `solve'
     para resolver la última resultante para la última variable.

     Ejemplo:

          (%i1) expr1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) expr2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) expr3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate ([expr3, expr2, expr1], [y, z]);
                       8         7         6          5          4
          (%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                              3         2
                                      - 5154 x  - 1291 x  + 7688 x + 15376]


 -- Función: ezgcd (<p_1>, <p_2>, <p_3>, ...)
     Devuelve una lista cuyo primer elemento es el máximo común divisor
     (mcd) de los polinomios <p_1>, <p_2>, <p_3>, ...  siendo los
     miembros restantes los mismos polinomios divididos por el mcd. Se
     utiliza siempre el algoritmo `ezgcd'.


 -- Variable opcional: facexpand
     Valor por defecto: `true'

     La variable `facexpand' controla si los factores irreducibles
     devueltos por `factor' están en formato expandido (por defecto) o
     recursivo  (CRE normal).


 -- Función: factcomb (<expr>)
     Trata de combinar los coeficientes de los factoriales de <expr>
     con los mismos factoriales, convirtiendo, por ejemplo, `(n +
     1)*n!' en `(n + 1)!'.

     Si la variable `sumsplitfact' vale `false' hará que `minfactorial'
     se aplique después de `factcomb'.


 -- Función: factor (<expr>)
 -- Función: factor (<expr>, <p>)
     Factoriza la expresión <expr>, que puede contener cualquier número
     de variables o funciones, en factores irreducibles respecto de los
     enteros. La llamada `factor (<expr>, <p>)' factoriza <expr> en el
     campo de los racionales con un elemento añadido cuyo polinomio
     mínimo es <p>.

     La función `factor' utiliza a `ifactors' para factorizar enteros.

     Si la variable `factorflag' vale `false' suprime la factorización
     de los factores enteros en las expresiones racionales.

     La variable `dontfactor' puede contener una lista de variables con
     respecto a las cuales no se factorizará (inicialmente está vacía).
     Tampoco se factorizará respecto de cualesquiera otra variables que
     sean menos importantes (según la ordenación que se sigue en el
     formato CRE) que aquellas que se encuentran en la lista
     `dontfactor'.

     Si la variable `savefactors' vale `true', los factores de una
     expresión en forma de producto se guardarán por ciertas funciones
     a fin de acelerar posteriores factorizaciones de expresiones que
     contengan algunos de estos mismos factores.

     Si `berlefact' vale `false' entonces se utiliza el algoritmo de
     factorización de Kronecker, en caso contrario se utilizará el
     algoritmo de Berlekamp, que es el que se aplica por defecto.

     Si la variable `intfaclim' vale `true', Maxima desistirá de
     factorizar enteros si no encuentra ningún factor después de las
     divisiones tentativas y de aplicar el método rho de Pollard. Si
     vale `false' (este es el caso cuando el usuario invoca
     explícitamente a `factor'), se intentará la factorización completa
     del entero. El valor asignado a `intfaclim' se utiliza en llamadas
     internas a `factor'. Así, se puede cambiar el valor de `intfaclim'
     para evitar que Maxima dedique un tiempo prohibitivo a factorizar
     números enteros grandes.

     Ejemplos:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)


 -- Variable opcional: factorflag
     Valor por defecto: `false'

     Si `factorflag' vale `false' se evita la factorización de factores
     enteros de expresiones racionales.


 -- Función: factorout (<expr>, <x_1>, <x_2>, ...)
     Reorganiza la suma <expr> como una suma de términos de la forma `f
     (<x_1>, <x_2>, ...)*g' donde `g' es un producto de expresiones que
     no contienen ningún <x_i> y `f' se factoriza.


 -- Función: factorsum (<expr>)
     Intenta agrupar términos en los factores de <expr> que son sumas
     en grupos de términos tales que su suma sea factorizable. La
     función `factorsum' puede restablecer el recuperar de `expand ((x
     + y)^2 + (z + w)^2)' pero no puede recuperar `expand ((x + 1)^2 +
     (x + y)^2)' porque los términos tienen variables comunes.

     Ejemplo:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum (%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )


 -- Función: fasttimes (<p_1>, <p_2>)
     Calcula el producto de los polinomios <p_1> y <p_2> utilizando un
     algoritmo especial. Los polinomios `p_1' y `p_2' deben ser
     multivariantes, densos y aproximadamente del mismo tamaño. La
     multiplicación clásica es de orden `n_1 n_2' donde `n_1' es el
     grado de  `p_1' y  `n_2' el grado de `p_2'. La función `fasttimes'
     es de orden `max (n_1, n_2)^1.585'.


 -- Función: fullratsimp (<expr>)
     Aplica repetidamente `ratsimp' a una expresión, seguida de
     simplificaciones no racionales, hasta que no se obtienen más
     transformaciones; entonces devuelve el resultado.

     En presencia de expresiones no racionales, una llamada a `ratsimp'
     seguida de una simplificación no racional ("general") puede no ser
     suficiente para conseguir un resultado simplificado. En ocasiones
     serán necesarias más de una llamada a `ratsimp', que es lo que
     hace precisamente `fullratsimp'.

     Ejemplo:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1


 -- Función: fullratsubst (<a>, <b>, <c>)
     Similar a `ratsubst' excepto por el hecho de que se llama a í
     misma recursivamente hasta que el resultado deja de cambiar. Esta
     función es útil cuando la expresión a sustituir y la que la
     sustituye tienen variables comunes.

     La función `fullratsubst' también acepta sus argumentos en el
     formato de `lratsubst'.

     Es necesario ejecutar `load ("lrats")' para cargar `fullratsubst'
     y `lratsubst'.

     Ejemplos:

          (%i1) load ("lrats")$

        * `subst' puede hacer sustituciones múltiples; `lratsubst' es
          análoga a `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * Si sólo se quiere una sustitución, entonces se puede dar una
          única ecuación como primer argumento.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

        * `fullratsubst' equivale a `ratsubst', excepto por el hecho de
          que se llama a í misma recursivamente hasta que el resultado
          deja de cambiar.

          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b

        * `fullratsubst' también acepta una lista de ecuaciones o una
          sóla ecuación como primer argumento.

          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b

        * `fullratsubst' puede caer en una recursión infinita.

          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET


 -- Función: gcd (<p_1>, <p_2>, <x_1>, ...)
     Devuelve el máximo común divisor de <p_1> y <p_2>.  La variable
     `gcd' determiona qué algoritmo se va a utilizar.  Asignándole a
     `gcd' los valores `ez', `subres', `red' o `spmod', se seleccionan
     los algoritmos `ezgcd', subresultante `prs', reducido o modular,
     respectivamente.  Si `gcd' vale `false' entonces `gcd(<p_1>,
     <p_2>, <x>)' devolverá siempre 1 para cualquier <x>.  Muchas
     funciones (por ejemplo,  `ratsimp', `factor', etc.)  hacen uso de
     `gcd' implícitamente.  En caso de polinomios homogéneos se
     recomienda darle a `gcd' el valor `subres'.  Para calcular un
     máximo común divisor en presencia de raíces, como en  `gcd (<x>^2
     - 2*sqrt(2)*<x> + 2, <x> - sqrt(2))', la variable `algebraic' debe
     igualarse a `true' y `gcd' no puede ser `ez'.

     Se recomienda utilizar el algoritmo `subres' en lugar de `red',
     por ser aquél más moderno.

     Si la variable `gcd', cuyo valor por defecto es `spmod', vale
     `false', no se calculará el máximo común divisor cuando las
     expresiones se conviertan a su forma canónica (CRE), lo que
     redundará en ocasiones en mayor rapidez de cálculo.


 -- Función: gcdex (<f>, <g>)
 -- Función: gcdex (<f>, <g>, <x>)
     Devuelve una lista `[<a>, <b>, <u>]' en la que <u> es el máximo
     común divisor (mcd) de <f> y <g>, e igual a `<a> <f> + <b> <g>'.
     Los argumentos <f> y <g> deben ser polinomios univariantes, o
     indicarles la variable principal <x> en caso de ser multivariantes.

     La función `gcdex' implementa el algoritmo de Euclides, en el que
     tenemos una secuencia de `L[i]: [a[i], b[i], r[i]]' todos ellos
     ortogonales a `[f, g, -1]' siendo el siguiente calculado a partir
     de `q = quotient(r[i]/r[i+1])' y `L[i+2]: L[i] - q L[i+1]'; el
     proceso termina en `L[i+1]' cuando el resto `r[i+2]' se anula.

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0


 -- Función: gcfactor (<n>)
     Factoriza el entero gaussiano <n> como producto, a su vez, de
     enteros gaussianos, (un entero gaussiano es de la forma`<a> + <b>
     `%i'' donde <a> y <b> son números enteros). Los factores se
     normalizan de manera que tanto la parte real como imaginaria sean
     no negativas.


 -- Función: gfactor (<expr>)
     Factoriza el polinomio <expr> sobre los enteros gaussianos (un
     entero gaussiano es de la forma`<a> + <b> `%i'' donde <a> y <b>
     son números enteros).  Es como `factor (<expr>, <a>^2+1)' donde
     <a> vale `%i'.

     Ejemplo:

          (%i1) gfactor (x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)


 -- Función: gfactorsum (<expr>)
     Esta función es similar a `factorsum' pero aplica `gfactor' en
     lugar de `factor'.


 -- Función: hipow (<expr>, <x>)
     Devuelve el mayor exponente explícito de  <x> en <expr>.  El
     argumento<x> puede ser una variable o una expresión general.  Si
     <x> no aparece en <expr>, `hipow' devuelve `0'.

     La función `hipow' no tiene en cuenta expresiones equivalentes a
     `expr'.  En particular, `hipow' no expande `expr', de manera que
     `hipow (<expr>, <x>)' y `hipow (expand (<expr>, <x>))' pueden dar
     resultados diferentes.

     Ejemplos:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0


 -- Variable opcional: intfaclim
     Valor por defecto: `true'

     Si vale `true', Maxima  desistirá de factorizar enteros si no
     encuentra ningún factor después de las divisiones tentativas y de
     aplicar el método rho de Pollard, por lo que la factorización
     puede quedar incompleta.

     Si vale `false' (este es el caso cuando el usuario invoca
     explícitamente a `factor'), se intentará la factorización completa
     del entero. El valor asignado a `intfaclim' se utiliza en llamadas
     internas a `factor'. A la variable `intfaclim' se le asigna el
     valor `false' cuando se calculan factores desde las funciones
     `divisors', `divsum' y `totient'.

     Las llamadas internas a `factor' respetan el valor dado por el
     usuario a `intfaclim'.  Asignando a `intfaclim' el valor `true' se
     puede reducir  el tiempo que Maxima dedica a factorizar enteros
     grandes.


 -- Variable opcional: keepfloat
     Valor por defecto: `false'

     Si `keepfloat' vale `true', los números decimales en coma flotante
     no se racionalizan cuando las expresiones que los contienen se
     convierten al formato canónico racional (CRE).


 -- Función: lratsubst (<L>, <expr>)
     Esta función es similar a `subst (<L>, <expr>)', excepto por el
     hecho de que utiliza `ratsubst' en lugar de `subst'.

     El primer argumento de `lratsubst' es una ecuación o lista de
     ecuaciones idénticas en formato a las aceptadas por `subst'.  Las
     sustituciones se hacen en el orden dado por la lista de
     ecuaciones, esto es, de izquierda a derecha.

     La instrucción `load ("lrats")' carga `fullratsubst' y `lratsubst'.

     Ejemplos:

          (%i1) load ("lrats")$

        * `subst' can carry out multiple substitutions.  `lratsubst' is
          analogous to `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * If only one substitution is desired, then a single equation
          may be given as first argument.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b


 -- Variable opcional: modulus
     Valor por defecto: `false'

     Si `modulus' es un número positivo <p>, las operaciones con
     números racionales (como los devueltos por `rat' y funciones
     asociadas) se realizan módulo <p>, utilizando el llamado sistema
     de módulo balanceado, en el que `<n> módulo <p>' se define como un
     entero <k> de `[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' si <p> es
     impar, o de `[-(<p>/2 - 1), ..., 0, ...., <p>/2]' si <p> es par,
     de tal manera que `<a> <p> + <k>' es igual a <n> para algún entero
     <a>.

     Normalmente a `modulus' se le asigna un número primo. Se acepta
     que a `modulus' se le asigne un entero positivo no primo, pero se
     obtendrá un mensaje de aviso. Maxima permitirá que a `modulus' se
     le asigne cero o un entero negativo, aunque no esté clara su
     utilidad.


 -- Función: num (<expr>)
     Devuelve el numerador de <expr> si se trata de una fracción. Si
     <expr> no es una fracción, se devuelve <expr>.

     La función `num' evalúa su argumento.


 -- Función: polydecomp (<p>, <x>)
     Descompone el polinomio <p> de variable <x> en una composición
     funcional de polinomios en <x>.  La función `polydecomp' devuelve
     una lista `[<p_1>, ..., <p_n>]' tal que

          lambda([x],p_1)(lambda ([x],p_2)(...(lambda([x],p_n)(x))...))

     es igual a  <p>.  El grado de <p_i> es mayor que 1 para <i> menor
     que <n>.

     Esta descomposición no es única.

     Ejemplos:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     La siguiente función compone `L = [e_1, ..., e_n]' como funciones
     de `x'; se trata de la inversa de `polydecomp':

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Se vuelve a obtener el resultado del ejemplo de más arriba
     haciendo uso de `compose':

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Nótese que aunque `compose (polydecomp (<p>, <x>), <x>)' devuelve
     siempre <p> (sin expandir), `polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)'  no devuelve necesariamente `[<p_1>, ...,
     <p_n>]':

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2


 -- Función: quotient (<p_1>, <p_2>)
 -- Función: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Devuelve el polinomio <p_1> dividido por el polinomio <p_2>. Los
     argumentos <x_1>, ..., <x_n> se interpretan como en la función
     `ratvars'.

     La función `quotient' devuelve el primer elemento de la lista
     devuelta por `divide'.


 -- Función: rat (<expr>)
 -- Función: rat (<expr>, <x_1>, ..., <x_n>)
     Convierte <expr> al formato canónico racional (canonical rational
     expression o CRE) expandiendo y combinando todos los términos
     sobre un denominador común y cancelando el máximo común divisor
     del numerador y denominador, así como convirtiendo números
     decimales en coma flotante a números racionales dentro de la
     tolerancia indicada por `ratepsilon'. Las variables se ordenan de
     acuerdo a <x_1>, ..., <x_n> si se han especificado, como en la
     función `ratvars'.

     En general, `rat' no simplifica otras funciones que no sean la
     suma `+', resta `-', multiplicación `*', división `/' y
     exponenciación de exponente entero, mientras que `ratsimp' sí lo
     hace.  Nótese que los átomos (números y variables) en expresiones
     en formato CRE no son los mismos que en el formato general.  Por
     ejemplo, `rat(x)- x' devuelve `rat(0)', que tiene una
     representación interna diferente de 0.

     Si `ratprint' vale `false' no aparecerán mensajes informando al
     usuario sobre la conversión de números decimales en coma flotante
     a números racionales.

     Si `keepfloat' vale `true' no se convertirán números decimales en
     coma flotante a números racionales.

     Véanse también `ratexpand' y  `ratsimp'.

     Ejemplos:
          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x)
                   / (4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y


 -- Variable opcional: ratalgdenom
     Valor por defecto: `true'

     Si `ratalgdenom' vale `true', se permite la racionalización de
     denominadores eliminando radicales.  La variable `ratalgdenom'
     sólo tiene efecto cuando expresiones en formato canónico (CRE)
     están siendo utilizadas en modo algebraico.


 -- Función: ratcoef (<expr>, <x>, <n>)
 -- Función: ratcoef (<expr>, <x>)
     Devuelve el coeficiente de la expresión `<x>^<n>' dentro de la
     expresión <expr>. Si se omite, <n> se considera igual a 1.

     El valor devuelto está libre de las variables en <x>, excepto
     quizás en un sentido no racional. Si no existe un coeficiente de
     este tipo se devuelve 0.

     La función `ratcoef' expande y simplifica racionalmente su primer
     argumento, por lo que puede dar una respuesta diferente a la dada
     por la función `coeff', la cual tiene un carácter puramente
     sintáctico.  Así, `ratcoef ((x + 1)/y + x, x)' devuelve `(y +
     1)/y', mientras que `coeff' devuelve 1.

     La llamada `ratcoef (<expr>, <x>, 0)', siendo <expr> una suma,
     devuelve una suma formada por los términos que no contienen <x>.

     Puesto que <expr> se simplifica racionalmente antes de ser
     examinada, algunos coeficientes puede que no aparezcan como en la
     expresión original.

     Ejemplo:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x


 -- Función: ratdenom (<expr>)
     Devuelve el denominador de <expr>, después de transformar <expr>
     al formato canónico (CRE). El valor retornado está también en
     formato CRE.

     El argumento <expr> se transforma al formato CRE por la función
     `rat', a menos que ya esté en este formato.  Esta conversión puede
     cambiar la forma de <expr> colocando todos sus términos sobre un
     denominador común.

     La función `denom' es parecida, pero devuelve una expresión
     general en lugar de una CRE. Tampoco `denom' intenta colocar todos
     sus términos sobre un denominador común, de manera que algunas
     expresiones que son consideradas como divisiones por `ratdenom',
     no son tales para `denom'.


 -- Variable opcional: ratdenomdivide
     Valor por defecto: `true'

     Si `ratdenomdivide' vale `true', la función `ratexpand' expande
     una fracción en la que el numerador es una suma en una suma de
     divisiones. En otro caso, `ratexpand' reduce una suma de
     divisiones a una única fracción, cuyo numerador es la suma de los
     denominadores de cada fracción.

     Examples:
          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3


 -- Función: ratdiff (<expr>, <x>)
     Deriva la expresión racional <expr> con respecto a <x>.  El
     argumento <expr> debe ser una fracción algebraica o un polinomio
     en <x>.  El argumento <x> puede ser una variable o una
     subexpresión de <expr>.

     El resultado equivale al devuelto por `diff', aunque es posible
     que se obtenga en una forma diferente.  La función `ratdiff' puede
     ser más rápida que `diff' en expresiones racionales.

     La función `ratdiff' devuelve una expresión en formato canónico o
     CRE si `expr' es también una expresión CRE. En otro caso,
     `ratdiff' devuelve una expresión general.

     La función `ratdiff' considera únicamente la dependencia de <expr>
     respecto de <x>, ignorando cualquier dependencia establecida por
     `depends'.

     Ejemplo:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a


 -- Función: ratdisrep (<expr>)
     Devuelve su argumento como una expresión general.  Si <expr> es
     una expresión general, se devuelve sin cambios.

     Normalmente se invoca a `ratdisrep' a fin de convertir una
     expresión en formato canónico (CRE) al formato general, lo que
     puede ser utilizado si se quiere parar el contagio que produce el
     formato CRE, o para utilizar funciones racionales en contextos no
     racionales.

     Véase también `totaldisrep'.


 -- Variable opcional: ratepsilon
     Valor por defecto: 2.0e-8

     La variable `ratepsilon' guarda la tolerancia utilizada en la
     conversión de números decimales en coma flotante a números
     racionales.


 -- Función: ratexpand (<expr>)
 -- Variable opcional: ratexpand
     Expande <expr> multiplicando productos de sumas y sumas con
     exponentes, combinando fracciones con común denominador,
     cancelando el máximo común divisor del numerador y del denominador
     y luego dividiendo los sumandos del numerador por el denominador.

     El valor que devuelve `ratexpand' es una expresión general,
     incluso cuando <expr> está en formato canónico o CRE.

     Si la variable `ratexpand' vale `true' hará que las expresiones
     CRE se expandan completamente cuando se conviertan al formato
     general o se muestren en el terminal, mientras que si vale `false'
     se mostrarán de forma recursiva. Véase también `ratsimp'.

     Si `ratdenomdivide' vale `true', `ratexpand' expande una fracción
     en la que el numerador es una suma en una suma de fracciones,
     todas ellas con denominador común. En otro caso, `ratexpand'
     reduce una suma de fracciones en una única fracción, cuyo
     numerador es la suma de los numeradores de cada fracción.

     Si `keepfloat' vale `true', los números decimales en coma flotante
     no se racionalizan cuando las expresiones que los contienen se
     convierten al formato canónico racional (CRE).

     Ejemplos:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1


 -- Variable opcional: ratfac
     Valor por defecto: `false'

     Si `ratfac' vale `true', las expresiones canónicas (CRE) se
     manipulan en una forma parcialmente factorizada.

     Durante las operaciones racionales, las expresiones se mantienen
     completamente factorizadas tanto como sea posible sin llamar a
     `factor'. Esto debería ahorrar espacio y tiempo en algunos
     cálculos. El numerador y denominador se hacen primos relativos,
     por ejemplo `rat ((x^2 - 1)^4/(x + 1)^2)' devuelve `(x - 1)^4 (x +
     1)^2)', pero los factores dentro de cada parte pueden no ser
     primos relativos.

     En el paquete `ctensr' sobre manipulación de tensores por
     componentes, los tensores de Ricci, Einstein, Riemann y Weyl y la
     curvatura escalar se factorizan automáticamente si `ratfac' vale
     `true'; `ratfac' debe activarse únicamente en aquellos casos en
     los que se sabe que el número de términos de las componentes
     tensoriales es pequño.

     Nota: Los esquemas de comportamiento basados en `ratfac' y
     `ratweight' son incompatibles y no se debe  pretender usarlos al
     mismo tiempo.


 -- Función: ratnumer (<expr>)
     Devuelve el numerador de <expr>, después de reducir <expr> a su
     forma canónica (CRE).  El valor retornado está también en formato
     CRE.

     El argumento <expr> se transforma al formato CRE por la función
     `rat', a menos que ya esté en este formato.  Esta conversión puede
     cambiar la forma de <expr> colocando todos sus términos sobre un
     denominador común.

     Es parecida a la función `num', pero devuelve una expresión
     general en lugar de una CRE.  Además, `num' no intenta colocar
     todos los términos sobre un denominador común, de manera que
     algunas expresiones que son consideradas fracciones por `ratnumer'
     no se consideran como tales por `num'.


 -- Función: ratnump (<expr>)
     Devuelve `true' si <expr> es un entero literal o una fracción de
     enteros literales, en caso contrario devuelve `false'.


 -- Función: ratp (<expr>)
     Devuelve `true' si <expr> es una expresión canónica racional
     (canonical rational expression o CRE) o una CRE extendida, en caso
     contrario devuelve `false'.

     Las expresiones CRE son creadas por `rat' y funciones asociadas.
     Las CRE extendidas son creadas por `taylor' y funciones asociadas.


 -- Variable opcional: ratprint
     Valor por defecto: `true'

     Si `ratprint' vale `true', se muestra al usuario un mensaje dando
     cuenta de la conversión de números decimales en coma flotante a
     formato racional.


 -- Función: ratsimp (<expr>)
 -- Función: ratsimp (<expr>, <x_1>, ..., <x_n>)
     Simplifica la expresión <expr> y todas sus subexpresiones,
     incluyendo los argumentos de funciones no racionales. El resultado
     es un cociente de dos polinomios en una forma recursiva, esto es,
     los coeficientes de la variable principal son polinomios respecto
     de las otras variables. Las variables pueden incluir funciones no
     racionales, como `sin (x^2 + 1)', y los argumentos de tales
     funciones son también racionalmente simplificados.

     La llamada `ratsimp (<expr>, <x_1>, ..., <x_n>)' permite la
     simplificación racional con la especificación del orden de las
     variables, como en `ratvars'.

     Si `ratsimpexpons' vale `true', `ratsimp' se aplica a los
     exponentes de las expresiones durante la simplificación.

     Véase también `ratexpand'. Nótese que `ratsimp' se ve afectada por
     algunas de las variables globales que controlan a `ratexpand'.

     Ejemplos:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x


 -- Variable opcional: ratsimpexpons
     Valor por defecto: `false'

     Si `ratsimpexpons' vale `true', `ratsimp' se aplica a los
     exponentes de las expresiones durante la simplificación.


 -- Función: ratsubst (<a>, <b>, <c>)
     Sustituye <b> por <a> en <c> y devuelve la expresión resultante.
     El argumento <b> puede ser una suma, un producto, una potencia,
     etc.

     La función `ratsubst' reconoce el significado de las expresiones,
     mientras que `subst' tan solo realiza sustituciones sintácticas.
     Así por ejemplo, `subst (a, x + y, x + y + z)' devuelve `x + y + z'
     cuando `ratsubst' devuelve `z + a'.

     Si `radsubstflag' vale `true', `ratsubst' sustituye radicales en
     expresiones que no los contienen explícitamente.

     Ejemplos:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u


 -- Función: ratvars (<x_1>, ..., <x_n>)
 -- Función: ratvars ()
 -- Variable del sistema: ratvars
     Declara como variables principales <x_1>, ..., <x_n> en
     expresiones racionales. Si <x_n> está presente en una expresión
     racional, se considerará como variable principal. Si no está
     presente, entonces se considerará principal a la variable
     <x_[n-1]> si aparece en la expresión, se continúa así hasta <x_1>,
     que se considerará como variable principal sólo si ninguna de las
     variables que le siguen está presente en la expresión.

     Si una variable de la expresión racional no está presente en la
     lista `ratvars', se le dará una prioridad inferior a la de <x_1>.

     Los argumentos de `ratvars' pueden ser tanto variables como
     funciones no racionales como `sin(x)'.

     La variable `ratvars' es una lista que contiene los argumentos
     pasados a la función `ratvars' la última vez que fue invocada.
     Cada llamada a la función `ratvars' reinicializa la lista. La
     llamada `ratvars ()' vacía la lista.


 -- Función: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Función: ratweight ()
     Asigna un peso <w_i> a la variable <x_i>. Un término será
     reemplazado por 0 si su peso excede el valor de la variable
     `ratwtlvl' (por defecto no se realiza el truncamiento). El peso de
     un término es la suma de los productos de los pesos de las
     variables que lo forman multiplicados por sus exponentes. Por
     ejemplo, el peso de `3 x_1^2 x_2' es `2 w_1 + w_2'. El
     truncamiento basado en `ratwtlvl' solamente se lleva a cabo cuando
     se multiplican o se elevan a potencias expresiones canónicas (CRE).

     La llamada `ratweight ()' devuelve la lista acumulada de
     asignaciones de pesos.

     Nota: Los esquemas de comportamiento basados en `ratfac' y
     `ratweight' son incompatibles y no se debe  pretender usarlos al
     mismo tiempo.

     Ejemplos:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1


 -- Variable del sistema: ratweights
     Valor por defecto: `[]'

     La variable `ratweights' es una lista que contiene los pesos
     asignados por `ratweight'.  Las lista es acumulativa, en el
     sentido de que cada llamada a `ratweight' añade nuevos elementos a
     la lista.


 -- Variable opcional: ratwtlvl
     Valor por defecto: `false'

     La variable `ratwtlvl' se utiliza en combinación con la función
     `ratweight' para controlar el truncamiento de expresiones
     racionales canónicas (CRE). Con el valor por defecto, `false', no
     se produce truncamiento alguno.


 -- Función: remainder (<p_1>, <p_2>)
 -- Función: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Devuelve el resto de la división del polinomio <p_1> entre <p_2>.
     Los argumentos <x_1>, ..., <x_n> se interpretan como en `ratvars'.

     La función `remainder' devuelve el segundo elemento de la lista
     retornada por `divide'.


 -- Función: resultant (<p_1>, <p_2>, <x>)
 -- Variable: resultant
     Calcula la resultante de los dos polinomios <p_1> y <p_2>,
     eliminando la variable <x>.  La resultante es un determinante de
     los coeficientes de <x> en <p_1> y <p_2>, que es igual a cero si
     sólo si <p_1> y <p_2> tienen un factor común no constante.

     Si <p_1> o <p_2> pueden ser factorizados, puede ser necesario
     llamar a `factor' antes que invocar a `resultant'.

     La variable `resultant' controla qué algoritmo será utilizado para
     calcular la resultante.

     La función `bezout' toma los mismos argumentos que `resultant' y
     devuelve una matriz. El determinante del valor retornado es la
     resultante buscada.


 -- Variable opcional: savefactors
     Valor por defecto: `false'

     Si `savefactors' vale `true', los factores de una expresión
     producto se almacenan por ciertas funciones a fin de acelerar
     posteriores factorizaciones de expresiones que contengan algunos
     de estos factores.


 -- Función: tellrat (<p_1>, ..., <p_n>)
 -- Función: tellrat ()
     Añade al anillo de enteros algebraicos conocidos por Maxima los
     elementos que son soluciones de los polinomios <p_1>, ..., <p_n>.
     Cada argumento <p_i> es un polinomio de coeficientes enteros.

     La llamada `tellrat (<x>)' hace que se sustituya 0 por <x> en las
     funciones racionales.

     La llamada `tellrat ()' devuelve una lista con las sustituciones
     actuales.

     A la variable `algebraic' se le debe asignar el valor `true' a fin
     de poder realizar la simplificación de enteros algebraicos.

     Maxima reconoce la unidad imaginaria `%i' y todas las raíces de
     los enteros.

     La instrucción `untellrat' borra todas las propiedades de
     `tellrat'.

     Es ambiguo aplicar `tellrat' a un polinomio multivariante tal como
     `tellrat (x^2 - y^2)', pues no se sabe si sustituir `<y>^2' por
     `<x>^2' o al revés. Maxima sigue un cierto orden, pero si el
     usuario quiere especificar uno en concreto, puede hacerlo mediante
     la sintaxis `tellrat (y^2 = x^2)', que indica que se ponga `<x>^2'
     en lugar de `<y>^2'.

     Ejemplos:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]


 -- Función: totaldisrep (<expr>)
     Convierte cada subexpresión  de <expr> del formato canónico (CRE)
     al general y devuelve el resultado.  Si <expr> está en formato CRE
     entonces `totaldisrep' es idéntico a `ratdisrep'.

     La función `totaldisrep' puede ser útil para modificar expresiones
     como las ecuaciones, listas, matrices, etc., que tienen algunas
     subexpresiones en formato CRE.


 -- Función: untellrat (<x_1>, ..., <x_n>)
     Elimina de <x_1>, ..., <x_n> las propiedades relacionadas con
     `tellrat'.



File: maxima.info,  Node: Constantes,  Next: Logaritmos,  Prev: Polinomios,  Up: Top

13 Constantes
*************

* Menu:

* Funciones y variables para Constantes::


File: maxima.info,  Node: Funciones y variables para Constantes,  Prev: Constantes,  Up: Constantes

13.1 Funciones y variables para Constantes
==========================================

 -- Constante: %e
     El símbolo `%e' representa a la base de los logaritmos naturales,
     también conocido como número de Euler. El valor numérico de `%e'
     es el número decimal en coma flotante 2.718281828459045d0.


 -- Constante: %i
     El símbolo `%i' representa la unidad imaginaria, sqrt(- 1).


 -- Constante: false
     El símbolo `false' representa al valor lógico "falso". Maxima
     implementa `false' con el valor `NIL' de Lisp.

 -- Constante: ind
     `ind' representa un resultado acotado indeterminado.

     Véase también `limit'.

     Ejemplo:

          (%i1) limit (sin(1/x), x, 0);
          (%o1)                          ind

 -- Constante: inf
     El símbolo `inf' representa al infinito real positivo.

 -- Constante: infinity
     El símbolo `infinity' representa al infinito complejo.

 -- Constante: minf
     El símbolo `minf' representa al infinito real negativo.

 -- Constante: %phi
     El símbolo `%phi' representa a la llamada razón áurea, (1 +
     sqrt(5))/2.  El valor numérico de `%phi' es el número decimal en
     coma flotante 1.618033988749895d0.

     La función `fibtophi' expresa los números de Fibonacci `fib(n)' en
     términos de `%phi'.

     Por defecto, Maxima desconoce las propiedades algebraicas de
     `%phi'.  Tras evaluar `tellrat(%phi^2 - %phi - 1)' y `algebraic:
     true', `ratsimp' puede simplificar algunas expresiones que
     contengan `%phi'.

     Ejemplos:

     `fibtophi' expresa el número de Fibonacci `fib(n)' en términos de
     `%phi'.

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

     Por defecto, Maxima desconoce las propiedades algebraicas de
     `%phi'.  Después de evaluar `tellrat (%phi^2 - %phi - 1)' y
     `algebraic: true', `ratsimp' puede simplificar algunas expresiones
     que contengan `%phi'.

          (%i1) e : expand ((%phi^2 - %phi - 1) * (A + 1));
                           2                      2
          (%o1)        %phi  A - %phi A - A + %phi  - %phi - 1
          (%i2) ratsimp (e);
                            2                     2
          (%o2)        (%phi  - %phi - 1) A + %phi  - %phi - 1
          (%i3) tellrat (%phi^2 - %phi - 1);
                                      2
          (%o3)                  [%phi  - %phi - 1]
          (%i4) algebraic : true;
          (%o4)                         true
          (%i5) ratsimp (e);
          (%o5)                           0


 -- Constante: %pi
     El símbolo `%pi' representa la razón entre la longitud de una
     circunferencia y su radio.  El valor numérico de `%pi' es el
     número decimal en coma flotante 3.141592653589793d0.

 -- Constante: true
     El símbolo `true' representa al valor lógico "verdadero". Maxima
     implementa `true' con el valor `T' de Lisp.

 -- Constante: und
     `und' representa un resultado indefinido.

     Véase también `limit'.

     Ejemplo:

          (%i1) limit (1/x, x, 0);
          (%o1)                          und

 -- Constante: zeroa
     `zeroa' representa un infinitesimal mayor que cero.  `zeroa' puede
     utilizarse en expresiones. `limit' simplifica expresiones que
     contienen infinitesimales.

     Véanse también `zerob' y `limit'.

     Ejemplo:

     `limit' simplifica expresiones que contienen infinitesimales:

          (%i1) limit(zeroa);
          (%o1)                                  0
          (%i2) limit(x+zeroa);
          (%o2)                                  x


 -- Constante: zerob
     `zerob' representa un infinitesimal menor que cero.  `zerob' puede
     utilizarse en expresiones. `limit' simplifica expresiones que
     contienen infinitesimales.

     Véanse también `zeroa' y `limit'.


File: maxima.info,  Node: Logaritmos,  Next: Trigonometría,  Prev: Constantes,  Up: Top

14 Logaritmos
*************

* Menu:

* Funciones y variables para logaritmos::


File: maxima.info,  Node: Funciones y variables para logaritmos,  Prev: Logaritmos,  Up: Logaritmos

14.1 Funciones y variables para logaritmos
==========================================

 -- Variable opcional: %e_to_numlog
     Valor por defecto: `false'

     Si `%e_to_numlog' vale `true', `r' es un número racional y `x' una
     expresión, `%e^(r*log(x))' se reduce a `x^r' .  Téngase en cuenta
     que la instrucción `radcan' también hace este tipo de
     transformaciones, así como otras más complicadas. La instrucción
     `logcontract' "contrae" expresiones que contienen algún `log'.


 -- Función: li [<s>] (<z>)
     Representa la función polilogarítmica de orden <s> y argumento <z>,
     definida por la serie infinita

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     `li [1]' es `- log (1 - z)'.  `li [2]' y `li [3]' son las
     funciones di- y trilogaritmo, respectivamente.

     Cuando el orden es 1, el polilogaritmo se simplifica a `- log (1 -
     z)', el cual a su vez se reduce a un valor numérico si <z> es un
     número real o complejo en coma flotante o si está presente el
     término `numer'.

     Cuando el orden es 2 ó 3, el polilogaritmo se reduce a un valor
     numérico si <z> es un número real en coma flotante o si está
     presente el término `numer'.

     Ejemplos:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]


 -- Función: log (<x>)
     Representa el logaritmo natural (en base e) de <x>.

     Maxima no tiene definida una función para el logaritmo de base 10 u
     otras bases. El usuario puede hacer uso de la definición `log10(x)
     := log(x) / log(10)'.

     La simplificación y evaluación de logaritmos se controla cciertas
     variables globales:

     `logexpand' - hace que `log(a^b)' se convierta en `b*log(a)'.  Si
     toma el valor `all', `log(a*b)' también se reducirá a
     `log(a)+log(b)'.  Si toma el valor `super', entonces `log(a/b)'
     también se reducirá a `log(a)-log(b)', siendo `a/b' racional y
     `a#1',  (la expresión `log(1/b)', para `b' entero, se simplifica
     siempre).  Si toma el valor  `false', se desactivarán todas estas
     simplificaciones.

     `logsimp' - si vale `false', entonces no se transforma `%e' a
     potencias que contengan logaritmos.

     `lognumer' - si vale `true', entonces los argumentos de `log' que
     sean números decimales negativos en coma flotante se convertirán
     siempre a su valor absoluto antes de aplicar `log'.  Si `numer'
     vale también `true', entonces los argumentos enteros negativos de
     `log' también se convertirán en su valor absoluto.

     `lognegint' - si vale `true' se aplica la regla `log(-n)' ->
     `log(n)+%i*%pi' siendo `n' un entero positivo.

     `%e_to_numlog' - si vale `true', `r' es un número racional y `x'
     una expresión, `%e^(r*log(x))' se reduce a `x^r' .  Téngase en
     cuenta que la instrucción `radcan' también hace este tipo de
     transformaciones, así como otras más complicadas. La instrucción
     `logcontract' "contrae" expresiones que contienen algún `log'.


 -- Variable opcional: logabs
     Valor por defecto: `false'

     Cuando se calculan integrales indefinidas en las que se generan
     logaritmos, como en `integrate(1/x,x)', el resultado se devuelve
     de la forma  `log(abs(...))' si `logabs' vale `true', o de la
     forma `log(...)' si `logabs' vale `false'. En la integración
     definida se hace la asignación `logabs:true', ya que aquí es
     normalmente necesario evaluar la integral indefinida en los
     extremos del intervalo de integración.


 -- Variable opcional: logarc
 -- Función: logarc (<expr>)
     Si la variable global `logarc' toma el valor `true', las funciones
     circulares e hiperbólicas inversas se reemplazan por funciones
     logarítmicas equivalentes.  El valor por defecto de `logarc' es
     `false'.

     La función `logarc(<expr>)' realiza la anterior transformación en
     la expresión <expr> sin necesidad de alterar el valor de la
     variable global `logarc'.


 -- Variable opcional: logconcoeffp
     Valor por defecto: `false'

     Controla qué coeficientes se contraen cuando se utiliza
     `logcontract'. Se le puede asignar el nombre de una función de
     predicado de un argumento; por ejemplo, si se quiere introducir
     raíces cuadradas, se puede hacer `logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$' .  Entonces
     `logcontract(1/2*log(x));' devolverá `log(sqrt(x))'.


 -- Función: logcontract (<expr>)
     Analiza la expresión <expr> recursivamente, transformando
     subexpresiones de la forma `a1*log(b1) + a2*log(b2) + c' en
     `log(ratsimp(b1^a1 * b2^a2)) + c'

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     Si se hace `declare(n,integer);' entonces
     `logcontract(2*a*n*log(x));' da `a*log(x^(2*n))'.  Los
     coeficientes que se contraen de esta manera son aquellos que como
     el 2 y el `n' satisfacen `featurep(coeff,integer)'. El usuario
     puede controlar qué coeficientes se contraen asignándole a la
     variable global `logconcoeffp' el nombre de una función de
     predicado de un argumento; por ejemplo, si se quiere introducir
     raíces cuadradas, se puede hacer `logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$' .  Entonces
     `logcontract(1/2*log(x));' devolverá `log(sqrt(x))'.


 -- Variable opcional: logexpand
     Valor por defecto: `true'

     Si `logexpand' vale `true' hace que `log(a^b)' se convierta en
     `b*log(a)'.  Si toma el valor `all', `log(a*b)' también se
     reducirá a  `log(a)+log(b)'.  Si toma el valor `super', entonces
     `log(a/b)' también se reducirá a `log(a)-log(b)', siendo `a/b'
     racional y `a#1',  (la expresión `log(1/b)', para `b' entero, se
     simplifica siempre).  Si toma el valor  `false', se desactivarán
     todas estas simplificaciones.


 -- Variable opcional: lognegint
     Valor por defecto: `false'

     Si `lognegint' vale `true' se aplica la regla `log(-n)' ->
     `log(n)+%i*%pi' siendo `n' un entero positivo.


 -- Variable opcional: lognumer
     Valor por defecto: `false'

     Si `lognumer' vale `true', entonces los argumentos de `log' que
     sean números decimales negativos en coma flotante se convertirán
     siempre a su valor absoluto antes de aplicar `log'.  Si `numer'
     vale también `true', entonces los argumentos enteros negativos de
     `log' también se convertirán en su valor absoluto.


 -- Variable opcional: logsimp
     Valor por defecto: `true'

     Si `logsimp' vale `false', entonces no se transforma `%e' a
     potencias que contengan logaritmos.


 -- Función: plog (<x>)
     Representa la rama principal del logaritmo natural complejo con
     `-%pi' < `carg(<x>)' <= `+%pi' .



File: maxima.info,  Node: Trigonometría,  Next: Funciones Especiales,  Prev: Logaritmos,  Up: Top

15 Trigonometría
****************

* Menu:

* Introducción a la trigonometría::
* Funciones y variables para trigonometría::


File: maxima.info,  Node: Introducción a la trigonometría,  Next: Funciones y variables para trigonometría,  Prev: Trigonometría,  Up: Trigonometría

15.1 Introducción a la trigonometría
====================================

Maxima reconoce muchas funciones trigonométricas. No están programadas
todas las identidades trigonométricas, pero el usuario puede añadir
muchas de ellas haciendo uso de las técnicas basadas en patrones.  Las
funciones trigonométricas definidas en Maxima son:  `acos', `acosh',
`acot', `acoth', `acsc', `acsch', `asec', `asech', `asin', `asinh',
`atan', `atanh', `cos', `cosh', `cot', `coth', `csc', `csch', `sec',
`sech', `sin', `sinh', `tan' y `tanh'. Hay también un determinado
número de instrucciones especiales para manipular funciones
trigonométricas;  véanse a este respecto `trigexpand', `trigreduce' y
la variable `trigsign'.  Dos paquetes adicionales amplían las reglas de
simplificación de Maxima, `ntrig' y `atrig1'.  Ejecútese
`describe(<command>)' para más detalles.


File: maxima.info,  Node: Funciones y variables para trigonometría,  Prev: Introducción a la trigonometría,  Up: Trigonometría

15.2 Funciones y variables para trigonometría
=============================================

 -- Variable opcional: %piargs
     Valor por defecto: `true'

     Cuando `%piargs' vale `true', las funciones trigonométricas se
     simplifican a constantes algebraicas cuando el argumento es
     múltiplo entero de %pi, %pi/2, %pi/3, %pi/4 o %pi/6.

     Maxima conoce algunas identidades aplicables cuando %pi, etc., se
     multiplican por una variable entera (esto es, un símbolo declarado
     como entero).

     Ejemplo:

          (%i1) %piargs : false$
          (%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          %pi       %pi
          (%o2)            [sin(%pi), sin(---), sin(---)]
                                           2         3
          (%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                %pi       %pi       %pi
          (%o3)            [sin(---), sin(---), sin(---)]
                                 4         5         6
          (%i4) %piargs : true$
          (%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          sqrt(3)
          (%o5)                    [0, 1, -------]
                                             2
          (%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                   1         %pi   1
          (%o6)                [-------, sin(---), -]
                                sqrt(2)       5    2
          (%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
                 cos (sqrt(2)*%pi/3)];
                          1    1               sqrt(2) %pi
          (%o7)          [-, - -, sqrt(3), cos(-----------)]
                          2    2                    3

     Se aplican ciertas identidades cuando %pi o %pi/2 se multiplican
     por una variable entera.

          (%i1) declare (n, integer, m, even)$
          (%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
                 cos (%pi/2 * m)];
                                                m/2
          (%o2)                  [0, 1, 0, (- 1)   ]


 -- Variable opcional: %iargs
     Valor por defecto: `true'

     Cuando `%iargs' vale `true', las funciones trigonométricas se
     simplifican a funciones hiperbólicas si el argumento es
     aparentemente un múltiplo de la unidad imaginaria %i.

     La simplificación se lleva a cabo incluso cuando el argumento es
     manifiestamente real; Maxima sólo se fija en si el argumento es un
     múltiplo literal de %i.

     Ejemplos:

          (%i1) %iargs : false$
          (%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o2)           [sin(%i x), cos(%i x), tan(%i x)]
          (%i3) %iargs : true$
          (%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o4)           [%i sinh(x), cosh(x), %i tanh(x)]

     La simplificación se aplica incluso en el caso de que el argumento
     se reduzca a un número real.

          (%i1) declare (x, imaginary)$
          (%i2) [featurep (x, imaginary), featurep (x, real)];
          (%o2)                     [true, false]
          (%i3) sin (%i * x);
          (%o3)                      %i sinh(x)


 -- Function: acos (<x>)
     Arco coseno.


 -- Función: acosh (<x>)
     Arco coseno hiperbólico.


 -- Función: acot (<x>)
     Arco cotangente.


 -- Función: acoth (<x>)
     Arco cotangente hiperbólica.


 -- Función: acsc (<x>)
     Arco cosecante.


 -- Función: acsch (<x>)
     Arco cosecante hiperbólica.


 -- Función: asec (<x>)
     Arco secante.


 -- Función: asech (<x>)
     Arco secante hiperbólica.


 -- Función: asin (<x>)
     Arco seno.


 -- Función: asinh (<x>)
     Arco seno hiperbólico.


 -- Función: atan (<x>)
     Arco tangente.


 -- Función: atan2 (<y>, <x>)
     Calcula el valor de `atan(<y>/<x>)' en el intervalo de `-%pi' a
     `%pi'.


 -- Función: atanh (<x>)
     Arco tangente hiperbólica.


 -- Paquete: atrig1
     El paquete `atrig1' contiene ciertas reglas de simplificación
     adicionales para las funciones trigonométricas inversas. Junto con
     las reglas que ya conoce Maxima, los siguientes ángulos están
     completamente implementados: `0', `%pi/6', `%pi/4', `%pi/3' y
     `%pi/2'.  Los ángulos correspondientes en los otros tres
     cuadrantes también están disponibles.  Para hacer uso de estas
     reglas, ejecútese `load(atrig1);'.


 -- Función: cos (<x>)
     Coseno.


 -- Función: cosh (<x>)
     Coseno hiperbólico.


 -- Función: cot (<x>)
     Cotangente.


 -- Función: coth (<x>)
     Cotangente hiperbólica.


 -- Función: csc (<x>)
     Cosecante.


 -- Función: csch (<x>)
     Cosecante hiperbólica.


 -- Variable opcional: halfangles
     Valor por defecto: `false'

     Si `halfangles' vale `true', las funciones trigonométricas con
     argumentos del tipo `<expr>/2' se simplifican a funciones con
     argumentos <expr>.

     Para un argumento real <x> en el intervalo `0 < x < 2*%pi' el seno
     del semiángulo se simplifica como

                              sqrt(1 - cos(x))
                              ----------------
                                  sqrt(2)

     Se necesita un factor relativamente complicado para que esta
     fórmula sea también válida para cualquier argumento complejo <z>:

                     realpart(z)
               floor(-----------)
                        2 %pi
          (- 1)                   (1 - unit_step(- imagpart(z))

                                realpart(z)            realpart(z)
                          floor(-----------) - ceiling(-----------)
                                   2 %pi                  2 %pi
                    ((- 1)                                          + 1))

     Maxima reconoce este factor y otros similares para las funciones
     `sin', `cos', `sinh' y `cosh'. Para valores especiales del
     argumento z, estos factores se simplifican de forma apropiada.

     Ejemplos:

          (%i1) halfangles:false;
          (%o1)                                false
          (%i2) sin(x/2);
                                                  x
          (%o2)                               sin(-)
                                                  2
          (%i3) halfangles:true;
          (%o3)                                true
          (%i4) sin(x/2);
                                                              x
                                                      floor(-----)
                                                            2 %pi
                                sqrt(1 - cos(x)) (- 1)
          (%o4)                 ----------------------------------
                                             sqrt(2)
          (%i5) assume(x>0, x<2*%pi)$
          (%i6) sin(x/2);
                                         sqrt(1 - cos(x))
          (%o6)                          ----------------
                                             sqrt(2)


 -- Paquete: ntrig
     El paquete `ntrig' contiene un conjunto de reglas de
     simplificación que se pueden usar para simplificar funciones
     trigonométricas cuyos argumentos son de la forma `<f>(<n> %pi/10)'
     donde <f> es cualquiera de las funciones `sin', `cos', `tan',
     `csc', `sec' o `cot'.


 -- Función: sec (<x>)
     Secante.


 -- Función: sech (<x>)
     Secante hiperbólica.


 -- Función: sin (<x>)
     Seno.


 -- Función: sinh (<x>)
     Seno hiperbólico.


 -- Función: tan (<x>)
     Tangente.


 -- Función: tanh (<x>)
     Tangente hiperbólica.


 -- Función: trigexpand (<expr>)
     Expande funciones trigonométricas e hiperbólicas de sumas de
     ángulos y de múltiplos de ángulos presentes en <expr>.  Para
     mejorar los resultados, <expr> debería expandirse. Para facilitar
     el control por parte del usuario de las simplificaciones, esta
     función tan solo expande un nivel de cada vez, expandiendo sumas
     de ángulos o de múltiplos de ángulos. A fin de obtener una
     expansión completa en senos y coseno, se le dará a la variable
     `trigexpand' el valor `true'.

     La función `trigexpand' está controlada por las siguientes
     variables:

    `trigexpand'
          Si vale `true', provoca la expansión de todas las expresiones
          que contengan senos y cosenos.

    `trigexpandplus'
          Controla la regla de la suma para `trigexpand', la expansión
          de una suma como `sin(x + y)' se llevará a cabo sólo si
          `trigexpandplus' vale `true'.

    `trigexpandtimes'
          Controla la regla del producto para `trigexpand', la
          expansión de un producto como `sin(2 x)' se llevará a cabo
          sólo si `trigexpandtimes' vale `true'.

     Ejemplos:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)


 -- Variable optativa: trigexpandplus
     Valor por defecto: `true'

     La variable `trigexpandplus' controla la regla de la suma para
     `trigexpand'.  Así, si la instrucción `trigexpand' se utiliza o si
     la variable `trigexpand' vale `true', se realizará la expansión de
     sumas como `sin(x+y)' sólo si `trigexpandplus' vale `true'.


 -- Variable optativa: trigexpandtimes
     Valor por defecto: `true'

     La variable `trigexpandtimes' controla la regla del producto para
     `trigexpand'.  Así, si la instrucción `trigexpand' se utiliza o si
     la variable `trigexpand' vale `true', se realizará la expansión de
     productos como `sin(2*x)' sólo si `trigexpandtimes' vale `true'.


 -- Variable optativa: triginverses
     Valor por defecto: `true'

     La variable `triginverses' controla la simplificación de la
     composición de funciones trigonométricas e hiperbólicas con sus
     funciones inversas.

     Si vale `all', tanto `atan(tan(<x>))'  como `tan(atan(<x>))' se
     reducen a <x>.

     Si vale `true', se desactiva la simplificación de
     `<arcfun>(<fun>(<x>))'.

     Si vale `false', se desactivan las simplificaciones de
     `<arcfun>(<fun>(<x>))' y `<fun>(<arcfun>(<x>))'.


 -- Función: trigreduce (<expr>, <x>)
 -- Función: trigreduce (<expr>)
     Combina productos y potencias de senos y cosenos trigonométricos e
     hiperbólicos de <x>, transformándolos en otros que son múltiplos
     de <x>.  También intenta eliminar estas funciones cuando aparecen
     en los denominadores.  Si no se introduce el argumento <x>,
     entonces se utilizan todas las variables de <expr>.

     Véase también `poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

     Las rutinas de simplificación trigonométrica utilizan información
     declarada en algunos casos sencillos. Las declaraciones sobre
     variables se utilizan como se indica a continuación:

          (%i1) declare(j, integer, e, even, o, odd)$
          (%i2) sin(x + (e + 1/2)*%pi);
          (%o2)                        cos(x)
          (%i3) sin(x + (o + 1/2)*%pi);
          (%o3)                       - cos(x)


 -- Variable optativa: trigsign
     Valor por defecto: `true'

     Si `trigsign' vale `true', se permite la simplificación de
     argumentos negativos en funciones trigonométricas, como en
     `sin(-x)', que se transformará en `-sin(x)' sólo si `trigsign'
     vale `true'.


 -- Función: trigsimp (<expr>)
     Utiliza las identidades sin(x)^2 + cos(x)^2 = 1 y cosh(x)^2 -
     sinh(x)^2 = 1 para simplificar expresiones que contienen `tan',
     `sec', etc., en expresiones con `sin', `cos', `sinh', `cosh'.

     Las funciones `trigreduce', `ratsimp' y `radcan' puden seguir
     siendo útiles para continuar el proceso de simplificación.

     La instrucción `demo ("trgsmp.dem")' muestra algunos ejemplos de
     `trigsimp'.


 -- Función: trigrat (<expr>)
     Devuelve una forma canónica simplificada cuasi-lineal de una
     expresión trigonométrica; <expr> es una fracción racional que
     contiene `sin', `cos' o `tan', cuyos argumentos son formas
     lineales respecto de ciertas variables (o kernels) y `%pi/<n>'
     (<n> entero) con coeficientes enteros. El resultado es una
     fracción simplificada con el numerador y denominador lineales
     respecto de `sin' y `cos'.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     El siguiente ejemplo se ha tomado de Davenport, Siret y Tournier,
     Calcul Formel, Masson (o en inglés, Addison-Wesley), sección
     1.5.5, teorema de Morley.

          (%i1) c : %pi/3 - a - b$
          (%i2) bc : sin(a)*sin(3*c)/sin(a+b);
                                                    %pi
                            sin(a) sin(3 (- b - a + ---))
                                                     3
          (%o2)             -----------------------------
                                     sin(b + a)
          (%i3) ba : bc, c=a, a=c;
                                                   %pi
                              sin(3 a) sin(b + a - ---)
                                                    3
          (%o3)               -------------------------
                                            %pi
                                    sin(a - ---)
                                             3
          (%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2         2         %pi
                sin (3 a) sin (b + a - ---)
                                        3
          (%o4) ---------------------------
                          2     %pi
                       sin (a - ---)
                                 3
                                                 %pi
           - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                                  3
                       %pi            %pi
           sin(b + a - ---))/(sin(a - ---) sin(b + a))
                        3              3
                2       2              %pi
             sin (a) sin (3 (- b - a + ---))
                                        3
           + -------------------------------
                          2
                       sin (b + a)
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
           - 9)/4



File: maxima.info,  Node: Funciones Especiales,  Next: Funciones elípticas,  Prev: Trigonometría,  Up: Top

16 Funciones Especiales
***********************

* Menu:

* Introducción a las funciones especiales::
* Funciones de Bessel::
* Funciones de Airy::
* Funciones Gamma y factorial::
* Integral exponencial::
* Función de error::
* Funciones de Struve::
* Funciones hipergeométricas::
* Funciones de cilindro parabólico::
* Funciones y variables para las funciones especiales::


File: maxima.info,  Node: Introducción a las funciones especiales,  Next: Funciones de Bessel,  Prev: Funciones Especiales,  Up: Funciones Especiales

16.1 Introducción a las funciones especiales
============================================

A continuación se especifican las notaciones correspondientes a las
funciones especiales:

     bessel_j (index, expr)    Función de Bessel de primera especie
     bessel_y (index, expr)    Función de Bessel de segunda especie
     bessel_i (index, expr)    Función de Bessel modificada de primera especie
     bessel_k (index, expr)    Función de Bessel modificada de segunda especie
     hankel_1 (v,z)            Función de Hankel de primera especie
     hankel_2 (v,z)            Función de Hankel de segunda especie
     struve_h (v,z)            Función H de Struve
     struve_l (v,z)            Función L de Struve
     %p[u,v] (z)               Función de Legendre de primera especie
     %q[u,v] (z)               Función de Legendre de segunda especie
     %f[p,q] ([], [], expr)    Función hipergeométrica generalizada
     gamma()                   Función Gamma
     gammagreek(a,z)           Función Gamma incompleta
     gammaincomplete(a,z)      Extremo de la función Gamma incompleta
     hypergeometric(l1, l2, z) Función hipergeométrica
     slommel
     %m[u,k] (z)               Función de Whittaker de primera especie
     %w[u,k] (z)               Función de Whittaker de segunda especie
     erfc (z)                  Complemento de la función de error, erf
     expintegral_e (v,z)       Integral exponencial E
     expintegral_e1 (z)        Integral exponencial E1
     expintegral_ei (z)        Integral exponencial Ei
     expintegral_li (z)        Integral logarítmica Li
     expintegral_si (z)        Integral exponencial Si
     expintegral_ci (z)        Integral exponencial Ci
     expintegral_shi (z)       Integral exponencial Shi
     expintegral_chi (z)       Integral exponencial Chi
     kelliptic (z)             Integral elíptica completa
                                       de primera especie (K)
     parabolic_cylinder_d(v,z) Función D de cilindro parabólico


File: maxima.info,  Node: Funciones de Bessel,  Next: Funciones de Airy,  Prev: Introducción a las funciones especiales,  Up: Funciones Especiales

16.2 Funciones de Bessel
========================

 -- Función: bessel_j (<v>, <z>)
     Función de Bessel de primera especie de orden v y argumento z.

     La función `bessel_j' se define como

                          inf
                          ====       k  - v - 2 k  v + 2 k
                          \     (- 1)  2          z
                           >    --------------------------
                          /        k! gamma(v + k + 1)
                          ====
                          k = 0

     aunque la serie infinita no se utiliza en los cálculos.


 -- Función: bessel_y (<v>, <z>)
     Función de Bessel de segunda especie de orden v y argumento z.

     La función `bessel_y' se define como

                        cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
                        -------------------------------------------
                                       sin(%pi v)

     si v no es un entero.  En caso de que  v sea un entero n, se
     calcula el límite cuando v se aproxima a n.


 -- Función: bessel_i (<v>, <z>)
     Función modificada de Bessel de primera especie de orden v y
     argumento z.

     La función `bessel_i' se define como

                              inf
                              ====   - v - 2 k  v + 2 k
                              \     2          z
                               >    -------------------
                              /     k! gamma(v + k + 1)
                              ====
                              k = 0

     aunque la serie infinita no se utiliza en los cálculos.


 -- Función: bessel_k (<v>, <z>)
     Función modificada de Bessel de segunda especie de orden v y
     argumento z.

     La función `bessel_k' se define como

                     %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
                     -------------------------------------------------
                                            2

     si v no es un entero.  Si v es igual al entero n, entonces se
     calcula el límite cuando v tiende a n.

 -- Función: hankel_1 (<v>, <z>)
     Función de Hankel de primera especie de orden v y argumento z (A&S
     9.1.3). La función `hankel_1' se define como

             bessel_j(v,z) + %i * bessel_y(v,z)

     Maxima evalúa `hankel_1' numéricamente para el orden real v y el
     argumento complejo z en doble precisión (float). La evaluación
     numérica en gran precisión (bigfloat) y para órdenes complejos no
     está implementada.

     Si `besselexpand' vale `true', `hankel_1' se expande en términos
     de funciones elementales cuando el orden v es la mitad de un
     entero impar. Véase al respecto `besselexpand'.

     Maxima reconoce la derivada de `hankel_1' con respecto del
     argumento z.

     Ejemplos:

     Evaluación numérica:

          (%i1) hankel_1(1,0.5);
          (%o1)              .2422684576748738 - 1.471472392670243 %i
          (%i2) hankel_1(1,0.5+%i);
          (%o2)             - .2558287994862166 %i - 0.239575601883016

     No se soportan órdenes complejos. Maxima devuelve una forma
     nominal:

          (%i3) hankel_1(%i,0.5+%i);
          (%o3)                       hankel_1(%i, %i + 0.5)

     Expansión de `hankel_1' cuando `besselexpand' vale `true':

          (%i4) hankel_1(1/2,z),besselexpand:true;
                                sqrt(2) sin(z) - sqrt(2) %i cos(z)
          (%o4)                 ----------------------------------
                                        sqrt(%pi) sqrt(z)

     Derivada de `hankel_1' respecto del argumento z. No está soportada
     la derivada respecto del orden v. Maxima devuelve una forma
     nominal:

          (%i5) diff(hankel_1(v,z),z);
                              hankel_1(v - 1, z) - hankel_1(v + 1, z)
          (%o5)               ---------------------------------------
                                                 2
          (%i6) diff(hankel_1(v,z),v);
                                       d
          (%o6)                        -- (hankel_1(v, z))
                                       dv


 -- Función: hankel_2 (<v>, <z>)
     Función de Hankel de segunda especie de orden v y argumento z (A&S
     9.1.4). La función `hankel_2' se define como

             bessel_j(v,z) - %i * bessel_y(v,z)

     Maxima evalúa `hankel_2' numéricamente para el orden real v y el
     argumento complejo z en doble precisión (float). La evaluación
     numérica en gran precisión (bigfloat) y para órdenes complejos no
     está implementada.

     Si `besselexpand' vale `true', `hankel_2' se expande en términos
     de funciones elementales cuando el orden v es la mitad de un
     entero impar. Véase al respecto `besselexpand'.

     Maxima reconoce la derivada de `hankel_2' con respecto del
     argumento z.

     Véanse ejemplos en `hankel_1'.


 -- Variable optativa: besselexpand
     Valor por defecto: `false'

     Controla la expansión de las funciones de Bessel cuando el orden
     es la mitad de un entero impar. En tal caso, las funciones de
     Bessel se pueden expandir en términos de otras funciones
     elementales.  Si `besselexpand' vale `true', se expande la función
     de Bessel.

          (%i1) besselexpand: false$
          (%i2) bessel_j (3/2, z);
                                              3
          (%o2)                      bessel_j(-, z)
                                              2
          (%i3) besselexpand: true$
          (%i4) bessel_j (3/2, z);
                                                  sin(z)   cos(z)
                                 sqrt(2) sqrt(z) (------ - ------)
                                                     2       z
                                                    z
          (%o4)                  ---------------------------------
                                             sqrt(%pi)


 -- Función: scaled_bessel_i (<v>, <z>)
     Es la función de Bessel modificada de primera especie de orden v y
     argumento z, es decir scaled_bessel_i(v,z) =
     exp(-abs(z))*bessel_i(v, z).  Esta función es especialmente útil
     para calcular bessel_i cuando z es grande. Sin embargo, Maxima no
     sabe mucho más sobre esta función. En cálculos simbólicos, quizás
     sea preferible trabajar directamente con la expresión
     `exp(-abs(z))*bessel_i(v, z)'.


 -- Función: scaled_bessel_i0 (<z>)
     Idéntica a `scaled_bessel_i(0,z)'.


 -- Función: scaled_bessel_i1 (<z>)
     Idéntica a `scaled_bessel_i(1,z)'.


 -- Función: %s [<u>,<v>] (<z>)
     Función s[u,v](z) de Lommel.  Gradshteyn & Ryzhik 8.570.1.



File: maxima.info,  Node: Funciones de Airy,  Next: Funciones Gamma y factorial,  Prev: Funciones de Bessel,  Up: Funciones Especiales

16.3 Funciones de Airy
======================

Las funciones de Airy Ai(x) y Bi(x) se definen en la sección 10.4.  de
Abramowitz and Stegun, Handbook of Mathematical Functions.

   `y = Ai(x)' y `y = Bi(x)' son dos soluciones linealmente
independientes de la ecuación diferencia de Airy `diff (y(x), x, 2) - x
y(x) = 0'.

   Si el argumento `x' es un número decimal en coma flotante real o
complejo, se devolverá el valor numérico de la función.

 -- Función: airy_ai (<x>)
     Función de Airy Ai(x).  (A&S 10.4.2)

     La derivada `diff (airy_ai(x), x)' es `airy_dai(x)'.

     Véanse `airy_bi', `airy_dai' y `airy_dbi'.

 -- Función: airy_dai (<x>)
     Es la derivada de la función Ai de Airy, `airy_ai(x)'.

     Véase `airy_ai'.

 -- Función: airy_bi (<x>)
     Es la función Bi de Airy, tal como la definen Abramowitz y Stegun,
     Handbook of Mathematical Functions, Sección 10.4. Se trata de la
     segunda solución de la ecuación de Airy `diff (y(x), x, 2) - x
     y(x) = 0'.

     Si el argumento `x' es un número decimal real o complejo, se
     devolverá el valor numérico de `airy_bi' siempre que sea posible.
     En los otros casos, se devuelve la expresión sin evaluar.

     La derivada `diff (airy_bi(x), x)' es `airy_dbi(x)'.

     Véanse `airy_ai' y `airy_dbi'.

 -- Función: airy_dbi (<x>)
     Es la derivada de la función Bi de Airy, `airy_bi(x)'.

     Véanse `airy_ai' y `airy_bi'.


File: maxima.info,  Node: Funciones Gamma y factorial,  Next: Integral exponencial,  Prev: Funciones de Airy,  Up: Funciones Especiales

16.4 Funciones Gamma y factorial
================================

Las funciones gamma, beta, psi y gamma incompleta están definidas en el
capítulo 6 de Abramowitz y Stegun, Handbook of Mathematical Functions.

 -- Función: gamma (<x>)
     La definición básica de la función gamma (A&S 6.1.1) es

                                         inf
                                        /
                                        [     z - 1   - t
                             gamma(z) = I    t      %e    dt
                                        ]
                                        /
                                         0

     Maxima simplifica `gamma' para enteros positivos y para fracciones
     positivas o negativas. Para fracciones de denominador dos, el
     resultado es un número racional multiplicado por `sqrt(%pi)'. La
     simplificación para valores enteros la controla `factlim'. Para
     enteros mayores que `factlim' el resultado numérico de la función
     factorial, la cual se utiliza para calcular `gamma', producirá un
     desbordamiento. La simplificación para números racionales la
     controla `gammalim' para evitar desbordamientos.  Véanse también
     `factlim' y `gammalim'.

     Para enteros negativos, `gamma' no está definida.

     Maxima puede evaluar `gamma' numéricamente para valores reales y
     complejos, tanto en formato float (doble precisión) como big float
     (precisión arbitraria).

     La función `gamma' tiene simetría especular.

     Si `gamma_expand' vale `true', Maxima expande `gamma' para
     argumentos del tipo `z+n' y `z-n', siendo `n' un entero.

     Maxima conoce la derivada de `gamma'.

     Ejemplos:

     Simplificación para enteros, fracciones de denominador dos y
     números racionales:

          (%i1) map('gamma,[1,2,3,4,5,6,7,8,9]);
          (%o1)               [1, 1, 2, 6, 24, 120, 720, 5040, 40320]

          (%i2) map('gamma,[1/2,3/2,5/2,7/2]);
                                     sqrt(%pi)  3 sqrt(%pi)  15 sqrt(%pi)
          (%o2)          [sqrt(%pi), ---------, -----------, ------------]
                                         2           4            8

          (%i3) map('gamma,[2/3,5/3,7/3]);
                                                  2           1
                                          2 gamma(-)  4 gamma(-)
                                      2           3           3
          (%o3)                [gamma(-), ----------, ----------]
                                      3       3           9

     Evaluación numérica para valores reales y complejos:

          (%i4) map('gamma,[2.5,2.5b0]);
          (%o4)             [1.329340388179137, 1.329340388179137b0]

          (%i5) map('gamma,[1.0+%i,1.0b0+%i]);
          (%o5) [.4980156681183558 - .1549498283018108 %i,
                                4.980156681183561b-1 - 1.549498283018107b-1 %i]

     Simetría especular:

          (%i8) declare(z,complex)$
          (%i9) conjugate(gamma(z));
          (%o9)                         gamma(conjugate(z))

     Maxima expande `gamma(z+n)' y `gamma(z-n)' si `gamma_expand' vale
     `true':

          (%i10) gamma_expand:true$
          (%i11) [gamma(z+1),gamma(z-1),gamma(z+2)/gamma(z+1)];
                                                gamma(z)
          (%o11)                   [z gamma(z), --------, z + 1]
                                                 z - 1

     Derivada de `gamma':

          (%i12) diff(gamma(z),z);
          (%o12)                         psi (z) gamma(z)
                                            0

     Véase también `makegamma'.

     La constante de Euler-Mascheroni es `%gamma'.

 -- Función: log_gamma (<z>)
     Logaritmo natural de la función gamma.

 -- Función: gamma_incomplete (<a>,<z>)
     Función gamma incompleta superior, A&S 6.5.2: gamma_incomplete(a,
     x) = integrate(exp(-t)*t^(a-1), t, 0, x)

 -- Función: gamma_incomplete_regularized (<a>,<z>)
     Función gamma incompleta superior regularizada, A&S 6.5.1.

     ` gamma_incomplete_regularized(a,z)=gamma_incomplete(a,z)/gamma(a)'

 -- Función: gamma_incomplete_generalized (<a>,<z1>,<z1>)
     Función gamma incompleta generalizada.

     ` gamma_incomplete_generalized(a,z) =  integrate(t^(a-1)*exp(-t),
     z, z1,z2) '

 -- Variable optativa: gammalim
     Valor por defecto: 1000000

     La variable `gammalim' controla la simplificación de la función
     gamma con argumentos enteros o racionales. Si el valor absoluto
     del argumento no es mayor que `gammalim', entonces se realizará la
     simplificación. Nótese que la variable `factlim' también controla
     la simplificación del resultado de `gamma' con argumento entero.


 -- Función: makegamma (<expr>)
     Transforma las funciones `binomial', `factorial' y `beta' que
     aparecen en <expr> en funciones `gamma'.

     Véase también `makefact'.


 -- Función: beta (<a>, <b>)
     La función beta se define como `gamma(a) gamma(b)/gamma(a+b)' (A&S
     6.2.1).

     Maxima simplifica la función beta para enteros positivos y números
     racionales cuya suma sea entera. Si `beta_args_sum_to_integer'
     vale `true', Maxima también simplifica expresiones generales cuya
     suma sea también entera.

     Cuando <a> o <b> sean nulos, la función beta no está definida.

     En general, la función beta no está definida para enteros
     negativos.  La excepción es para <a=-n>, siendo <n> un entero
     positivo y <b> otro entero positivo tal que <b<=n>, entonces es
     posible definir una continuación analítica. En este caso Maxima
     devuelve un resultado.

     Si `beta_expand' vale `true', expresiones como `beta(a+n,b)',
     `beta(a-n,b)', `beta(a,b+n)' o `beta(a,b-n)', siendo `n' entero,
     se simplifican.

     Maxima puede evaluar la función beta para valores reales y
     complejos, tanto de tipo decimal flotante o big float. Para la
     evaluación numérica Maxima utiliza `log_gamma':

                     - log_gamma(b + a) + log_gamma(b) + log_gamma(a)
                   %e

     Maxima reconoce la simetría de la función beta.

     Maxima conoce las derivadas de la función beta, tanto respecto de
     <a> como de <b>.

     Para expresar la función beta como un cociente de funciones gamma,
     véase `makegamma'.

     Ejemplos:

     Simplificación cuando uno de sus argumentos es entero:

          (%i1) [beta(2,3),beta(2,1/3),beta(2,a)];
                                         1   9      1
          (%o1)                         [--, -, ---------]
                                         12  4  a (a + 1)

     Simplificación para argumentos racionales que suman un entero:

          (%i2) [beta(1/2,5/2),beta(1/3,2/3),beta(1/4,3/4)];
                                    3 %pi   2 %pi
          (%o2)                    [-----, -------, sqrt(2) %pi]
                                      8    sqrt(3)

     Cuando se iguala `beta_args_sum_to_integer' a `true' se
     simplifican expresiones más generales si la suma de los argumentos
     se reduce a un entero:

          (%i3) beta_args_sum_to_integer:true$
          (%i4) beta(a+1,-a+2);
                                          %pi (a - 1) a
          (%o4)                         ------------------
                                        2 sin(%pi (2 - a))

     Posibles valores cuando uno de los argumentos es entero negativo:

          (%i5) [beta(-3,1),beta(-3,2),beta(-3,3)];
                                              1  1    1
          (%o5)                            [- -, -, - -]
                                              3  6    3

     `beta(a+n,b)' o `beta(a-n)' con `n' entero se simplifica si
     `beta_expand' vale `true':

          (%i6) beta_expand:true$
          (%i7) [beta(a+1,b),beta(a-1,b),beta(a+1,b)/beta(a,b+1)];
                              a beta(a, b)  beta(a, b) (b + a - 1)  a
          (%o7)              [------------, ----------------------, -]
                                 b + a              a - 1           b

     La función beta no está definida si uno de sus argumentos es cero:

          (%i7) beta(0,b);
          beta: expected nonzero arguments; found 0, b
           -- an error.  To debug this try debugmode(true);

     Evaluación numérica para argumentos reales y complejos de tipo
     decimal flotante o big float:

          (%i8) beta(2.5,2.3);
          (%o8) .08694748611299981

          (%i9) beta(2.5,1.4+%i);
          (%o9) 0.0640144950796695 - .1502078053286415 %i

          (%i10) beta(2.5b0,2.3b0);
          (%o10) 8.694748611299969b-2

          (%i11) beta(2.5b0,1.4b0+%i);
          (%o11) 6.401449507966944b-2 - 1.502078053286415b-1 %i

     La función beta es simétrica con simetría especular:

          (%i14) beta(a,b)-beta(b,a);
          (%o14)                                 0
          (%i15) declare(a,complex,b,complex)$
          (%i16) conjugate(beta(a,b));
          (%o16)                 beta(conjugate(a), conjugate(b))

     Derivada de la función beta respecto de `a':

          (%i17) diff(beta(a,b),a);
          (%o17)               - beta(a, b) (psi (b + a) - psi (a))
                                                0             0

 -- Función: beta_incomplete (<a>, <b>, <z>)
     La definición básica de la función beta incompleta (A&S 6.6.1) es

                                 z
                                /
                                [         b - 1  a - 1
                                I  (1 - t)      t      dt
                                ]
                                /
                                 0

     Esta definición es posible para realpart(a)>0, realpart(b)>0 y
     abs(z)<1. Para otras situaciones, la función beta incompleta puede
     definirse por medio de una función hipergeométrica generalizada:

             gamma(a) hypergeometric_generalized([a, 1 - b], [a + 1], z) z
     (Véase Funcións.wolfram.com para una completa definición de la
     función beta incompleta.)

     Para enteros negativos a = -n y enteros positivos b=m con m<=n la
     función beta incompleta se define como

                                      m - 1           k
                                      ====  (1 - m)  z
                                n - 1 \            k
                               z       >    -----------
                                      /     k! (n - k)
                                      ====
                                      k = 0
     Maxima utiliza esta definición para simplificar `beta_incomplete'
     cuando <a> es entero negativo.

     Cuando <a> es entero positivo, `beta_incomplete' se simplifica
     para cualesquiera argumentos <b> y <z>, y para <b> entero positivo
     para cualesquiera argumentos <a> y <z>, con la excepción de cuando
     <a> sea entero negativo.

     Para z=0 y realpart(a)>0, `beta_incomplete' se anula.  Para <z=1>
     y realpart(b)>0, `beta_incomplete' se reduce a la función
     `beta(a,b)'.

     Maxima evalúa `beta_incomplete' numéricamente para valores reales
     y complejos en forma decimal y big float. La evaluación numérica se
     realiza expandiendo la función beta incompleta en fracciones
     continuas.

     Si `beta_expand' vale `true', Maxima expande las expresiones
     `beta_incomplete(a+n,b,z)' y `beta_incomplete(a-n,b,z)', siendo
     <n> entero positivo.

     Maxima conoce las derivadas de `beta_incomplete' con respecto a
     las variables <a>, <b> y <z>, así como la integral respecto de la
     variable <z>.

     Ejemplos:

     Simplificación para <a> entero positivo:

          (%i1) beta_incomplete(2,b,z);
                                                 b
                                      1 - (1 - z)  (b z + 1)
          (%o1)                       ----------------------
                                            b (b + 1)

     Simplificación para <b> entero positivo:

          (%i2) beta_incomplete(a,2,z);
                                                         a
                                        (a (1 - z) + 1) z
          (%o2)                         ------------------
                                            a (a + 1)

     Simplificación para <a> y <b> enteros positivos:

          (%i3) beta_incomplete(3,2,z);
                                                         3
                                        (3 (1 - z) + 1) z
          (%o3)                         ------------------
                                                12

     Para <a> entero negativo y b<=(-a):

          (%i4) beta_incomplete(-3,1,z);
                                                 1
          (%o4)                              - ----
                                                  3
                                               3 z

     Simplificación para los valores z=0 y z=1:

          (%i5) assume(a>0,b>0)$
          (%i6) beta_incomplete(a,b,0);
          (%o6)                                 0
          (%i7) beta_incomplete(a,b,1);
          (%o7)                            beta(a, b)

     Evaluación numérica, tanto con float (precisión doble) como big
     float (precisión arbitraria):

          (%i8) beta_incomplete(0.25,0.50,0.9);
          (%o8)                          4.594959440269333
          (%i9)  fpprec:25$
          (%i10) beta_incomplete(0.25,0.50,0.9b0);
          (%o10)                    4.594959440269324086971203b0

     Para abs(z)>1, `beta_incomplete' devuelve un resultado complejo:

          (%i11) beta_incomplete(0.25,0.50,1.7);
          (%o11)              5.244115108584249 - 1.45518047787844 %i

     Resultados para argumentos complejos más generales:

          (%i14) beta_incomplete(0.25+%i,1.0+%i,1.7+%i);
          (%o14)             2.726960675662536 - .3831175704269199 %i
          (%i15) beta_incomplete(1/2,5/4*%i,2.8+%i);
          (%o15)             13.04649635168716 %i - 5.802067956270001
          (%i16)

     Expansión cuando `beta_expand' vale `true':

          (%i23) beta_incomplete(a+1,b,z),beta_expand:true;
                                                                 b  a
                             a beta_incomplete(a, b, z)   (1 - z)  z
          (%o23)             -------------------------- - -----------
                                       b + a                 b + a

          (%i24) beta_incomplete(a-1,b,z),beta_expand:true;
                                                                     b  a - 1
                     beta_incomplete(a, b, z) (- b - a + 1)   (1 - z)  z
          (%o24)     -------------------------------------- - ---------------
                                     1 - a                         1 - a

     Derivada e integral de `beta_incomplete':

          (%i34) diff(beta_incomplete(a,b,z),z);
                                               b - 1  a - 1
          (%o34)                        (1 - z)      z
          (%i35) integrate(beta_incomplete(a,b,z),z);
          (%o35)     beta_incomplete(a, b, z) z - beta_incomplete(a + 1, b, z)
          (%i36) diff(%,z);
          (%o36)                     beta_incomplete(a, b, z)

 -- Función: beta_incomplete_regularized (<a>, <b>, <z>)
     Función beta incompleta regularizada A&S 6.6.2, definida como
     `beta_incomplete(a,b,z)/beta(a,b)'.

     Al igual que `beta_incomplete', esta definición no es completa.
     Véase Funcións.wolfram.com para una definición completa de
     `beta_incomplete_regularized'.

     `beta_incomplete_regularized' se simplifica para <a> o <b> entero
     positivo.

     Para z=0 y realpart(a)>0, `beta_incomplete_regularized' se anula.
     Para <z=1> y realpart(b)>0, `beta_incomplete_regularized' se
     reduce a 1.

     Maxima evalúa `beta_incomplete_regularized' numéricamente para
     valores reales y complejos en forma decimal y big float.

     Si `beta_expand' vale `true', Maxima expande
     `beta_incomplete_regularized' para los argumentos a+n o a-n,
     siendo <n> entero.

     Maxima conoce las derivadas de `beta_incomplete_regularized' con
     respecto a las variables <a>, <b> y <z>, así como la integral
     respecto de la variable <z>.

     Ejemplos:

     Simplificación para <a> o <b> enteros positivos:

          (%i1) beta_incomplete_regularized(2,b,z);
                                                 b
          (%o1)                       1 - (1 - z)  (b z + 1)

          (%i2) beta_incomplete_regularized(a,2,z);
                                                         a
          (%o2)                         (a (1 - z) + 1) z

          (%i3) beta_incomplete_regularized(3,2,z);
                                                         3
          (%o3)                         (3 (1 - z) + 1) z

     Simplificación para los valores z=0 y z=1:

          (%i4) assume(a>0,b>0)$
          (%i5) beta_incomplete_regularized(a,b,0);
          (%o5)                                 0
          (%i6) beta_incomplete_regularized(a,b,1);
          (%o6)                                 1

     Evaluación numérica, tanto con float (precisión doble) como big
     float (precisión arbitraria):

          (%i7) beta_incomplete_regularized(0.12,0.43,0.9);
          (%o7)                         .9114011367359802
          (%i8) fpprec:32$
          (%i9) beta_incomplete_regularized(0.12,0.43,0.9b0);
          (%o9)               9.1140113673598075519946998779975b-1
          (%i10) beta_incomplete_regularized(1+%i,3/3,1.5*%i);
          (%o10)             .2865367499935403 %i - 0.122995963334684
          (%i11) fpprec:20$
          (%i12) beta_incomplete_regularized(1+%i,3/3,1.5b0*%i);
          (%o12)      2.8653674999354036142b-1 %i - 1.2299596333468400163b-1

     Expansión cuando `beta_expand' vale `true':

          (%i13) beta_incomplete_regularized(a+1,b,z);
                                                                      b  a
                                                               (1 - z)  z
          (%o13)        beta_incomplete_regularized(a, b, z) - ------------
                                                               a beta(a, b)
          (%i14) beta_incomplete_regularized(a-1,b,z);
                                                                    b  a - 1
                                                             (1 - z)  z
          (%o14)   beta_incomplete_regularized(a, b, z) - ----------------------
                                                          beta(a, b) (b + a - 1)

     Derivada e integral respecto de <z>:

          (%i15) diff(beta_incomplete_regularized(a,b,z),z);
                                               b - 1  a - 1
                                        (1 - z)      z
          (%o15)                        -------------------
                                            beta(a, b)

          (%i16) integrate(beta_incomplete_regularized(a,b,z),z);
          (%o16) beta_incomplete_regularized(a, b, z) z
                                     a beta_incomplete_regularized(a + 1, b, z)
                                   - ------------------------------------------
                                                       b + a


 -- Función: beta_incomplete_generalized (<a>, <b>, <z1>, <z2>)
     La definición básica de la función beta incompleta generalizada es

     The basic definition of the generalized incomplete beta function is

                                z2
                               /
                               [          b - 1  a - 1
                               I   (1 - t)      t      dt
                               ]
                               /
                                z1

     Maxima simplifica `beta_incomplete_regularized' para <a> y <b>
     enteros positivos.

     Para realpart(a)>0 y z1=0 o z2=0, Maxima reduce
     `beta_incomplete_generalized' a `beta_incomplete'. Para
     realpart(b)>0 y z1=1 o <z2=1>, Maxima reduce a una expresión con
     `beta' y `beta_incomplete'.

     Maxima evalúa `beta_incomplete_generalized' numéricamente para
     valores reales y complejos en forma decimal y big float.

     Si `beta_expand' vale `true', Maxima expande
     `beta_incomplete_generalized' para los argumentos a+n y a-n,
     siendo <n> entero positivo.

     Maxima conoce las derivadas de `beta_incomplete_generalized' con
     respecto a las variables <a>, <b>, <z1> y <z2>, así como la
     integral respecto de las variables <z1> y <z2>.

     Ejemplos:

     Maxima simplifica `beta_incomplete_generalized' para <a> y <b>
     enteros positivos:
          (%i1) beta_incomplete_generalized(2,b,z1,z2);
                                    b                      b
                            (1 - z1)  (b z1 + 1) - (1 - z2)  (b z2 + 1)
          (%o1)             -------------------------------------------
                                             b (b + 1)

          (%i2) beta_incomplete_generalized(a,2,z1,z2);
                                               a                      a
                            (a (1 - z2) + 1) z2  - (a (1 - z1) + 1) z1
          (%o2)             -------------------------------------------
                                             a (a + 1)

          (%i3) beta_incomplete_generalized(3,2,z1,z2);
                            2      2                       2      2
                    (1 - z1)  (3 z1  + 2 z1 + 1) - (1 - z2)  (3 z2  + 2 z2 + 1)
          (%o3)     -----------------------------------------------------------
                                                12

     Simplificación para los valores z1=0, z2=0, z1=1 o z2=1:
          (%i4) assume(a > 0, b > 0)$
          (%i5) beta_incomplete_generalized(a,b,z1,0);
          (%o5)                    - beta_incomplete(a, b, z1)

          (%i6) beta_incomplete_generalized(a,b,0,z2);
          (%o6)                    - beta_incomplete(a, b, z2)

          (%i7) beta_incomplete_generalized(a,b,z1,1);
          (%o7)              beta(a, b) - beta_incomplete(a, b, z1)

          (%i8) beta_incomplete_generalized(a,b,1,z2);
          (%o8)              beta_incomplete(a, b, z2) - beta(a, b)

     Evaluación numérica para argumentos reales, tanto con float
     (precisión doble) como big float (precisión arbitraria):
          (%i9) beta_incomplete_generalized(1/2,3/2,0.25,0.31);
          (%o9)                        .09638178086368676

          (%i10) fpprec:32$
          (%i10) beta_incomplete_generalized(1/2,3/2,0.25,0.31b0);
          (%o10)               9.6381780863686935309170054689964b-2

     Evaluación numérica para argumentos complejos, tanto con float
     (precisión doble) como big float (precisión arbitraria):
          (%i11) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31);
          (%o11)           - .09625463003205376 %i - .003323847735353769
          (%i12) fpprec:20$
          (%i13) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31b0);
          (%o13)     - 9.6254630032054178691b-2 %i - 3.3238477353543591914b-3

     Expansión para a+n o a-n, siendo <n> entero positivo con
     `beta_expand' igual `true':
          (%i14) beta_expand:true$
          (%i15) beta_incomplete_generalized(a+1,b,z1,z2);
                         b   a           b   a
                 (1 - z1)  z1  - (1 - z2)  z2
          (%o15) -----------------------------
                             b + a
                                      a beta_incomplete_generalized(a, b, z1, z2)
                                    + -------------------------------------------
                                                         b + a

          (%i16) beta_incomplete_generalized(a-1,b,z1,z2);
                 beta_incomplete_generalized(a, b, z1, z2) (- b - a + 1)
          (%o16) -------------------------------------------------------
                                          1 - a
                                                    b   a - 1           b   a - 1
                                            (1 - z2)  z2      - (1 - z1)  z1
                                          - -------------------------------------
                                                            1 - a

     Derivada respecto de la variable <z1> e integrales respecto de
     <z1> y <z2>:
          (%i17) diff(beta_incomplete_generalized(a,b,z1,z2),z1);
                                                b - 1   a - 1
          (%o17)                      - (1 - z1)      z1

          (%i18) integrate(beta_incomplete_generalized(a,b,z1,z2),z1);
          (%o18) beta_incomplete_generalized(a, b, z1, z2) z1
                                                  + beta_incomplete(a + 1, b, z1)

          (%i19) integrate(beta_incomplete_generalized(a,b,z1,z2),z2);
          (%o19) beta_incomplete_generalized(a, b, z1, z2) z2
                                                  - beta_incomplete(a + 1, b, z2)

 -- Variable opcional: beta_expand
     Valor por defecto: false

     Si `beta_expand' vale `true', `beta(a,b)' y sus funciones
     relacionadas se expanden para argumentos del tipo a+n o a-n,
     siendo n un número entero.

 -- Variable opcional: beta_args_sum_to_integer
     Valor por defecto: false

     Si `beta_args_sum_to_integer' vale `true', Maxima simplifica
     `beta(a,b)' cuando la suma de los argumentos <a> y <b> sea un
     entero.

 -- Función: psi [<n>](<x>)
     Es la derivada de `log (gamma (<x>))' de orden `<n>+1', de tal
     manera que `psi[0](<x>)' es la primera derivada, `psi[1](<x>)' la
     segunda derivada y así sucesivamente.

     En general, Maxima no sabe cómo calcular valores numéricos de
     `psi', pero sí conoce el valor exacto para algunos argumentos
     racionales.  Existen algunas variables globales para controlar en
     qué rangos racionales debe devolver `psi' resultados exactos, si
     ello es posible.  Véanse las descripciones de `maxpsiposint',
     `maxpsinegint', `maxpsifracnum' y `maxpsifracdenom'.  En resumen,
     <x> debe alcanzar un valor entre `maxpsinegint' y `maxpsiposint'.
     Si el valor absoluto de la parte fraccional de <x> es racional y
     tiene un numerador menor que `maxpsifracnum' y un denominador
     menor que `maxpsifracdenom', la función `psi' devolverá un valor
     exacto.

     La función `bfpsi' del paquete `bffac' puede calcular valores
     numéricos.


 -- Variable opcional: maxpsiposint
     Valor por defecto: 20

     La variable `maxpsiposint' guarda el mayor valor positivo para el
     que `psi[n](x)' intentará calcular un valor exacto.


 -- Variable opcional: maxpsinegint
     Valor por defecto: -10

     La variable `maxpsinegint' guarda el menor valor negativo para el
     que `psi[n](x)' intentará calcular un valor exacto. Si <x> es
     menor que `maxnegint', `psi[n](<x>)' no devolverá una respuesta
     simplificada, aunque supiese cómo hacerlo.


 -- Variable opcional: maxpsifracnum
     Valor por defecto: 6

     Sea <x> un número racional menor que la unidad de la forma `p/q'.
     Si `p' es mayor que `maxpsifracnum', entonces `psi[<n>](<x>)' no
     devolverá una respuesta simplificada.


 -- Variable opcional: maxpsifracdenom
     Valor por defecto: 6

     Sea <x> un número racional menor que la unidad de la forma `p/q'.
     Si `q' es mayor que `maxpsifracnum', entonces `psi[<n>](<x>)' no
     devolverá una respuesta simplificada.


 -- Función: makefact (<expr>)
     Transforma las funciones `binomial', `gamma' y `beta' que aparecen
     en <expr> en su notación factorial.

     Véase también `makegamma'.


 -- Función: numfactor (<expr>)
     Devuelve el factor numérico que multiplica a la expresión <expr>,
     la cual debe tener un único término.

          (%i1) gamma (7/2);
                                    15 sqrt(%pi)
          (%o1)                     ------------
                                         8
          (%i2) numfactor (%);
                                         15
          (%o2)                          --
                                         8



File: maxima.info,  Node: Integral exponencial,  Next: Función de error,  Prev: Funciones Gamma y factorial,  Up: Funciones Especiales

16.5 Integral exponencial
=========================

La integral exponencial y sus funciones relacionadas se definen en el
capítulo 5 de Abramowitz y Stegun, Handbook of Mathematical Functions.

 -- Función: expintegral_e1 (<z>)
     La integral exponencial E1(z) (A&S 5.1.1)

 -- Función: expintegral_ei (<z>)
     La integral exponencial Ei(z) (A&S 5.1.2)

 -- Función: expintegral_li (<n>,<z>)
     La integral exponencial Li(z)  (A&S 5.1.3)

 -- Función: expintegral_e (<n>,<z>)
     La integral exponencial En(z)  (A&S 5.1.4)

 -- Función: expintegral_si (<z>)
     La integral exponencial Si(z) (A&S 5.2.1)

 -- Función: expintegral_ci (<z>)
     La integral exponencial Ci(z) (A&S 5.2.2)

 -- Función: expintegral_shi (<z>)
     La integral exponencial Shi(z) (A&S 5.2.3)

 -- Función: expintegral_chi (<z>)
     La integral exponencial Chi(z) (A&S 5.2.4)

 -- Option variable: expintrep
     Valor por defecto: false

     Transforma la representación de la integral exponencial en
     términos de las funciones `gamma_incomplete', `expintegral_e1',
     `expintegral_ei', `expintegral_li', `expintegral_trig' y
     `expintegral_hyp'.

 -- Option variable: expintexpand
     Valor por defecto: false

     Expande la integral exponencial E[n](z) para valores medios de la
     integral en términos de las funciones Erfc o Erf y para positivos
     enteros en términos de Ei .


File: maxima.info,  Node: Función de error,  Next: Funciones de Struve,  Prev: Integral exponencial,  Up: Funciones Especiales

16.6 Función de error
=====================

La función de error y sus asociadas se definen en el capítulo 7 de
Abramowitz y Stegun, Handbook of Mathematical Functions.

 -- Función: erf (<z>)
     Función de error erf(z) (A&S 7.1.1)

     Véase también `erfflag'.

 -- Función: erfc (<z>)
     Complemento de la función de error erfc(z) (A&S 7.1.2)

     `erfc(z) = 1-erf(z)'

 -- Función: erfi (<z>)
     Función de error imaginaria.

     `erfi(z) = -%i*erf(%i*z)'

 -- Función: erf_generalized (<z1>,<z2>)
     Función de error generalizada Erf(z1,z2)

 -- Función: fresnel_c (<z>)
     Integral de Fresnel C(z) = integrate(cos((%pi/2)*t^2),t,0,z). (A&S
     7.3.1)

     La simplificación fresnel_c(-x) = -fresnel_c(x) se aplica cuando
     la variable global `trigsign' vale `true'.

     La simplificación fresnel_c(%i*x) =  %i*fresnel_c(x) se aplica
     cuando la variable global `%iargs' vale `true'.

     Véanse también `erf_representation' y
     `hypergeometric_representation'.

 -- Función: fresnel_s (<z>)
     Integral de Fresnel S(z) = integrate(sin((%pi/2)*t^2),t,0,z). (A&S
     7.3.2)

     La simplificación fresnel_s(-x) = -fresnel_s(x) se aplica cuando
     la variable global `trigsign' vale `true'.

     La simplificación fresnel_s(%i*x) =  %i*fresnel_s(x) se aplica
     cuando la variable global `%iargs' vale `true'.

     Véanse también `erf_representation' y
     `hypergeometric_representation'.

 -- Variable opcional: erf_representation
     Valor por defecto: false

     Cuando valga `true' erfc, erfi, erf_generalized, fresnel_s y
     fresnel_c se transforman a erf.

 -- Variable opcional: hypergeometric_representation
     Valor por defecto: false

     Permite obtener la representación hipergeométrica de las funciones
     fresnel_s y fresnel_c.


File: maxima.info,  Node: Funciones de Struve,  Next: Funciones hipergeométricas,  Prev: Función de error,  Up: Funciones Especiales

16.7 Funciones de Struve
========================

Las funciones de Struve se definen en el capítulo 12 de Abramowitz y
Stegun, Handbook of Mathematical Functions.

 -- Función: struve_h (<v>, <z>)
     Función H de Struve de orden <v> y argumento <z>, (A&S 12.1.1).


 -- Función: struve_l (<v>, <z>)
     Función L modificada de Struve de orden <v> y argumento <z>, (A&S
     12.2.1).



File: maxima.info,  Node: Funciones hipergeométricas,  Next: Funciones de cilindro parabólico,  Prev: Funciones de Struve,  Up: Funciones Especiales

16.8 Funciones hipergeométricas
===============================

Las funciones hipergeométricas se definen en los capítulos 13 y 15 de
Abramowitz y Stegun, Handbook of Mathematical Functions.

   Maxima tiene un soporte limitado sobre estas funciones, que pueden
aparecer en resultados devueltos por `hgfred'.

 -- Función: %m [<k>,<u>] (<z>)
     Función M de Whittaker `M[k,u](z) =
     exp(-z/2)*z^(1/2+u)*M(1/2+u-k,1+2*u,z)'.  (A&S 13.1.32)

 -- Función: %w [<k>,<u>] (<z>)
     Función W de Whittaker.  (A&S 13.1.33)

 -- Función: %f [<p>,<q>] (<[a],[b],z>)
     Es la función hipergeométrica pFq(a1,a2,..ap;b1,b2,..bq;z), donde
     `a' es una lista de longitud `p' y `b' otra lista de longitud `q'.

 -- Función: hypergeometric ([<a1>, ..., <ap>],[<b1>, ... ,<bq>], x)
     Es la función hipergeométrica. A diferencia de la función
     hipergeométrica `%f' de Maxima, la función `hypergeometric' es
     simplificadora; además, `hypergeometric' soporta la evaluación en
     doble (float) y gran (bigfloat) precisión. La evaluación numérica
     fuera del círculo unidad no está en general soportada, pero sí en
     el caso de la función hipergeométrica de Gauss, cuando p = 2 y q =
     1.

     Si la variable opcional `expand_hypergeometric' vale `true', (el
     valor por defecto es `false') y uno de los argumentos entr `a1' y
     `ap' es entero negativo (caso polinomial), entonces
     `hypergeometric' devuelve un polinomio expandido.

     Ejemplos:
           (%i1)  hypergeometric([],[],x);
           (%o1) %e^x

     Los polinomios se expanden automáticamente cuando
     `expand_hypergeometric' vale `true'.

           (%i2) hypergeometric([-3],[7],x);
           (%o2) hypergeometric([-3],[7],x)

           (%i3) hypergeometric([-3],[7],x), expand_hypergeometric : true;
           (%o3) -x^3/504+3*x^2/56-3*x/7+1

     Se soporta la evaluación en doble (float) y gran (bigfloat)
     precisión:

           (%i4) hypergeometric([5.1],[7.1 + %i],0.42);
           (%o4) 1.346250786375334-0.0559061414208204*%i

           (%i5) hypergeometric([5,6],[8], 5.7 - %i);
           (%o5) 0.00737582400977495-0.00104981368857867*%i

           (%i6) hypergeometric([5,6],[8], 5.7b0 - %i), fpprec : 30;
           (%o6) 7.37582400977494674506442010824b-3-1.04981368857867315858055393376b-3*%i


File: maxima.info,  Node: Funciones de cilindro parabólico,  Next: Funciones y variables para las funciones especiales,  Prev: Funciones hipergeométricas,  Up: Funciones Especiales

16.9 Funciones de cilindro parabólico
=====================================

Las funciones de cilindro parabólico se definen en el capítulo 19 de
Abramowitz y Stegun, Handbook of Mathematical Functions.

   Maxima tiene un soporte limitado sobre estas funciones, que pueden
aparecer en resultados devueltos por `hgfred'.

 -- Función: parabolic_cylinder_d (<v>, <z>)
     Función de cilindro parabólico `parabolic_cylinder_d(v,z)'. (A&s
     19.3.1)


File: maxima.info,  Node: Funciones y variables para las funciones especiales,  Prev: Funciones de cilindro parabólico,  Up: Funciones Especiales

16.10 Funciones y variables para las funciones especiales
=========================================================

 -- Función: specint (exp(- s*<t>) * <expr>, <t>)
     Calcula la transformada de Laplace de <expr> respecto de la
     variable <t>. El integrando <expr> puede contener funciones
     especiales.

     La función `specint' admite las funciones especiales siguientes:
     la gamma incompleta, las funciones de error (pero no `erfi', siendo
     sencillo transformar `erfi' en la función de error `erf'),
     integrales exponenciales, funciones de Bessel (incluidos productos
     de funciones de Bessel), funciones de Hankel, de Hermite y los
     polinomios de Laguerre.

     Además, `specint' también admite la función hipergeométrica
     `%f[p,q]([],[],z)', la función de Whittaker de primera especie
     `%m[u,k](z)' y la de segunda especie `%w[u,k](z)'.

     El resultado puede darse en términos de funciones especiales y es
     posible que incluya también funciones hipergeométricas sin
     simplificar.

     Cuando `laplace' es incapaz de calcular la transformada de Laplace,
     entonces llama a la función `specint'. Puesto que `laplace' tiene
     programadas más reglas para calcular transformadas de Laplace, es
     preferible utilizar `laplace' en lugar de `specint'.

     La ejecución de `demo(hypgeo)' muestra algunos ejemplos de
     transformadas de Laplace calculadas con `specint'.

     Ejemplos:

          (%i1) assume (p > 0, a > 0)$
          (%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                                     sqrt(%pi)
          (%o2)                     ------------
                                           a 3/2
                                    2 (p + -)
                                           4
          (%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
                        * exp(-p*t), t);
                                             - a/p
                                   sqrt(a) %e
          (%o3)                    ---------------
                                          2
                                         p

     Ejemplos para integrales exponenciales:

          (%i4) assume(s>0,a>0,s-a>0)$
          (%i5) ratsimp(specint(%e^(a*t)*(log(a)+expintegral_e1(a*t))*%e^(-s*t),t));
                                              log(s)
          (%o5)                               ------
                                              s - a

          (%i6) logarc:true$
          (%i7) gamma_expand:true$
          (%i8) radcan(specint((cos(t)*expintegral_si(t)
                               -sin(t)*expintegral_ci(t))*%e^(-s*t),t));
                                              log(s)
          (%o8)                               ------
                                               2
                                              s  + 1

          (%i9) ratsimp(specint((2*t*log(a)+2/a*sin(a*t)
                                -2*t*expintegral_ci(a*t))*%e^(-s*t),t));
                                                2    2
                                           log(s  + a )
          (%o9)                            ------------
                                                 2
                                                s

     Resultados cuando se utiliza la expansión de `gamma_incomplete' y
     se cambia la representación de `expintegral_e1':

          (%i10) assume(s>0)$
          (%i11) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                                      1
                                      gamma_incomplete(-, k s)
                                                      2
          (%o11)                      ------------------------
                                         sqrt(%pi) sqrt(s)

          (%i12) gamma_expand:true$
          (%i13) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                        erfc(sqrt(k) sqrt(s))
          (%o13)                        ---------------------
                                               sqrt(s)

          (%i14) expintrep:expintegral_e1$
          (%i15) ratsimp(specint(1/(t+a)^2*%e^(-s*t),t));
                                        a s
                                  a s %e    expintegral_e1(a s) - 1
          (%o15)                - ---------------------------------
                                                  a

 -- Función: hgfred (<a>, <b>, <t>)
     Simplifica la función hipergeométrica generalizada en términos de
     otras funciones más sencillas. <a> es una lista de parámetros del
     numerador y <b> lo es de parámetros del denominador.

     En caso de que `hgfred' no pueda simplificar la función
     hipergeométrica devolverá una expresión de la forma `%f[p,q]([a],
     [b], x)', siendo <p> el número de elementos de <a> y <q> el de
     <b>. Esta es la función hipergeométrica generalizada `pFq'.

          (%i1) assume(not(equal(z,0)));
          (%o1)                          [notequal(z, 0)]
          (%i2) hgfred([v+1/2],[2*v+1],2*%i*z);

                               v/2                               %i z
                              4    bessel_j(v, z) gamma(v + 1) %e
          (%o2)               ---------------------------------------
                                                 v
                                                z
          (%i3) hgfred([1,1],[2],z);

                                             log(1 - z)
          (%o3)                            - ----------
                                                 z
          (%i4) hgfred([a,a+1/2],[3/2],z^2);

                                         1 - 2 a          1 - 2 a
                                  (z + 1)        - (1 - z)
          (%o4)                   -------------------------------
                                           2 (1 - 2 a) z

     Tal como muestra el siguiente ejemplo, puede ser de utilidad cargar
     también el paquete `orthopoly'. Nótese que <L> es el polinomio
     generalizado de Laguerre.

          (%i5) load(orthopoly)$
          (%i6) hgfred([-2],[a],z);

                                              (a - 1)
                                           2 L       (z)
                                              2
          (%o6)                            -------------
                                             a (a + 1)
          (%i7) ev(%);

                                            2
                                           z        2 z
          (%o7)                         --------- - --- + 1
                                        a (a + 1)    a


 -- Función: lambert_w (<z>)
     Rama principal de la función W de Lambert, la solución de la
     ecuación `z = W(z) * exp(W(z))'.

 -- Función: nzeta (<z>)
     Función de dispersión del plasma.  `nzeta(z) =
     %i*sqrt(%pi)*exp(-z^2)*(1-erf(-%i*z))'

 -- Función: nzetar (<z>)
     Devuelve `realpart(nzeta(z))'.

 -- Función: nzetai (<z>)
     Devuelve `imagpart(nzeta(z))'.


File: maxima.info,  Node: Funciones elípticas,  Next: Límites,  Prev: Funciones Especiales,  Up: Top

17 Funciones elípticas
**********************

* Menu:

* Introducción a las funciones e integrales elípticas::
* Funciones y variables para funciones elípticas::
* Funciones y variables para integrales elípticas::


File: maxima.info,  Node: Introducción a las funciones e integrales elípticas,  Next: Funciones y variables para funciones elípticas,  Prev: Funciones elípticas,  Up: Funciones elípticas

17.1 Introducción a las funciones e integrales elípticas
========================================================

Maxima da soporte para las funciones elípticas jacobianas y para las
integrales elípticas completas e incompletas.  Esto incluye la
manipulación simbólica de estas funciones y su evaluación numérica. Las
definiciones de estas funciones y de muchas de sus propiedades se
pueden encontrar en Abramowitz y Stegun, capítulos 16-17, que es la
fuente principal utilizada para su programación en Maxima, aunque
existen algunas diferencias.

   En particular, todas las funciones e integrales elípticas utilizan
el parámero m en lugar del módulo k o del ángulo alfa. Esta es una de
las diferencias con Abramowitz y Stegun, que utilizan el ángulo para
las funciones elípticas. Las siguientes relaciones son válidas:

   m = k^2 y k = sin(alfa).

   Las funciones e integrales elípticas en Maxima tienen como objetivo
primordial dar soporte al cálculo simbólico, de ahí que también estén
incluidas la mayoría de las derivadas e integrales asociadas a estas
funciones. No obstante lo anterior, si los argumentos dados a las
funciones son decimales en coma flotante, los resultados también serán
decimales.

   Sin embargo, la mayoría de las propiedades no realacionadas con las
derivadas de las funciones e integrales elípticas  todavía no han sido
programadas en Maxima.

   Algunos ejemplos de funciones elípticas:
     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

   Algunos ejemplos de integrales elípticas:
     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

   El paquete para funciones e integrales elípticas fue programado por
Raymond Toy. Se distribuye, igual que Maxima, bajo la General Public
License (GPL).


File: maxima.info,  Node: Funciones y variables para funciones elípticas,  Next: Funciones y variables para integrales elípticas,  Prev: Introducción a las funciones e integrales elípticas,  Up: Funciones elípticas

17.2 Funciones y variables para funciones elípticas
===================================================

 -- Función: jacobi_sn (<u>, <m>)
     Función elíptica jacobiana sn(u,m).

 -- Función: jacobi_cn (<u>, <m>)
     Función elíptica jacobiana cn(u,m).

 -- Función: jacobi_dn (<u>, <m>)
     Función elíptica jacobiana dn(u,m).

 -- Función: jacobi_ns (<u>, <m>)
     Función elíptica jacobiana ns(u,m) = 1/sn(u,m).

 -- Función: jacobi_sc (<u>, <m>)
     Función elíptica jacobiana sc(u,m) = sn(u,m)/cn(u,m).

 -- Función: jacobi_sd (<u>, <m>)
     Función elíptica jacobiana sd(u,m) = sn(u,m)/dn(u,m).

 -- Función: jacobi_nc (<u>, <m>)
     Función elíptica jacobiana nc(u,m) = 1/cn(u,m).

 -- Función: jacobi_cs (<u>, <m>)
     Función elíptica jacobiana cs(u,m) = cn(u,m)/sn(u,m).

 -- Función: jacobi_cd (<u>, <m>)
     Función elíptica jacobiana cd(u,m) = cn(u,m)/dn(u,m).

 -- Función: jacobi_nd (<u>, <m>)
     Función elíptica jacobiana nc(u,m) = 1/cn(u,m).

 -- Función: jacobi_ds (<u>, <m>)
     Función elíptica jacobiana ds(u,m) = dn(u,m)/sn(u,m).

 -- Función: jacobi_dc (<u>, <m>)
     Función elíptica jacobiana dc(u,m) = dn(u,m)/cn(u,m).

 -- Función: inverse_jacobi_sn (<u>, <m>)
     Inversa de la función elíptica jacobiana sn(u,m).

 -- Función: inverse_jacobi_cn (<u>, <m>)
     Inversa de la función elíptica jacobiana cn(u,m).

 -- Función: inverse_jacobi_dn (<u>, <m>)
     Inversa de la función elíptica jacobiana dn(u,m).

 -- Función: inverse_jacobi_ns (<u>, <m>)
     Inversa de la función elíptica jacobiana ns(u,m).

 -- Función: inverse_jacobi_sc (<u>, <m>)
     Inversa de la función elíptica jacobiana sc(u,m).

 -- Función: inverse_jacobi_sd (<u>, <m>)
     Inversa de la función elíptica jacobiana sd(u,m).

 -- Función: inverse_jacobi_nc (<u>, <m>)
     Inversa de la función elíptica jacobiana nc(u,m).

 -- Función: inverse_jacobi_cs (<u>, <m>)
     Inversa de la función elíptica jacobiana cs(u,m).

 -- Función: inverse_jacobi_cd (<u>, <m>)
     Inversa de la función elíptica jacobiana cd(u,m).

 -- Función: inverse_jacobi_nd (<u>, <m>)
     Inversa de la función elíptica jacobiana nc(u,m).

 -- Función: inverse_jacobi_ds (<u>, <m>)
     Inversa de la función elíptica jacobiana ds(u,m).

 -- Función: inverse_jacobi_dc (<u>, <m>)
     Inversa de la función elíptica jacobiana dc(u,m).


File: maxima.info,  Node: Funciones y variables para integrales elípticas,  Prev: Funciones y variables para funciones elípticas,  Up: Funciones elípticas

17.3 Funciones y variables para integrales elípticas
====================================================

 -- Función: elliptic_f (<phi>, <m>)
     Integral elíptica incompleta de primera especie, definida como

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Véanse también `elliptic_e' y `elliptic_kc'.


 -- Función: elliptic_e (<phi>, <m>)
     Integral elíptica incompleta de segunda especie, definida como

     elliptic_e(phi, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)

     Véanse también `elliptic_e' y `elliptic_ec'.


 -- Función: elliptic_eu (<u>, <m>)
     Integral elíptica incompleta de segunda especie, definida como

     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     donde tau = sn(u,m).

     Esto se relaciona con `elliptic_e' mediante

     elliptic_eu(u, m) = elliptic_e(asin(sn(u,m)),m)

     Véase también `elliptic_e'.

 -- Función: elliptic_pi (<n>, <phi>, <m>)
     Integral elíptica incompleta de tercera especie, definida como

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Maxima sólo conoce la derivada respecto de phi.

 -- Función: elliptic_kc (<m>)
     Integral elíptica completa de primera especie, definida como

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Para algunos valores de m, se conoce el valor de la integral en
     términos de la función Gamma. Hágase uso de `makegamma' para
     realizar su cálculo.

 -- Función: elliptic_ec (<m>)
     Integral elíptica completa de segunda especie, definida como

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Para algunos valores de m, se conoce el valor de la integral en
     términos de la función Gamma. Hágase uso de `makegamma' para
     realizar su cálculo.


File: maxima.info,  Node: Límites,  Next: Diferenciación,  Prev: Funciones elípticas,  Up: Top

18 Límites
**********

* Menu:

* Funciones y variables para límites::


File: maxima.info,  Node: Funciones y variables para límites,  Prev: Límites,  Up: Límites

18.1 Funciones y variables para límites
=======================================

 -- Variable optativa: lhospitallim
     Valor por defecto: 4

     Es el número máximo de veces que la regla de L'Hopital es aplicada
     en la función `limit', evitando bucles infinitos al iterar la
     regla en casos como `limit (cot(x)/csc(x), x, 0)'.


 -- Función: limit (<expr>, <x>, <val>, <dir>)
 -- Función: limit (<expr>, <x>, <val>)
 -- Función: limit (<expr>)
     Calcula el límite de <expr> cuando la variable real <x> se
     aproxima al valor <val> desde la dirección <dir>. El argumento
     <dir> puede ser el valor `plus' para un límite por la derecha,
     `minus' para un límite por la izquierda o simplemente se omite
     para indicar un límite en ambos sentidos.

     La función `limit' utiliza los símbolos especiales siguientes:
     `inf' (más infinito) y `minf' (menos infinito). En el resultado
     también puede hacer uso de `und' (indefinido), `ind' (indefinido
     pero acotado) y `infinity' (infinito complejo).

     La variable `lhospitallim' guarda el número máximo de veces que la
     regla de L'Hopital es aplicada en la función `limit', evitando
     bucles infinitos al iterar la regla en casos como `limit
     (cot(x)/csc(x), x, 0)'.

     Si la variable `tlimswitch' vale `true', hará que la función
     `limit' utilice desarrollos de Taylor siempre que le sea posible.

     La variable `limsubst' evita que la función `limit' realice
     sustituciones sobre formas desconocidas, a fin de evitar fallos
     tales como que `limit (f(n)/f(n+1), n, inf)' devuelva 1.  Dándole
     a `limsubst' el valor `true' se permitirán tales sustituciones.

     La función `limit' con un solo argumento se utiliza frecuentemente
     para simplificar expresiones constantes, como por ejemplo `limit
     (inf-1)'.

     La instrucción `example (limit)' muestra algunos ejemplos.

     Para información sobre el método utilizado véase Wang, P.,
     "Evaluation of Definite Integrals by Symbolic Manipulation", Ph.D.
     thesis, MAC TR-92, October 1971.


 -- Variable optativa: limsubst
     Valor por defecto: `false'

     La variable `limsubst' evita que la función `limit' realice
     sustituciones sobre formas desconocidas, a fin de evitar fallos
     tales como que `limit (f(n)/f(n+1), n, inf)' devuelva 1.  Dándole
     a `limsubst' el valor `true' se permitirán tales sustituciones.


 -- Función: tlimit (<expr>, <x>, <val>, <dir>)
 -- Función: tlimit (<expr>, <x>, <val>)
 -- Función: tlimit (<expr>)
     Calcula el límite del desarrollo de Taylor de la expresión `expr'
     de variable `x' en el punto `val' en la dirección `dir'.

 -- Variable optativa: tlimswitch
     Valor por defecto: `true'

     Si `tlimswitch' vale `true', la función `limit' utilizará un
     desarrollo de Taylor si el límite de la expresión dada no se puede
     calcular directamente. Esto permite el cálculo de límites como
     `limit(x/(x-1)-1/log(x),x,1,plus)'.  Si `tlimswitch' vale `false'
     y el límite de la expresión no se puede calcular directamente, la
     función `limit' devolverá una expresión sin evaluar.


File: maxima.info,  Node: Diferenciación,  Next: Integración,  Prev: Límites,  Up: Top

19 Diferenciación
*****************

* Menu:

* Funciones y variables para la diferenciación::



Local Variables:
coding: iso-8859-1
End:
