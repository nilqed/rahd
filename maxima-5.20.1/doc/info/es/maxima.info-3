This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Ver. 5.20 Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Funciones y variables para la diferenciación,  Prev: Diferenciación,  Up: Diferenciación

19.1 Funciones y variables para la diferenciación
=================================================

 -- Función: antid (<expr>, <x>, <u(x)>)
     Devuelve una lista con dos elementos, de manera que se pueda
     calcular la antiderivada de <expr> respecto de  <x> a partir de la
     lista. La expresión <expr> puede contener una función no
     especificada <u> y sus derivadas.

     Sea <L> la lista con dos elementos que devuelve la función `antid'.
     Entonces, `<L>[1] + 'integrate (<L>[2], <x>)' es una antiderivada
     de <expr> con respecto a <x>.

     Si la ejecución de `antid' resulta exitosa, el segundo elemento de
     la lista retornada es cero. En caso contrario, el segundo elemento
     es distinto de cero y el primero puede ser nulo o no. Si `antid'
     no es capaz de hacer ningún progreso, el primer elemento es nulo y
     el segundo no nulo.

     Es necesario ejecutar `load ("antid")' para cargar esta función.
     El paquete `antid' define también las funciones `nonzeroandfreeof'
     y `linear'.

     La función `antid' está relacionada con `antidiff' como se indica
     a continuación.  Sea <L> la lista devuelta por la función `antid'.
     Entonces, el resultado de `antidiff' es igual a  `<L>[1] +
     'integrate (<L>[2], <x>)', donde <x> es la variable de integración.

     Ejemplos:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- Función: antidiff (<expr>, <x>, <u>(<x>))
     Devuelve la antiderivada de <expr> respecto de <x>.  La expresión
     <expr> puede contener una función no especificada <u> y sus
     derivadas.

     Cuando `antidiff' se ejecuta con éxito, la expresión resultante no
     tiene símbolos integrales (esto es, no tiene referencias a la
     función `integrate'). En otro caso, `antidiff' devuelve una
     expresión que se encuentra total o parcialmente bajo el signo de
     integración. Si `antidiff' no puede ralizar ningún progreso, el
     valor devuelto se encuentra completamente bajo la integral.

     Es necesario ejecutar `load ("antid")' para cargar esta función.
     El paquete `antid' define también las funciones `nonzeroandfreeof'
     y `linear'.

     La función `antidiff' está relacionada con `antid' como se indica
     a continuación.  Sea <L> la lista de dos elementos que devuelve
     `antid'. Entonces, el valor retornado por `antidiff' es igual a
     `<L>[1] + 'integrate (<L>[2], <x>)', donde <x> es la variable de
     integración.

     Ejemplos:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- Propiedad: atomgrad
     La propiedad `atomgrad' es asignada por `gradef'.


 -- Función: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- Función: atvalue (<expr>, <x_1> = <a_1>, <c>)
     Asigna el valor <c> a <expr> en el punto `<x> = <a>'.

     La expresión <expr> es una función del tipo `<f>(<x_1>, ...,
     <x_m>)', o una derivada, `diff (<f>(<x_1>, ..., <x_m>), <x_1>,
     <n_1>, ..., <x_n>, <n_m>)' en la que aparecen los argumentos de la
     función de forma explícita.  Los símbolos <n_i> se refieren al
     orden de diferenciación respecto de <x_i>.

     El punto en el que `atvalue' establece el valor se especifica
     mediante la lista de ecuaciones `[<x_1> = <a_1>, ..., <x_m> =
     <a_m>]'.  Si hay una única variable <x_1>, la ecuación puede
     escribirse sin formar parte de una lista.

     La llamada `printprops ([<f_1>, <f_2>, ...], atvalue)' muestra los
     valores asignados por `atvalue' a las funciones `<f_1>, <f_2>,
     ...'.  La llamada  `printprops (<f>, atvalue)' muestra los valores
     asignados por `atvalue' a la función <f>.  La llamada  `printprops
     (all, atvalue)' muestra los valores asignados por `atvalue' a
     todas las funciones.

     Los símbolos `@1', `@2', ... representan las variables <x_1>,
     <x_2>, ... cuando se muestran los valores asignados por `atvalue'.

     La función `atvalue' evalúa sus argumentos y devuelve <c>, el
     valor asignado.

     Ejemplos:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Función: cartan -
     El cálculo exterior de formas diferenciales es una herramienta
     básica de la geometría diferencial desarrollada por Elie Cartan,
     teniendo importantes aplicaciones en la teoría de ecuaciones
     diferenciales en derivadas parciales.  El paquete `cartan' dispone
     de las funciones `ext_diff' y `lie_diff', así como de los
     operadores `~' (producto exterior) y `|' (contracción de una forma
     con un vector). La orden `demo (tensor)' permite ver una breve
     descripción de estas instrucciones, junto con ejemplos.

     El paquete `cartan' fue escrito por F.B. Estabrook y H.D.
     Wahlquist.


 -- Función: del (<x>)
     La expresión `del (<x>)' representa el diferencial de la variable
     x.

     La función `diff' devuelve una expresión que contiene a `del' si
     no se ha especificado una variable independiente. En este caso, el
     valor retornado es el llamado "diferencial total".

     Ejemplos:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)


 -- Función: delta (<t>)
     Es la función delta de Dirac.

     En el estado actual de desarrollo de Maxima, sólo `laplace'
     reconoce la función `delta'.

     Ejemplo:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e


 -- Variable del sistema: dependencies
     Valor por defecto: `[]'

     La variable `dependencies' es la lista de átomos que tienen algún
     tipo de dependencia funcional, asignada por `depends' o `gradef'.
     La lista `dependencies' es acumulativa: cada llamada a `depends' o
     `gradef' añade elementos adicionales.

     Véanse `depends' y `gradef'.


 -- Función: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)
     Declara dependencias funcionales entre variables con el propósito
     de calcular derivadas.  En ausencia de una dependencia declarada,
     `diff (f, x)' devuelve cero.  Si se declara `depends (f, x)',
     `diff (f, x)' devuelve una derivada simbólica (esto es, una
     expresión con `diff').

     Cada argumento  <f_1>, <x_1>, etc., puede ser el nombre de una
     variable, de un arreglo o una lista de nombres.  Cada elemento de
     <f_i> (quizás un único elemento) se declara como dependiente de
     cada elemento de <x_i> (quizás también un único elemento). Si
     alguno de los  <f_i> es el nombre de un arreglo o contiene el
     nombre de un arreglo, todos los elemento del arregl dependen de
     <x_i>.

     La función `diff' reconoce dependencias indirectas establecidas
     por `depends' y aplica la regla de la cadena en tales casos.

     La instrucción `remove (<f>, dependency)' borra todas las
     dependencias declaradas para <f>.

     La función `depends' devuelve una lista con las dependencias que
     han sido establecidas. Las dependencias se añaden a la variable
     global `dependencies'. La función `depends' evalúa sus argumentos.

     La función `diff' es la única instrucción de Maxima que reconoce
     las dependencias establecidas por `depends'. Otras funciones
     (`integrate', `laplace', etc.) solamente reconocen dependencias
     explícitamente representadas por sus argumentos. Por ejemplo,
     `integrate' no reconoce la dependencia de `f' respecto de `x' a
     menos que se represente explícitamente como `integrate (f(x), x)'.

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt


 -- Variable optativa: derivabbrev
     Valor por defecto: `false'

     Si `derivabbrev' vale `true', las derivadas simbólicas (esto es,
     expresiones con `diff') se muestran como subíndices. En otro caso,
     las derivadas se muestran en la notación de Leibniz, `dy/dx'.


 -- Función: derivdegree (<expr>, <y>, <x>)
     Devuelve el mayor grado de la derivada de la variable dependiente
     <y> respecto de la variable independiente <x> que aparece en
     <expr>.

     Ejemplo:
          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2


 -- Función: derivlist (<var_1>, ..., <var_k>)
     Hace que las derivadas calculadas por la instrucción `ev' se
     calculen respecto de las variables indicadas.


 -- Variable optativa: derivsubst
     Valor por defecto: `false'

     Si `derivsubst' vale `true', una sustitución no sintáctica del
     estilo `subst (x, 'diff (y, t), 'diff (y, t, 2))' devuelve `'diff
     (x, t)'.


 -- Función: diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)
 -- Función: diff (<expr>, <x>, <n>)
 -- Función: diff (<expr>, <x>)
 -- Función: diff (<expr>)
     Devuelve la derivada o diferencial de  <expr> respecto de alguna o
     de todas las variables presentes en <expr>.

     La llamada `diff (<expr>, <x>, <n>)' devuelve la <n>-esima
     derivada de <expr> respecto de <x>.

     La llamada `diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)'
     devuelve la derivada parcial de <expr> con respecto de <x_1>, ...,
     <x_m>.  Equivale a `diff (... (diff (<expr>, <x_m>, <n_m>) ...),
     <x_1>, <n_1>)'.

     La llamada `diff (<expr>, <x>)' devuelve la primera derivada de
     <expr> respecto de la variable <x>.

     La llamada `diff (<expr>)' devuelve el diferencial total de
     <expr>, esto es, la suma de las derivadas de <expr> respecto de
     cada una de sus variables, multiplicadas por el diferencial `del'
     de cada una de ellas.

     La forma nominal de `diff' es necesaria en algunos contextos, como
     para definir ecuaciones diferenciales.  En tales casos, `diff'
     puede ir precedida de un apóstrofo (como `'diff') para evitar el
     cálculo de la derivada.

     Si `derivabbrev' vale `true', las derivadas se muestran como
     subíndices. En otro caso, se muestran en la notación de Leibniz,
     `dy/dx'.

     Ejemplos:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     Para el paquete sobre tensores se han introducido las siguientes
     modificaciones:

     (1) Las derivadas de los objetos indexados en <expr> tendrán las
     variables <x_i> añadidas como argumentos adicionales. Entonces se
     ordenarán todos los índices de derivadas.

     (2) Las <x_i> pueden ser enteros entre 1 hasta el valor de la
     variable `dimension' [valor por defecto: 4].  Esto hará que la
     diferenciación sea llevada a cabo con respecto al <x_i>-ésimo
     número de la lista `coordinates', la cual debería contener una
     lista con los nombres de las coordenadas, por ejemplo, `[x, y, z,
     t]'. Si `coordinates' es una variableis atómica, entonces esa
     variable será utilizada como variable de diferenciación. Se
     permite la utilización de arreglos con los nombres de las
     coordenadas o nombres con subíndices, como `X[1]', `X[2]', ... to
     be used.  Si a `coordinates' no se le ha asignado ningún valor,
     entonces las variables serán tratadas como se ha indicado en (1).


 -- Símbolo especial: diff
     Si el nombre `diff' está presente en una llamada a la función `ev'
     en modo `evflag', entonces se calculan todas las derivadas
     presentes en `expr'.


 -- Función: express (<expr>)
     Transforma los nombres de los operadores diferenciales en
     expresiones que contienen derivadas parciales. Los operadores
     reconocidos por la función `express' son: `grad' (gradiente),
     `div' (divergencia), `curl' (rotacional), `laplacian' (laplaciano)
     y `~' (producto vectorial).

     Las derivadas simbólicas (es decir, las que incluyen la forma
     nominal `diff') que aparecen en la expresión devuelta por
     `express', se pueden calcular pasándole a `ev' el argumento
     `diff', o escribiéndolo directamente en la línea de comandos. En
     este contexto, `diff' actúa como `evfun'.

     Es necesario ejecutar `load ("vect")' para cargar esta función.

     Ejemplos:

          (%i1) load ("vect")$
          (%i2) grad (x^2 + y^2 + z^2);
                                        2    2    2
          (%o2)                  grad (z  + y  + x )
          (%i3) express (%);
                 d    2    2    2   d    2    2    2   d    2    2    2
          (%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
                 dx                 dy                 dz
          (%i4) ev (%, diff);
          (%o4)                    [2 x, 2 y, 2 z]
          (%i5) div ([x^2, y^2, z^2]);
                                        2   2   2
          (%o5)                   div [x , y , z ]
          (%i6) express (%);
                             d    2    d    2    d    2
          (%o6)              -- (z ) + -- (y ) + -- (x )
                             dz        dy        dx
          (%i7) ev (%, diff);
          (%o7)                    2 z + 2 y + 2 x
          (%i8) curl ([x^2, y^2, z^2]);
                                         2   2   2
          (%o8)                   curl [x , y , z ]
          (%i9) express (%);
                 d    2    d    2   d    2    d    2   d    2    d    2
          (%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
                 dy        dz       dz        dx       dx        dy
          (%i10) ev (%, diff);
          (%o10)                      [0, 0, 0]
          (%i11) laplacian (x^2 * y^2 * z^2);
                                            2  2  2
          (%o11)                laplacian (x  y  z )
          (%i12) express (%);
                   2                2                2
                  d     2  2  2    d     2  2  2    d     2  2  2
          (%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
                    2                2                2
                  dz               dy               dx
          (%i13) ev (%, diff);
                                2  2      2  2      2  2
          (%o13)             2 y  z  + 2 x  z  + 2 x  y
          (%i14) [a, b, c] ~ [x, y, z];
          (%o14)                [a, b, c] ~ [x, y, z]
          (%i15) express (%);
          (%o15)          [b z - c y, c x - a z, a y - b x]


 -- Función: gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)
 -- Función: gradef (<a>, <x>, <expr>)
     Define las derivadas parciales, o componentes del gradiente, de la
     función <f> o variable <a>.

     La llamada `gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)'
     define `d<f>/d<x_i>' como <g_i>, donde <g_i> es una expresión;
     <g_i> puede ser una llamada a función, pero no el nombre de una
     función.  El número de derivadas parciales <m> puede ser menor que
     el número de argumentos <n>, en cuyo caso las derivadas se definen
     solamente con respecto a  <x_1>, ...., <x_m>.

     La llamada `gradef (<a>, <x>, <expr>)' define la derivada de la
     variable <a> respecto de <x> en <expr>. Con esto se establece la
     dependencia de <a> respecto de <x> a través de `depends (<a>,
     <x>)'.

     El primer argumento `<f>(<x_1>, ..., <x_n>)' o <a> no se evalúa,
     pero sí lo hacen el resto de argumentos <g_1>, ..., <g_m>.  La
     llamada a `gradef' devuelve la función o variable para la que se
     define la derivada parcial.

     La instrucción `gradef' puede redefinir las derivadas de las
     funciones propias de Maxima.  Por ejemplo, `gradef (sin(x), sqrt
     (1 - sin(x)^2))' redefine la derivada de `sin'.

     La instrucción `gradef' no puede definir derivadas parciales de
     funciones subindicadas.

     La llamada `printprops ([<f_1>, ..., <f_n>], gradef)' muestra las
     derivadas parciales de las funciones <f_1>, ..., <f_n>, tal como
     las definió `gradef'.

     La llamada `printprops ([<a_n>, ..., <a_n>], atomgrad)' muestra
     las derivadas parciales de las variables <a_n>, ..., <a_n>, tal
     como las definió `gradef'.

     La variable `gradefs' contiene la lista de las funciones para las
     que se han definido derivadas parciales con la instrucción
     `gradef', pero no incluye las variables para las que se han
     definido las derivadas parciales.

     Los gradientes son necesarios cuando una función no se conoce
     explícitamente pero sí sus primeras derivadas y es necesario
     calcular las derivadas de orden mayor.


 -- Variable del sistema: gradefs
     Valor por defecto: `[]'

     La variable `gradefs' contiene la lista de las funciones para las
     que se han definido derivadas parciales con la instrucción
     `gradef', pero no incluye las variables para las que se han
     definido las derivadas parciales.


 -- Función: laplace (<expr>, <t>, <s>)
     Calcula la transformada de Laplace de <expr> con respecto de la
     variable <t> y parámetro de transformación <s>.

     La función `laplace' reconoce en <expr> las funciones `delta',
     `exp', `log', `sin', `cos', `sinh', `cosh' y `erf', así como
     `derivative', `integrate', `sum' y `ilt'.  Si `laplace' no
     encuentra una transformada, entonces llama a la función `specint',
     la cual puede encontrar la transformada de Laplace de expresiones
     con funciones especiales, tales como las de Bessel. `specint'
     también puede manipular la función `unit_step'. Véase `specint'
     para más información.

     Cuando tampoco `specint' sea capaz de encontrar una solución, se
     devolverá una forma nominal.

     La función `laplace' reconoce integrales de convolución de la
     forma `integrate (f(x) * g(t - x), x, 0, t)', no pudiendo
     reconocer otros tipos de convoluciones.

     Las relaciones funcionales se deben representar explícitamente en
     <expr>; las relaciones implícitas establecidas por `depends' no
     son reconocidas. Así, si <f> depende de <x> y <y>, `f (x, y)' debe
     aparecer en <expr>.

     Véase también `ilt', la transformada inversa de Laplace.

     Ejemplos:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0
          (%i5) assume(a>0)$
          (%i6) laplace(gamma_incomplete(a,t),t,s),gamma_expand:true;
                                                        - a - 1
                                   gamma(a)   gamma(a) s
          (%o6)                    -------- - -----------------
                                      s            1     a
                                                  (- + 1)
                                                   s
          (%i7) factor(laplace(gamma_incomplete(1/2,t),t,s));
                                                        s + 1
                                sqrt(%pi) (sqrt(s) sqrt(-----) - 1)
                                                          s
          (%o7)                 -----------------------------------
                                          3/2      s + 1
                                         s    sqrt(-----)
                                                     s
          (%i8) assume(exp(%pi*s)>1)$
          (%i9) laplace(sum((-1)^n*unit_step(t-n*%pi)*sin(t),n,0,inf),t,s),simpsum;
                                   %i                         %i
                        ------------------------ - ------------------------
                                        - %pi s                    - %pi s
                        (s + %i) (1 - %e       )   (s - %i) (1 - %e       )
          (%o9)         ---------------------------------------------------
                                                 2
          (%i9) factor(%);
                                                %pi s
                                              %e
          (%o9)                   -------------------------------
                                                       %pi s
                                  (s - %i) (s + %i) (%e      - 1)



File: maxima.info,  Node: Integración,  Next: Ecuaciones,  Prev: Diferenciación,  Up: Top

20 Integración
**************

* Menu:

* Introducción a la integración::
* Funciones y variables para integración::
* Introducción a QUADPACK::
* Funciones y variables para QUADPACK::


File: maxima.info,  Node: Introducción a la integración,  Next: Funciones y variables para integración,  Prev: Integración,  Up: Integración

20.1 Introducción a la integración
==================================

Maxima tiene varias rutinas para calcular integrales. La función
`integrate' hace uso de la mayor parte de ellas.  También está el
paquete `antid', que opera con funciones no especificadas y sus
derivadas. Para usos numéricos se dispone de la batería de integradores
adaptativos de `QUADPACK', como `quad_qag', `quad_qags', etc., que se
describen en la sección `QUADPACK'.  También se trabajan funciones
hipergeométricas, véase `specint' para más detalles. En términos
generales, Maxima sólo opera con funciones que son integrables en
términos de funciones elementales, como las racionales,
trigonométricas, logarítmicas, exponenciales, radicales, etc., y unas
pocas extensiones de éstas, como la función de error o los
dilogaritmos. No opera con integrales en términos de funciones
desconocidas, como  `g(x)' o `h(x)'.


File: maxima.info,  Node: Funciones y variables para integración,  Next: Introducción a QUADPACK,  Prev: Introducción a la integración,  Up: Integración

20.2 Funciones y variables para integración
===========================================

 -- Función: changevar (<expr>, <f(x,y)>, <y>, <x>)
     Hace el cambio de variable dado por `<f(x,y)> = 0' en todas las
     integrales que aparecen en <expr> con la integración respecto de
     <x>. La nueva variable será <y>.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     Si una expresión contiene formas nominales, como aquélla en la que
     aparece `'integrate' en el ejemplo, podrá ser evaluada por `ev' si
     se utiliza el término `nouns'. Por ejemplo, la expresión devuelta
     por `changevar' se puede evaluar haciendo `ev (%o3, nouns)'.

     La función `changevar' también se puede utilizar para cambiar los
     índices de una suma o producto.  Sin embargo, debe tenerse en
     cuenta que cuando se realiza un cambio en una suma o producto, el
     mismo debe expresarse en términos de sumas, como `i = j+ ...', no
     como una función de mayor grado.

     Ejemplo:

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2


 -- Función: dblint (<f>, <r>, <s>, <a>, <b>)
     Es una rutina para integrales dobles escrita en lenguaje Maxima y
     posteriormente traducida y compilada a código máquina. La
     instrucción `load (dblint)' carga esta función. Utiliza el método
     de Simpson en las dos direcciones `x' e `y' para calcular

          /b /s(x)
          |  |
          |  |    f(x,y) dy dx
          |  |
          /a /r(x)

     La función <f> debe ser una función traducida o compilada de dos
     variables, a la vez que <r> y <s> deben ser cada una de ellas una
     función traducida o compilada de una variable, mientras que <a> y
     <b> deben ser números en coma flotante. La rutina tiene dos
     variables globales que determinan el número de divisiones de los
     intervalos `x' e `y': `dblint_x' y `dblint_y', ambos con un valor
     por defecto de 10, pero que pueden cambiarse de forma
     independiente a otros valores enteros (hay `2*dblint_x+1' puntos a
     calcular en la dirección `x' y `2*dblint_y+1' en la dirección
     `y'). La rutina subdivide el eje X y luego para cada valor de X
     calcula primero `<r>(x)' y `<s>(x)'; entonces se subdivide el eje
     Y entre `<r>(x)' y `<s>(x)', evaluándose la integral a lo largo
     del eje Y aplicando la regla de Simpson; a continuación, se evalúa
     la integral a lo largo del eje X utilizando también la regla de
     Simpson tomando como valores de función las integrales sobre Y.
     Este procedimiento puede ser numéricamente inestable por múltiples
     motivos, pero es razonablemente rápido: evítese su uso con
     funciones con grandes oscilaciones o que tengan singularidades.
     Las integrales del eje Y dependen de la proximidad de los límites
     `<r>(x)' y `<s>(x)', de manera que si la distancia `<s>(x) -
     <r>(x)' varía rápidamente con X, puede dar lugar errores
     importantes debido a truncamientos de diferente amplitud en las
     integrales de Y. Se puede aumentar `dblint_x' y `dblint_y' al
     objeto de mejorar el recubrimiento de la región de integración,
     pero a costa del tiempo de cómputo. Es necesario que las funciones
     <f>, <r> y <s> estén traducidas o compiladas antes de utilizar
     `dblint', lo cual redundará en una mejora del tiempo de ejecución
     de varios órdenes de magnitud respecto de la ejecución de código
     interpretado.


 -- Función: defint (<expr>, <x>, <a>, <b>)
     Intenta calcular una integral definida. La función `defint' es
     invocada por  `integrate' cuando se especifican los límites de
     integración, por ejemplo `integrate (<expr>, <x>, <a>, <b>)'. Así,
     desde el punto de vista del usuario, es suficiente con utilizar
     `integrate'.

     La función `defint' devuelve una expresión simbólica, bien sea el
     resultado calculado o la forma nominal.  Véase `quad_qag' y sus
     funciones relacionadas para aproximaciones numéricas de integrales
     definidas.


 -- Variable optativa: erfflag
     Valor por defecto: `true'

     Si `erfflag' vale `false', la función `risch' no introduce la
     función `erf' en el resultado si no había ninguna en el integrando.


 -- Función: ilt (<expr>, <s>, <t>)
     Calcula la transformada inversa de Laplace de <expr> con respecto
     de <s> y parámetro <t>. El argumento  <expr> debe ser una fracción
     de polinomios cuyo denominador tenga sólo factores lineales y
     cuadráticos. Utilizando las funciones `laplace' y `ilt', junto con
     las funciones `solve' o `linsolve', el usuario podrá resolver
     ciertas ecuaciones integrales.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a


 -- Función: integrate (<expr>, <x>)
 -- Función: integrate (<expr>, <x>, <a>, <b>)
     Calcula simbólicamente la integral de <expr> respecto de <x>. La
     llamada `integrate (<expr>, <x>)' resuelve una integral
     indefinida, mientras que  `integrate (<expr>, <x>, <a>, <b>)'
     resuelve una integral definida con límites de integración <a> y
     <b>.  Los límites no pueden contener a <x>. El argumento <a> no
     necesita ser menor que <b>.  Si <b> es igual a <a>, `integrate'
     devuelve cero.

     Véase `quad_qag' y funciones relacionadas para la aproximación
     numérica de integrales definidas.  Véase `residue' para el cálculo
     de residuos (integración compleja).  Véase `antid' para un método
     alternativo de resolución de integrales indefinidas.

     Se obtendrá una integral (es decir, una expresión sin `integrate')
     si `integrate' tiene éxito en el cálculo. En otro caso, la
     respuesta es la forma nominal de la integral (esto es, el operador
     `'integrate' precedido de apóstrofo) o una expresión que contiene
     una o más formas nominales. La forma nominal de `integrate' se
     muestra con un símbolo integral.

     En ciertos casos es útil proporcionar una forma nominal 'a mano',
     haciendo preceder `integrate' con una comilla simple o apóstrofo,
     como en `'integrate (<expr>, <x>)'.  Por ejemplo, la integral
     puede depender de algunos parámetros que todavía no han sido
     calculados.  La forma nominal puede aplicarse después a sus
     argumentos haciendo `ev (<i>, nouns)' donde <i> es la forma
     nominal de interés.

     La función `integrate' trata de manera diferente las integrales
     definidas de las indefinidas, empleando una batería de heurísticas
     especial para cada caso.  Casos especiales de integrales definidas
     incluyen las que tienen límites de integración iguales a cero o a
     infinito (`inf' o `minf'), funciones trigonométricas con límites
     de integración igual a cero y `%pi' o `2 %pi', funciones
     racionales, integrales relacionadas con las funciones `beta' y
     `psi' y algunas integrales logarítmicas y trigonométricas. El
     tratamiento de funciones racionales puede incluir el cálculo de
     residuos.  Si no se reconoce ninguno de los casos especiales, se
     intenta resolver la integral idefinida y evaluarla en los límites
     de integración. Esto incluye tomar límites cuando alguno de los
     extremos del intervalo de integración se acerca a más infinito o a
     menos infinito; véase también `ldefint'.

     Casos especiales de integrales indefinidas incluyen a las
     funciones trigonométricas, exponenciales, logarítmicas y
     racionales. La función `integrate' también hace uso de una pequeña
     tabla de integrales elementales.

     La función `integrate' puede llevar a cabo cambios de variable si
     el integrando es de la forma `f(g(x)) * diff(g(x), x)', entonces
     `integrate' trata de encontrar una subexpresión de `g(x)' tal que
     la derivada de  `g(x)' divida el integrando. Esta búsqueda puede
     hacer uso de las derivadas establecidas con la función `gradef'.
     Véanse también `changevar' y `antid'.

     Si ninguna de las heurísticas descritas resuelve la integral
     indefinida, se ejecuta el algoritmo de Risch.  La variable `risch'
     puede utilizarse como una `evflag', en una llamada a `ev' o en la
     línea de comandos por ejemplo, `ev (integrate (<expr>, <x>),
     risch)' o `integrate (<expr>, <x>), risch'.  Si `risch' está
     presenta, `integrate' llama a la función `risch' sin intentar
     primero las heurísticas. Véase también `risch'.

     La función `integrate' opera únicamente con relaciones funcionales
     que se representen explícitamente con la notación `f(x)', sin
     considerar las dependencias implícitas establecidas mediante la
     función `depends'.

     Es posible que `integrate' necesite conocer alguna propiedad de
     alguno de los parámetros presentes en el integrando, en cuyo caso
     `integrate' consultará en primer lugar la base de datos creada con
     `assume', y si la variable de interés no se encuentra ahí,
     `integrate' le preguntará al usuario. Dependiendo de la pregunta,
     posibles respuestas son: `yes;', `no;', `pos;', `zero;' o `neg;'.

     Por defecto, `integrate' no se considera lineal. Véanse `declare'
     y `linear'.

     La función `integrate' intentará la integración por partes sólo en
     casos especiales.

     Ejemplos:

        * Integrales elementales indefinidas y definidas.

               (%i1) integrate (sin(x)^3, x);
                                          3
                                       cos (x)
               (%o1)                   ------- - cos(x)
                                          3
               (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                                2    2
               (%o2)                    - sqrt(b  - x )
               (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                              %pi
                                          3 %e      3
               (%o3)                      ------- - -
                                             5      5
               (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                           sqrt(%pi)
               (%o4)                       ---------
                                               2

        * Utilización de `assume' e interacción.

               (%i1) assume (a > 1)$
               (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
                   2 a + 2
               Is  -------  an integer?
                      5

               no;
               Is  2 a - 3  positive, negative, or zero?

               neg;
                                                  3
               (%o2)                  beta(a + 1, - - a)
                                                  2

        * Cambio de variable. En este ejemplo hay dos cambios de
          variable: uno utilizando una derivada establecida con
          `gradef' y otra utilizando la derivada `diff(r(x))' de una
          función no especificada `r(x)'.

               (%i3) gradef (q(x), sin(x**2));
               (%o3)                         q(x)
               (%i4) diff (log (q (r (x))), x);
                                     d               2
                                    (-- (r(x))) sin(r (x))
                                     dx
               (%o4)                ----------------------
                                           q(r(x))
               (%i5) integrate (%, x);
               (%o5)                     log(q(r(x)))

        * El valor devuelto contiene la forma nominal `'integrate'.  En
          este ejemplo, Maxima puede extraer un factor del denominador
          de una función racional, pero no puede factorizar el resto.
          La función `grind' muestra la forma nominal `'integrate' del
          resultado.  Véase también `integrate_use_rootsof' para más
          información sobre integrales de funciones racionales.

               (%i1) expand ((x-4) * (x^3+2*x+1));
                                   4      3      2
               (%o1)              x  - 4 x  + 2 x  - 7 x - 4
               (%i2) integrate (1/%, x);
                                             /  2
                                             [ x  + 4 x + 18
                                             I ------------- dx
                                             ]  3
                                log(x - 4)   / x  + 2 x + 1
               (%o2)            ---------- - ------------------
                                    73               73
               (%i3) grind (%);
               log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$

        * Definición de una función mediante una integral.  El cuerpo
          de una función no se evalúa cuando ésta se define, de manera
          que el cuerpo de `f_1' en este ejemplo contiene la forma
          nominal de `integrate'.  El operador comilla-comilla `'''
          hace que se evalúe la integral y su resultado será el que
          defina a la función `f_2'.

               (%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                                    3
               (%o1)           f_1(a) := integrate(x , x, 1, a)
               (%i2) ev (f_1 (7), nouns);
               (%o2)                          600
               (%i3) /* Note parentheses around integrate(...) here */
                     f_2 (a) := ''(integrate (x^3, x, 1, a));
                                                  4
                                                 a    1
               (%o3)                   f_2(a) := -- - -
                                                 4    4
               (%i4) f_2 (7);
               (%o4)                          600


 -- Variable del sistema: integration_constant
     Valor por defecto: `%c'

     Cuando una constante de integración se crea durante la integración
     definida de una ecuación, el nombre de la constante se construye
     concatenando `integration_constant' y
     `integration_constant_counter'.

     A `integration_constant' se le puede asignar un símbolo cualquiera.

     Ejemplos:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integration_constant : 'k;
          (%o2)                           k
          (%i3) integrate (x^2 = 1, x);
                                      3
                                     x
          (%o3)                      -- = x + k2
                                     3


 -- Variable del sistema: integration_constant_counter
     Valor por defecto: 0

     Cuando una constante de integración se crea durante la integración
     definida de una ecuación, el nombre de la constante se construye
     concatenando `integration_constant' y
     `integration_constant_counter'.

     La variable `integration_constant_counter' se incrementa antes de
     construir la constante de integración siguiente.

     Ejemplos:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o2)                     -- = x + %c2
                                    3
          (%i3) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o3)                     -- = x + %c3
                                    3
          (%i4) reset (integration_constant_counter);
          (%o4)            [integration_constant_counter]
          (%i5) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o5)                     -- = x + %c1
                                    3

 -- Variable optativa: integrate_use_rootsof
     Valor por defecto: `false'

     Si `integrate_use_rootsof' vale `true' y el denominador de una
     función racional no se puede factorizar,  `integrate' devuelve la
     integral como una suma respecto de las raíces desconocidas del
     denominador.

     Por ejemplo, dándole a `integrate_use_rootsof' el valor `false',
     `integrate' devuelve la integral no resuelta de la función
     racional en forma nominal:

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Si ahora se le da a la variable el valor `true', la parte no
     resuelta de la integral se expresa como una suma cuyos sumandos
     dependen de las raíces del denominador de la función racional:

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                3    2
                %r4 in rootsof(x  - x  + 1)
          (%o4) ----------------------------------------------------------
                         7

                                                                 2 x + 1
                                             2            5 atan(-------)
                                        log(x  + x + 1)          sqrt(3)
                                      - --------------- + ---------------
                                              14             7 sqrt(3)

     Alternativamente, el usuario puede calcular las raíces del
     denominador separadamente y luego representar el integrando en
     función de dichas raíces, como por ejemplo `1/((x - a)*(x - b)*(x
     - c))' o `1/((x^2 - (a+b)*x + a*b)*(x - c))' si el denominador es
     un polinomio de tercer grado. En algunos casos, esto ayudará a
     Maxima mejorar sus resultados.


 -- Función: ldefint (<expr>, <x>, <a>, <b>)
     Calcula la integral definida de <expr> utilizando `limit' tras el
     cálculo de la integral indefinida de <expr> respecto a <x> en los
     extremos de integración <b> y <a>.  Si no consigue calcular la
     integral definida, `ldefint' devuelve una expresión con los
     límites en forma nominal.

     La función `integrate' no llama a `ldefint', de modo que la
     ejecución de `ldefint (<expr>, <x>, <a>, <b>)' puede dar un
     resultado diferente que `integrate (<expr>, <x>, <a>, <b>)'. La
     función `ldefint' siempre utiliza el mismo método para calcular la
     integral definida, mientras que `integrate' puede hacer uso de
     varias heurísticas y reconocer así casos especiales.


 -- Función: residue (<expr>, <z>, <z_0>)
     Calcula el residuo en el plano complejo de la expresión  <expr>
     cuando la variable <z> toma el valor <z_0>.  El residuo es el
     coeficiente de `(<z> - <z_0>)^(-1)' en el desarrollo de Laurent de
     <expr>.

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6


 -- Función: risch (<expr>, <x>)
     Integra <expr> respecto de <x> utilizando el caso trascendental
     del algoritmo de Risch. El caso algebraico del algoritmo de Risch
     no se ha implementado. Este método trata los casos de
     exponenciales y logaritmos anidados que no resuelve el
     procedimiento principal de `integrate'. La función `integrate'
     llamará automáticamente a `risch' si se presentan estos casos.

     Si la variable `erfflag' vale `false', evita que `risch'
     introduzca la función `erf' en la respuesta si ésta no estaba
     presente previamente en el integrando.

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)


 -- Función: tldefint (<expr>, <x>, <a>, <b>)
     Equivale a `ldefint' cuando `tlimswitch' vale `true'.



File: maxima.info,  Node: Introducción a QUADPACK,  Next: Funciones y variables para QUADPACK,  Prev: Funciones y variables para integración,  Up: Integración

20.3 Introducción a QUADPACK
============================

QUADPACK es un conjunto de funciones para el cálculo numérico de
integrales definidas de una variable. Se creó a partir de un trabajo
conjunto de R. Piessens (1), E. de Doncker (2), C. Ueberhuber (3), and
D. Kahaner (4).

   La librería QUADPACK incluida en Maxima es una traducción automática
(mediante el programa `f2cl') del código fuente Fortran de QUADPACK tal
como se encuentra en la SLATEC Common Mathematical Library,Versión 4.1
(5).  La librería SLATEC está fechada en julio de 1993, pero las
funciones QUADPACK fueron escritas algunos años antes.  Hay otra
versión de QUADPACK en Netlib (6), pero no está claro hasta qué punto
difiere de la que forma parte de la librería SLATEC.

   Las funciones QUADPACK incluidas en Maxima son todas automáticas, en
el sentido de que estas funciones intentan calcular sus resultados con
una exactitud especificada, requiriendo un número indeterminado de
evaluaciones de funciones.  La traducción a Lisp que Maxima hace de
QUADPACK incluye también algunas funciones que no son automáticas, pero
que no son accesibles desde el nivel de Maxima.

   Se puede encontrar más información sobre QUADPACK  en el libro (7).

20.3.1 Perspectiva general
--------------------------

`quad_qag'
     Integración de una función general en un intervalo finito.  La
     función `quad_qag' implementa un integrador global adaptativo
     simple utilizando una estrategia de Aind (Piessens, 1973).  Se
     puede escoger entre seis pares de fórmulas de cuadratura de
     Gauss-Kronrod para la regla de evaluación.  Las reglas de rango
     superior son útiles en los casos en los que los integrandos tienen
     un alto grado de oscilación.

`quad_qags'
     Integración de una función general en un intervalo finito.  La
     función `quad_qags' implementa la subdivisión de intervalos global
     adaptativa con extrapolación (de Doncker, 1978) mediante el
     algoritmo Epsilon  (Wynn, 1956).

`quad_qagi'
     Integración de una función general en un intervalo infinito o
     semi-infinito.  El intervalo se proyecta sobre un intervalo finito
     y luego se aplica la misma estrategia que en `quad_qags'.

`quad_qawo'
     Integración de cos(omega x) f(x) o sin(omega x) f(x) en un
     intervalo finito, siendo omega una constante. La regla de
     evaluación se basa en la técnica modificada de Clenshaw-Curtis.
     La función `quad_qawo' aplica la subdivisión adaptativa con
     extrapolación, de forma similar a `quad_qags'.

`quad_qawf'
     Calcula la transformada seno o coseno de Fourier en un intervalo
     semi-infinito.  Se aplica el mismo método que en `quad_qawo' a
     sucesivos intervalos finitos, acelerando la convergencia mediante
     el algoritmo Epsilon (Wynn, 1956).

`quad_qaws'
     Integración de w(x) f(x) en un intervalo finito [a, b], siendo w
     una función de la forma (x - a)^alpha (b - x)^beta v(x), con  v(x)
     igual a 1, a log(x - a), a log(b - x) o a log(x - a) log(b - x) y
     con alpha > -1, y beta > -1.  Se aplica una estrategia de
     subdivisión adaptativa global, con integración de Clenshaw-Curtis
     modificada en los subintervalos que contienen a a y a b.

`quad_qawc'
     Calcula el valor principal de Cauchy de f(x)/(x - c) en un
     intervalo finito (a, b) para una c dada.  La estrategia es global
     adaptativa, utilizando la integración de Clenshaw-Curtis
     modificada en los subintervalos que contienen a x = c.

   ---------- Footnotes ----------

   (1) Applied Mathematics and Programming Division, K.U. Leuven

   (2) Applied Mathematics and Programming Division, K.U. Leuven

   (3) Institut für Mathematik, T.U. Wien

   (4) National Bureau of Standards, Washington, D.C., U.S.A

   (5) `http://www.netlib.org/slatec'

   (6) `http://www.netlib.org/quadpack'

   (7) R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K.
Kahaner.  QUADPACK: A Subroutine Package for Automatic Integration.
Berlin: Springer-Verlag, 1983, ISBN 0387125531.


File: maxima.info,  Node: Funciones y variables para QUADPACK,  Prev: Introducción a QUADPACK,  Up: Integración

20.4 Funciones y variables para QUADPACK
========================================

 -- Función: quad_qag (<f(x)>, <x>, <a>, <b>, <key>, [<epsrel>,
          <epsabs>, <limit>])
 -- Función: quad_qag (<f>, <x>, <a>, <b>, <key>, [<epsrel>, <epsabs>,
          <limit>])
     Integración de una función general en un intervalo finito.  La
     función `quad_qag' implementa un integrador global adaptativo
     simple utilizando una estrategia de Aind (Piessens, 1973).  Se
     puede escoger entre seis pares de fórmulas de cuadratura de
     Gauss-Kronrod para la regla de evaluación.  Las reglas de rango
     superior son útiles en los casos en los que los integrandos tienen
     un alto grado de oscilación.

     La función `quad_qag' calcula numéricamente la integral

     integrate (f(x), x, a, b)

     utilizando un integrador adaptativo simple.

     La función a integrar es <f(x)>, con variable independiente <x>,
     siendo el intervalo de integración el comprendido entre <a> y <b>.
     El argumento <key> indica el integrador a utilizar y debe ser un
     número entero entre 1 y 6, ambos inclusive.  El valor de <key>
     selecciona el orden de la regla de integración de Gauss-Kronrod.
     Las reglas de rango superior son útiles en los casos en los que
     los integrandos tienen un alto grado de oscilación.

     El integrando se puede especificar con el nombre de una función u
     operador de Maxima o de Lisp, como una expresión lambda o como una
     expresión general de Maxima.

     La integración numérica se hace de forma adaptativa particionando
     la región de integración en subintervalos hasta conseguir la
     precisión requerida.

     Los argumentos opcionales pueden especificarse en cualquier orden.
     Todos ellos toman la forma `key=val'. Tales argumentos son:

    <epsrel>
          Error relativo deseado de la aproximación. El valor por
          defecto es 1d-8.

    <epsabs>
          Error absoluto deseado de la aproximación. El valor por
          defecto es 0.

    <limit>
          Tamaño del array interno utilizado para realizar la
          cuadratura.  <limit> es el número máximo de subintervalos a
          utilizar. El valor por defecto es 200.

     La función `quad_qag' devuelve una lista de cuatro elementos:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3, 'epsrel=5d-8);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9

 -- Función: quad_qags (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- Función: quad_qags (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
     Integración de una función general en un intervalo finito.  La
     función `quad_qags' implementa la subdivisión de intervalos global
     adaptativa con extrapolación (de Doncker, 1978) mediante el
     algoritmo Epsilon  (Wynn, 1956).

     La función `quad_qags' calcula la integral

     integrate (f(x), x, a, b)

     La función a integrar es <f(x)>, de variable independiente <x>,
     siendo el intervalo de integración el comprendido entre <a> y <b>.

     El integrando se puede especificar con el nombre de una función u
     operador de Maxima o de Lisp, como una expresión lambda o como una
     expresión general de Maxima.

     Los argumentos opcionales pueden especificarse en cualquier orden.
     Todos ellos toman la forma `key=val'. Tales argumentos son:

    <epsrel>
          Error relativo deseado de la aproximación. El valor por
          defecto es 1d-8.

    <epsabs>
          Error absoluto deseado de la aproximación. El valor por
          defecto es 0.

    <limit>
          Tamaño del array interno utilizado para realizar la
          cuadratura.  <limit> es el número máximo de subintervalos a
          utilizar. El valor por defecto es 200.

     La función `quad_qags' devuelve una lista de cuatro elementos:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `4'
          fallo de convergencia;

    `5'
          la integral es probablemente divergente o de convergencia
          lenta;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0, 1, 'epsrel=1d-10);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

     Nótese que `quad_qags' es más precisa y eficiente que `quad_qag'
     para este integrando.


 -- Función: quad_qagi (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- Función: quad_qagi (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
     Integración de una función general en un intervalo infinito o
     semi-infinito.  El intervalo se proyecta sobre un intervalo finito
     y luego se aplica la misma estrategia que en `quad_qags'.

     La función `quad_qagi' calcula cualquiera las siguientes
     integrales:

     integrate (f(x), x, a, inf)

     integrate (f(x), x, minf, a)

     integrate (f(x), x, minf, inf)

     utilizando la rutina QAGI de Quadpack QAGI. La función a integrar
     es <f(x)>, con variable independiente <x>, siendo el intervalo de
     integración de rango infinito.

     El integrando se puede especificar con el nombre de una función u
     operador de Maxima o de Lisp, como una expresión lambda o como una
     expresión general de Maxima.

     Uno de los límites de integración debe ser infinito. De no ser
     así, `quad_qagi' devolverá una forma nominal.

     Los argumentos opcionales pueden especificarse en cualquier orden.
     Todos ellos toman la forma `key=val'. Tales argumentos son:

    <epsrel>
          Error relativo deseado de la aproximación. El valor por
          defecto es 1d-8.

    <epsabs>
          Error absoluto deseado de la aproximación. El valor por
          defecto es 0.

    <limit>
          Tamaño del array interno utilizado para realizar la
          cuadratura.  <limit> es el número máximo de subintervalos a
          utilizar. El valor por defecto es 200.

     La función `quad_qagi' devuelve una lista de cuatro elementos:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `4'
          fallo de convergencia;

    `5'
          la integral es probablemente divergente o de convergencia
          lenta;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf, 'epsrel=1d-8);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32


 -- Función: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, [<epsrel>,
          <epsabs>, <limit>])
 -- Función: quad_qawc (<f>, <x>, <c>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
     Calcula el valor principal de Cauchy de f(x)/(x - c) en un
     intervalo finito (a, b) para una c dada.  La estrategia es global
     adaptativa, utilizando la integración de Clenshaw-Curtis
     modificada en los subintervalos que contienen a x = c.

     La función `quad_qawc' calcula el valor principal de Cauchy de

     integrate (f(x)/(x - c), x, a, b)

     utilizando la rutina QAWC de Quadpack.  La función a integrar es
     `<f(x)>/(<x> - <c>)', con variable independiente <x>, siendo el
     intervalo de integración el comprendido entre <a> y <b>.

     El integrando se puede especificar con el nombre de una función u
     operador de Maxima o de Lisp, como una expresión lambda o como una
     expresión general de Maxima.

     Los argumentos opcionales pueden especificarse en cualquier orden.
     Todos ellos toman la forma `key=val'. Tales argumentos son:

    <epsrel>
          Error relativo deseado de la aproximación. El valor por
          defecto es 1d-8.

    <epsabs>
          Error absoluto deseado de la aproximación. El valor por
          defecto es 0.

    <limit>
          Tamaño del array interno utilizado para realizar la
          cuadratura.  <limit> es el número máximo de subintervalos a
          utilizar. El valor por defecto es 200.

     `quad_qawc' returns a list of four elements:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5,
                           'epsrel=1d-7);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
                           x, 0, 5);
          Principal Value
                  alpha        9 4                 9
                 4      log(-------------- + --------------)
                             alpha + 3        alpha + 3
                            4          + 4   4          + 4
          (%o2) (-------------------------------------------
                                   alpha
                                2 4      + 2
              3 alpha                   3 alpha
              -------                   -------
                 2          alpha/2        2              alpha/2
             4        atan(4       )   4        atan(- 4 4       )
           - ----------------------- + ---------------------------)
                    alpha                       alpha
                   4      + 1                  4      + 1
            alpha
          /2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917


 -- Función: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, [<epsabs>,
          <limit>, <maxp1>, <limlst>])
 -- Función: quad_qawf (<f>, <x>, <a>, <omega>, <trig>, [<epsabs>,
          <limit>, <maxp1>, <limlst>])
     Calcula la transformada seno o coseno de Fourier en un intervalo
     semi-infinito.  Se aplica el mismo método que en `quad_qawo' a
     sucesivos intervalos finitos, acelerando la convergencia mediante
     el algoritmo Epsilon (Wynn, 1956).

     La función `quad_qawf' calcula la integral

     integrate (f(x)*w(x), x, a, inf)

     La función peso w se selecciona mediante <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     El integrando se puede especificar con el nombre de una función u
     operador de Maxima o de Lisp, como una expresión lambda o como una
     expresión general de Maxima

     Los argumentos opcionales pueden especificarse en cualquier orden.
     Todos ellos toman la forma `key=val'. Tales argumentos son:

    <epsabs>
          El error absoluto deseado para la aproximación. El valor por
          defecto es 1d-10.

    <limit>
          Tamaño del arreglo interno de trabajo.  (<limit> -
          <limlst>)/2 es el número máximo de subintervalos para la
          partición. El valor por defecto es 200.

    <maxp1>
          Número máximo de momentos de Chebyshev. Debe ser mayor que 0.
          El valor por defecto es 100.

    <limlst>
          Cota superior del número de ciclos. Debe ser mayor o igual
          que 3.  El valor por defecto es 10.

     `quad_qawf' returns a list of four elements:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos, 'epsabs=1d-9);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714


 -- Función: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>,
          [<epsrel>, <epsabs>, <limit>, <maxp1>, <limlst>])
 -- Función: quad_qawo (<f>, <x>, <a>, <b>, <omega>, <trig>, [<epsrel>,
          <epsabs>, <limit>, <maxp1>, <limlst>])
     Integración de cos(omega x) f(x) o sin(omega x) f(x) en un
     intervalo finito, siendo omega una constante. La regla de
     evaluación se basa en la técnica modificada de Clenshaw-Curtis.
     La función `quad_qawo' aplica la subdivisión adaptativa con
     extrapolación, de forma similar a `quad_qags'.

     La función `quad_qawo' realiza la integración utilizando la rutina
     QAWO de Quadpack:

     integrate (f(x)*w(x), x, a, b)

     La función peso w se selecciona mediante <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     El integrando se puede especificar con el nombre de una función u
     operador de Maxima o de Lisp, como una expresión lambda o como una
     expresión general de Maxima

     Los argumentos opcionales pueden especificarse en cualquier orden.
     Todos ellos toman la forma `key=val'. Tales argumentos son:

    <epsrel>
          El error absoluto deseado para la aproximación. El valor por
          defecto es 1d-8.

    <epsabs>
          Error absoluto deseado de la aproximación. El valor por
          defecto es 0.

    <limit>
          Tamaño del arreglo interno de trabajo. <limit>/2 es el número
          máximo de subintervalos para la partición. El valor por
          defecto es 200.

    <maxp1>
          Número máximo de momentos de Chebyshev. Debe ser mayor que 0.
          El valor por defecto es 100.

    <limlst>
          Cota superior del número de ciclos. Debe ser mayor o igual
          que 3.  El valor por defecto es 10.

     `quad_qawo' returns a list of four elements:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
                                     x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716


 -- Función: quad_qaws (<f(x)>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          [<epsrel>, <epsabs>, <limit>])
 -- Función: quad_qaws (<f>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          [<epsrel>, <epsabs>, <limit>])
     Integración de w(x) f(x) en un intervalo finito [a, b], siendo w
     una función de la forma (x - a)^alpha (b - x)^beta v(x), con  v(x)
     igual a 1, a log(x - a), a log(b - x) o a log(x - a) log(b - x) y
     con alpha > -1, y beta > -1.  Se aplica una estrategia de
     subdivisión adaptativa global, con integración de Clenshaw-Curtis
     modificada en los subintervalos que contienen a a y a b.

     La función `quad_qaws' realiza la integración utizando la rutina
     QAWS de Quadpack:

     integrate (f(x)*w(x), x, a, b)

     La función peso w se selecciona mediante <wfun>:

    `1'
          w(x) = (x - a)^alfa (b - x)^beta

    `2'
          w(x) = (x - a)^alfa (b - x)^beta log(x - a)

    `3'
          w(x) = (x - a)^alfa (b - x)^beta log(b - x)

    `4'
          w(x) = (x - a)^alfa (b - x)^beta log(x - a) log(b - x)

     El integrando se puede especificar con el nombre de una función u
     operador de Maxima o de Lisp, como una expresión lambda o como una
     expresión general de Maxima

     Los argumentos opcionales pueden especificarse en cualquier orden.
     Todos ellos toman la forma `key=val'. Tales argumentos son:

    <epsrel>
          El error absoluto deseado para la aproximación. El valor por
          defecto es 1d-8.

    <epsabs>
          Error absoluto deseado de la aproximación. El valor por
          defecto es 0.

    <limit>
          Tamaño del array interno utilizado para realizar la
          cuadratura.  (<limit> - <limlst>)/2 es el número máximo de
          subintervalos a utilizar. El valor por defecto es 200.

     `quad_qaws' returns a list of four elements:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1,
                           'epsabs=1d-9);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829



File: maxima.info,  Node: Ecuaciones,  Next: Ecuaciones Diferenciales,  Prev: Integración,  Up: Top

21 Ecuaciones
*************

* Menu:

* Funciones y variable para las ecuaciones::


File: maxima.info,  Node: Funciones y variable para las ecuaciones,  Prev: Ecuaciones,  Up: Ecuaciones

21.1 Funciones y variable para las ecuaciones
=============================================

 -- Variable del sistema: %rnum_list
     Valor por defecto: `[]'

     La variable `%rnum_list' es la lista de variables introducidas en
     las soluciones por la función `algsys'.  Las variables `%r' se
     añaden a `%rnum_list' en su orden de creación. Esto es útil para
     hacer sustituciones en la solución.

          (%i1) solve ([x + y = 3], [x,y]);
          (%o1)              [[x = 3 - %r1, y = %r1]]
          (%i2) %rnum_list;
          (%o2)                       [%r1]
          (%i3) sol : solve ([x + 2*y + 3*z = 4], [x,y,z]);
          (%o3)   [[x = - 2 %r3 - 3 %r2 + 4, y = %r3, z = %r2]]
          (%i4) %rnum_list;
          (%o4)                     [%r2, %r3]
          (%i5) for i : 1 thru length (%rnum_list) do
                  sol : subst (t[i], %rnum_list[i], sol)$
          (%i6) sol;
          (%o6)     [[x = - 2 t  - 3 t  + 4, y = t , z = t ]]
                               2      1           2       1

 -- Variable opcional: algexact
     Default value: `false'

     El contenido de la variable `algexact' afecta al comportamiento de
     `algsys' de la siguiente forma:

     Si `algexact' vale `true', `algsys' llamará siempre a `solve' y
     luego utilizará `realroots'.

     Si `algexact' vale `false', `solve' será llamada sólo si la
     ecuación no es univariante, o si es cuadrática o bicuadrática.

     Sin embargo, `algexact: true' no garantiza que únicamente se
     obtengan soluciones exactas, ya que aunque `algsys' intente
     siempre dar soluciones exactas, dará resultados aproximados si no
     encuentra una solución mejor.


 -- Función: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Función: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Resuelve el sistema de ecuaciones polinómicas <expr_1>, ...,
     <expr_m> o las ecuaciones <eqn_1>, ..., <eqn_m> para las variables
     <x_1>, ..., <x_n>.  La expresión <expr> equivale a la ecuación
     `<expr> = 0'. Puede haber más ecuaciones que variables o viceversa.

     La función `algsys' devuelve una lista de soluciones, cada una de
     las cuales consistente a su vez en una lista de ecuaciones
     asociando valores a las variables <x_1>, ..., <x_n> que satisfacen
     el sistema de ecuaciones.  Si `algsys' no puede encontrar
     soluciones devuelve la lista vacía `[]'.

     Si es necesario se introducen en la solución los símbolos  `%r1',
     `%r2', ..., para representar parámetros arbitrarios; estas
     variables también se añaden a la lista `%rnum_list'.

     El proceso que se sigue es el siguiente:

     (1) Primero se factorizan las ecuaciones y se reparten en
     subsistemas.

     (2) Para cada subsistema <S_i>, se seleccionan una ecuación <E> y
     una variable <x>. Se elige la variable que tenga grado menor.
     Entonces se calcula el resultado de <E> y <E_j> respecto de <x>,
     siendo las <E_j> el resto de ecuaciones del subsistema <S_i>. De
     aquí se obtiene otro subsistema <S_i'> con una incógnita menos, ya
     que <x> ha sido eliminada. El proceso ahora vuelve al paso (1).

     (3) En ocasiones se obtiene un subsistema consistente en una única
     ecuación. Si la ecuación es multivariante y no se han introducido
     aproximaciones en formato decimal de coma flotante, entonces  se
     llama a `solve' para tratar de encontrar una solución exacta.

     En algunos casos, `solve' no puede encontrar la solución, o si lo
     consigue puede que el resultado tenga una expresión muy grande.

     Si la ecuación tiene una sóla incógnita y es lineal, o cuadrática
     o bicuadrática, entonces se llama a la función `solve' si no se
     han introducido aproximaciones en formato decimal. Si se han
     introducido aproximaciones, o si hay más de una incógnita, o si no
     es lineal, ni cuadrática ni bicuadrática, y si la variables
     `realonly' vale `true', entonces se llama a la función `realroots'
     para calcular las soluciones reales.  Si `realonly' vale `false',
     entonces se llama a `allroots' para obtener las soluciones reales
     y complejas.

     Si `algsys' devuelve una solución que tiene menos dígitos
     significativos de los requeridos, el usuario puede cambiar a
     voluntad el valor de `algepsilon' para obtener mayor precisión.

     Si `algexact' vale `true', se llamará siempre a `solve'.

     Cuando `algsys' encuentra una ecuación con múltiples incógnitas y
     que contiene aproximaciones en coma flotante (normalmente debido a
     la imposibilidad de encontrar soluciones exactas en pasos
     anteriores), entonces no intenta aplicar los métodos exactos a
     estas ecuaciones y presenta el mensaje: "`algsys' cannot solve -
     system too complicated."

     Las interacciones con `radcan' pueden dar lugar a expresiones
     grandes o complicadas. En tal caso, puede ser posible aislar
     partes del resultado con  `pickapart' o `reveal'.

     Ocasionalmente, `radcan' puede introducir la unidad imaginaria
     `%i' en una solución que de hecho es real.

     Ejemplos:

          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3


 -- Función: allroots (<expr>)
 -- Función: allroots (<eqn>)
     Calcula aproximaciones numéricas de las raíces reales y complejas
     del polinomio <expr> o ecuación polinómica <eqn> de una variable.

     Si la variable `polyfactor' vale `true' hace que la función
     `allroots' factorice el polinomio para números reales si el
     polinomio es real, o para números complejos si el polinomio es
     complejo.

     La función `allroots' puede dar resultados inexactos en caso de
     que haya raíces múltiples.  Si el polinomio es real, `allroots
     (%i*<p>)') puede alcanzar mejores aproximaciones que `allroots
     (<p>)', ya que `allroots' ejecuta entonces un algoritmo diferente.

     La función `allroots' no opera sobre expresiones no polinómicas,
     pues requiere que el numerador sea reducible a un polinomio y el
     denominador sea, como mucho, un número complejo.

     Para polinomios complejos se utiliza el algoritmo de Jenkins y
     Traub descrito en (Algorithm 419, Comm. ACM, vol. 15, (1972), p.
     97). Para polinomios reales se utiliza el algoritmo de Jenkins
     descrito en (Algorithm 493, ACM TOMS, vol. 1, (1975), p.178).

     Ejemplos:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)


 -- Función: bfallroots (<expr>)
 -- Función: bfallroots (<eqn>)
     Calcula aproximaciones numéricas de las raíces reales y complejas
     del polinomio <expr> o de la ecuación polinómica <eqn> de una
     variable.

     En todos los aspectos, `bfallroots' es idéntica a `allroots',
     excepto que `bfallroots' calcula las raíces en formato bigfloat
     (números decimales de precisión arbitraria).

     Véase `allroots' para más información.

 -- Variable opcional: backsubst
     Valor por defecto: `true'

     Si `backsubst' vale `false', evita la retrosustitución en
     `linsolve' tras la triangularización de las ecuaciones.  Esto
     puede ser de utilidad en problemas muy grandes, en los que la
     retrosustitución puede provocar la generación de expresiones
     extremadamente largas.

          (%i1) eq1 : x + y + z = 6$
          (%i2) eq2 : x - y + z = 2$
          (%i3) eq3 : x + y - z = 0$
          (%i4) backsubst : false$
          (%i5) linsolve ([eq1, eq2, eq3], [x,y,z]);
          (%o5)             [x = z - y, y = 2, z = 3]
          (%i6) backsubst : true$
          (%i7) linsolve ([eq1, eq2, eq3], [x,y,z]);
          (%o7)               [x = 1, y = 2, z = 3]


 -- Variable opcional: breakup
     Valor por defecto: `true'

     Si `breakup' vale `true', `solve' expresa sus soluciones a las
     ecuaciones cúbicas y cuárticas en términos de subexpresiones
     comunes, las cuales son asignadas a etiquetas del tipo `%t1',
     `%t2', etc.  En otro caso, no se identifican subexpresiones
     comunes.

     La asignación `breakup: true' sólo tiene efecto cuando
     `programmode' vale `false'.

     Ejemplos:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]


 -- Función: dimension (<eqn>)
 -- Función: dimension (<eqn_1>, ..., <eqn_n>)
     El paquete `dimen' es para análisis dimensional. La instrucción
     `load ("dimen")' carga el paquete y `demo ("dimen")' presenta una
     pequeña demostración.


 -- Variable opcional: dispflag
     Valor por defecto: `true'

     Si `dispflag' vale `false', entonces se inhibirá que Maxima
     muestre resultados de las funciones que resuelven ecuaciones
     cuando éstas son llamadas desde dentro de un bloque (`block').
     Cuando un bloque termina con el signo del dólar, $, a la variable
     `dispflag' se le asigna `false'.


 -- Función: funcsolve (<eqn>, <g>(<t>))
     Devuelve `[<g>(<t>) = ...]'  o `[]', dependiendo de que exista o
     no una función racional  `<g>(<t>)' que satisfaga <eqn>, la cual
     debe ser un polinomio de primer orden, lineal para `<g>(<t>)' y
     `<g>(<t>+1)'

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1)
                           = (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Dependent equations eliminated:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Aviso: esta es una implemetación rudimentaria, por lo que debe ser
     utilizada con cautela.


 -- Variable opcional: globalsolve
     Valor por defecto: `false'

     Si `globalsolve' vale `true', a las incógnitas de las ecuaciones
     se les asignan las soluciones encontradas por `linsolve' y por
     `solve' cuando se resuelven sistemas de dos o más ecuaciones
     lineales.

     Si `globalsolve' vale `false', las soluciones encontradas por
     `linsolve' y por `solve' cuando se resuelven sistemas de dos o más
     ecuaciones lineales se expresan como ecuaciones y a las incógnitas
     no se le asignan valores.

     Cuando se resuelven ecuaciones que no son sistemas de dos o más
     ecuaciones lineales, `solve' ignora el valor de `globalsolve'.
     Otras funciones que resuelven ecuaciones (como `algsys') ignoran
     siempre el valor de `globalsolve'.

     Ejemplos:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y


 -- Función: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     El paquete `inteqn' se dedica a la resolución de ecuaciones
     integrales. Para hacer uso de él, ejecutar la instrucción `load
     ("inteqn")'.

     El argumento <ie> es la ecuación integral; <unk> es la función
     incógnita; <tech> es el método a aplicar para efectuar la
     resolución del problema (<tech> = `first' significa: aplica el
     primer método que encuentre una solución; <tech> = `all'
     significa: aplica todos los métodos posibles); <n> es el número
     máximo de términos que debe tomar `taylor', `neumann',
     `firstkindseries' o `fredseries' (también es el máximo nivel de
     recursión para el método de diferenciación); <guess> es la
     solución candidata inicial para `neumann' o `firstkindseries'.

     Valores por defecto para los argumentos segundo a quinto son:

     <unk>: `<p>(<x>)', donde <p> es la primera función desconocida que
     Maxima encuentra en el integrando y <x> es la variable que actúa
     como argumento en la primera aparición de <p> encontrada fuera de
     una integral en el caso de ecuaciones de segunda especie
     (`secondkind'), o es la única variable aparte de la de integración
     en el caso de ecuaciones de primera especie (`firstkind'). Si el
     intento de encontrar <x> falla, el usuario será consultado para
     suministrar una variable independiente.


 -- Variable opcional: ieqnprint
     Valor por defecto: `true'

     La variable `ieqnprint' controla el comportamiento del resultado
     retornado por la instrucción `ieqn'. Si `ieqnprint' vale `false',
     la lista devuelta por la función `ieqn' tiene el formato

     [<solución>, <método utilizado>, <nterms>, <variable>]

     donde <variable> estará ausente si la solución es exacta; en otro
     caso, será la palabra `approximate' o `incomplete' según que la
     solución sea inexacta o que no tenga forma explícita,
     respectivamente. Si se ha utilizado un método basado en series,
     <nterms> es el número de términos utilizado, que puede ser menor
     que el `n' dado a `ieqn'.


 -- Función: lhs (<expr>)
     Devuelve el miembro izquierdo (es decir, el primer argumento) de
     la expresión <expr>, cuando el operador de <expr> es uno de los
     operadores de relación `< <= = # equal notequal >= >', o un
     operadores de asignación `:= ::= : ::', o un operador infijo
     binario definido por el usuario mediante `infix'.

     Si <expr> es un átomo o si su operador es diferente de los citados
     más arriba, `lhs' devuelve <expr>.

     Véase también `rhs'.

     Ejemplo:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb),
                 lhs (aa >= bb), lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)),
                 lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa


 -- Función: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     Resuelve la lista de ecuaciones lineales simultáneas para la lista
     de variables. Las expresiones deben ser polinomios lineales
     respecto de las variables o ecuaciones.

     Si `globalsolve' vale `true', a cada incógnita se le asigna el
     valor de la solución encontrada.

     Si `backsubst' vale `false', `linsolve' no hace la sustitución
     tras la triangulariación de las ecuaciones.  Esto puede ser
     necesario en problemas muy grandes en los que la sustitución puede
     dar lugar a la generación de expresiones enormes.

     Si `linsolve_params' vale `true', `linsolve' también genera
     símbolos `%r' para representar parámetros arbitrarios como los
     descritos para la función `algsys'. Si vale `false', el resultado
     devuelto por `linsolve' expresará, si es el sistema es
     indeterminado, unas variables en función de otras.

     Si `programmode' vale `false', `linsolve' muestra la solución con
     etiquetas de expresiones intermedias (`%t') y devuelve las lista
     de etiquetas.

          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]


 -- Variable opcional: linsolvewarn
     Valor por defecto: `true'

     Si `linsolvewarn' vale `true', `linsolve' mostrará el mensaje:
     "Dependent equations eliminated".


 -- Variable opcional: linsolve_params
     Valor por defecto: `true'

     Si `linsolve_params' vale `true', `linsolve' también genera
     símbolos `%r' para representar parámetros arbitrarios como los
     descritos para la función `algsys'. Si vale `false', el resultado
     devuelto por `linsolve' expresará, si es el sistema es
     indeterminado, unas variables en función de otras.


 -- System variable: multiplicities
     Valor por defecto: `not_set_yet'

     La variable `multiplicities' es una con las multiplicidades de las
     soluciones encontradas por `solve' o `realroots'.


 -- Función: nroots (<p>, <low>, <high>)
     Devuelve el número de raíces reales del polinomio real univariante
     <p> en el intervalo semiabierto `(<low>, <high>]'. Los extremos
     del intervalo pueden ser `minf' o `inf', menos y más infinito.

     La función `nroots' utiliza el método de las secuencias de Sturm.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4


 -- Función: nthroot (<p>, <n>)
     Siendo `p' un polinomio de coeficientes enteros y `n' un entero
     positivo, `nthroot' devuelve un polinomio `q', también de
     coeficientes enteros, tal que `q^n=p', o un mensaje de error
     indicando que `p' no es una `n'-potencia exacta. Esta función es
     bastante más rápida que `factor' y que `sqfr'.


 -- Variable opcional: programmode
     Valor por defecto: `true'

     Si `programmode' vale `true', `solve', `realroots', `allroots' y
     `linsolve' devuelve sus soluciones como elementos de una lista.
     Si `programmode' vale `false', `solve' y las demás crean
     expresiones intermedias etiquetadas `%t1', `t2', etc., y les
     asinan las soluciones.

          (%i1) solve(x^2+x+1);
                              sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o1)        [x = - --------------, x = --------------]
                                    2                   2
          (%i2) programmode:false$
          (%i3) solve(x^2+x+1);
          Solution:

                                        sqrt(3) %i + 1
          (%t3)                   x = - --------------
                                              2

                                       sqrt(3) %i - 1
          (%t4)                    x = --------------
                                             2
          (%o4)                        [%t4, %t5]


 -- Variable opcional: realonly
     Valor por defecto: `false'

     Si `realonly' vale `true', `algsys' sólo devuelve aquellas
     soluciones exentas de la constante `%i'.


 -- Función: realroots (<expr>, <bound>)
 -- Función: realroots (<eqn>, <bound>)
 -- Función: realroots (<expr>)
 -- Función: realroots (<eqn>)
     Calcula aproximaciones racionales de las raíces reales del
     polinomio <expr> o de la ecuación polinómica <eqn> de una variable,
     dentro de la tolerancia especificada por <bound>.  Los
     coeficientes de <expr> o de <eqn> deben ser números literales, por
     lo que las constantes simbólicas como `%pi' no son aceptadas.

     La función `realroots' guarda las multiplicidades de las raíces
     encontradas en la variable global `multiplicities'.

     La función `realroots' genera una secuencia de Sturm para acotar
     cada raíz, aplicando después el método de bisección para afinar
     las aproximaciones. Todos los coeficientes se convierten a formas
     racionales equivalentes antes de comenzar la búsqueda de las
     raíces, de modo que los cálculos se realizan con aritmética exacta
     racional. Incluso en el caso de que algunos coeficientes sean
     números decimales en coma flotante, los resultados son racionales,
     a menos que se les fuerce a ser decimales con las variables
     `float' o `numer'.

     Si <bound> es menor que la unidad, todas las raíces enteras se
     expresan en forma exacta. Si no se especifica <bound>, se le
     supone igual al valor de la variable global `rootsepsilon'.

     Si la variable global `programmode' vale `true', la función
     `realroots' devuelve una lista de la forma `[x = <x_1>, x = <x_2>,
     ...]'.  Si `programmode' vale `false', `realroots' crea etiquetas
     `%t1', `%t2', ... para las expresiones intermedias, les asigna
     valores y, finalmente, devuelve la lista de etiquetas.

     Ejemplos:

          (%i1) realroots (-1 - x + x^5, 5e-6);
                                         612003
          (%o1)                     [x = ------]
                                         524288
          (%i2) ev (%[1], float);
          (%o2)                 x = 1.167303085327148
          (%i3) ev (-1 - x + x^5, %);
          (%o3)                - 7.396496210176905E-6

          (%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
          (%o1)                 [x = 1, x = 2, x = 3]
          (%i2) multiplicities;
          (%o2)                       [5, 3, 1]


 -- Función: rhs (<expr>)
     Devuelve el miembro derecho (es decir, el segundo argumento) de la
     expresión <expr>, cuando el operador de <expr> es uno de los
     operadores de relación `< <= = # equal notequal >= >', o un
     operadores de asignación `:= ::= : ::', o un operador infijo
     binario definido por el usuario mediante `infix'.

     Si <expr> es un átomo o si su operador es diferente de los citados
     más arriba, `rhs' devuelve <expr>.

     Véase también `lhs'.

     Ejemplo:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb),
                 rhs (aa >= bb), rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)),
                 rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb


 -- Variable opcional: rootsconmode
     Valor por defecto: `true'

     La variable `rootsconmode' controla el comportamiento de la
     instrucción `rootscontract'.  Véase `rootscontract' para más
     detalles.


 -- Función: rootscontract (<expr>)
     Convierte productos de raíces en raíces de productos. Por ejemplo,
     `rootscontract (sqrt(x)*y^(3/2))' devuelve `sqrt(x*y^3)'.

     Si `radexpand' vale `true' y `domain' vale `real', `rootscontract'
     convierte `abs' en `sqrt', por ejemplo, `rootscontract
     (abs(x)*sqrt(y))' devuelve `sqrt(x^2*y)'.

     La opción `rootsconmode' afecta el resultado de `rootscontract'
     como sigue:

          Problema            Valor de         Resultadod de
                            rootsconmode        rootscontract

          x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
          x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
          x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
          x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
          x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)

     Si `rootsconmode' vale `false', `rootscontract' contrae sólamente
     respecto de exponentes racionales cuyos denominadores sean
     iguales. La clave para los ejemplos `rootsconmode: true' es
     simplemente que 2 divide a 4 pero no a 3. La asignación
     `rootsconmode: all' hace que se calcule el mínimo común múltiplo
     de los denominadores de los exponentes.

     La función `rootscontract' utiliza `ratsimp' de forma similar a
     como lo hace `logcontract'.

     Ejemplos:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
          (%o13)                          0


 -- Variable opcional: rootsepsilon
     Valor por defecto: 1.0e-7

     La variable `rootsepsilon' es la tolerancia que establece el
     intervalo de confianza para las raíces calculadas por la función
     `realroots'.


 -- Función: solve (<expr>, <x>)
 -- Función: solve (<expr>)
 -- Función: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Resuelve la ecuación algebraica <expr> de incógnita <x> y devuelve
     una lista de igualdades con la <x> despejada.  Si <expr> no es una
     igualdad, se supone que se quiere resolver la ecuación `<expr> =
     0'.  El argumento <x> puede ser una función (por ejemplo, `f(x)'),
     u otra expresión no atómica, excepto una suma o producto. Puede
     omitirse <x> si <expr> contiene solamente una variable. El
     argumento <expr> puede ser una expresión racional y puede contener
     funciones trigonométricas, exponenciales, etc.

     Se utiliza el siguiente método de resolución:

     Sea <E> la expresión y <X> la incógnita. Si <E> es lineal respecto
     de <X> entonces <X> se resuelve de forma trivial. En caso
     contrario, si <E> es de la forma `A*X^N + B' entonces el resultado
     es `(-B/A)^1/N)' multiplicado por las `N'-ésimas raíces de la
     unidad.

     Si <E> no es lineal respecto de <X> entonces el máximo común
     divisor de los exponentes de <X> en <E> (supóngase que es <N>) se
     divide entre los exponentes y la multiplicidad de las raíces se
     multiplica por <N>.  Entonces es llamado recursivamente `solve'
     para este resultado. Si <E> es factorizable entonces `solve' es
     invocado para cada uno de los factores.  Finalmente, `solve'
     usará, según sea necesario, las fórmulas cuadrática, cúbica o
     cuártica.

     En caso de que <E> sea un polinomio respecto de una función de la
     incógnita, por ejemplo `F(X)', entonces se calcula primero para
     `F(X)' (sea <C> el resultado obtenido), entonces la ecuación
     `F(X)=C' se resuelve para <X> en el supuesto que se conozca la
     inversa de la función <F>.

     Si la variable `breakup' vale `false' hará que `solve' muestre las
     soluciones de las ecuaciones cúbicas o cuárticas como expresiones
     únicas, en lugar de utilizar varias subexpresiones comunes, que es
     el formato por defecto.

     A la variable `multiplicities' se le asignará una lista con las
     multiplicidades de las soluciones individuales devueltas por
     `solve', `realroots' o `allroots'. La instrucción `apropos
     (solve)' hará que se muestren las variables optativas que de algún
     modo afectan al comportamiento de `solve'. Se podrá luego utilizar
     la función  `describe' para aquellas variables cuyo objeto no esté
     claro.

     La llamada `solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])'
     resuelve un sistema de ecuaciones polinómicas simultáneas
     (lineales o no) llamando a `linsolve' o `algsys' y devuelve una
     lista de listas con soluciones para las incógnitas. En caso de
     haberse llamado a `linsolve' esta lista contendrá una única lista
     de soluciones. La llamada a `solve' tiene dos listas como
     argumentos. La primera lista tiene las ecuaciones a resolver y la
     segunda son las incógnitas cuyos valores se quieren calcular. Si
     el número de variables en las ecuaciones es igual al número de
     incógnitas, el segundo argumento puede omitirse.

     Si `programmode' vale `false', `solve' muestra la solución con
     etiquetas de expresiones intermedias (`%t') y devuelve las lista
     de etiquetas.

     Si `globalsolve' vale `true' y el problema consiste en resolver un
     sistema de dos o más ecuaciones lineales, a cada incógnita se le
     asigna el valor encontrado en la resolución del sistema.

     Ejemplos:
          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some solutions will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0


 -- Variable opcional: solvedecomposes
     Valor por defecto: `true'

     Si `solvedecomposes' vale `true', `solve' llama a `polydecomp' en
     caso de que se le pida resolver ecuaciones polinómicas.


 -- Variable opcional: solveexplicit
     Valor por defecto: `false'

     Si `solveexplicit' vale `true', le inhibe a `solve' devolver
     soluciones implícitas, esto es, soluciones de la forma `F(x) = 0',
     donde `F' es cierta función.


 -- Variable opcional: solvefactors
     Valor por defecto: `true'

     Si `solvefactors' vale `false', `solve' no intenta factorizar la
     expresión.  Este valor `false' puede ser útil en algunos casos en
     los que la factorización no es necesaria.


 -- Variable opcional: solvenullwarn
     Valor por defecto: `true'

     Si `solvenullwarn' vale `true',  `solve' muestra un mensaje de
     aviso si es llamado con una lista de ecuaciones vacía o con una
     lista de incógnitas vacía. Por ejemplo, `solve ([], [])' imprimirá
     dos mensajes de aviso y devolverá `[]'.


 -- Variable opcional: solveradcan
     Valor por defecto: `false'

     Si `solveradcan' vale `true', `solve' llama a `radcan', lo que
     hará que `solve' se ejecute de forma más lenta, pero permitirá que
     se resuelvan ciertas ecuaciones que contengan exponenciales y
     logaritmos.


 -- Variable opcional: solvetrigwarn
     Valor por defecto: `true'

     Si `solvetrigwarn' vale `true', `solve' puede presentar un mensaje
     diciendo que está utilizando funciones trigonométricas inversas
     para resolver la ecuación, y que por lo tanto puede estar
     ignorando algunas soluciones.



File: maxima.info,  Node: Ecuaciones Diferenciales,  Next: Métodos numéricos,  Prev: Ecuaciones,  Up: Top

22 Ecuaciones Diferenciales
***************************

* Menu:

* Introducción a las ecuaciones diferenciales::
* Funciones y variables para ecuaciones diferenciales::


File: maxima.info,  Node: Introducción a las ecuaciones diferenciales,  Next: Funciones y variables para ecuaciones diferenciales,  Prev: Ecuaciones Diferenciales,  Up: Ecuaciones Diferenciales

22.1 Introducción a las ecuaciones diferenciales
================================================

Esta sección describe las funciones disponibles en Maxima para el
cálculo de las soluciones analíticas de ciertos tipos de ecuaciones de
primer y segundo orden. Para las soluciones numéricas de sistemas de
ecuaciones diferenciales, véase el paquete adicional `dynamics'. Para
las representaciones gráficas en el espacio de fases, véase el paquete
`plotdf'.


File: maxima.info,  Node: Funciones y variables para ecuaciones diferenciales,  Prev: Introducción a las ecuaciones diferenciales,  Up: Ecuaciones Diferenciales

22.2 Funciones y variables para ecuaciones diferenciales.
=========================================================

 -- Función: bc2 (<soluc>, <xval1>, <yval1>, <xval2>, <yval2>)
     Resuelve el problema del valor en la frontera para ecuaciones
     diferenciales de segundo orden.  Aquí, <soluc> es una solución
     general de la ecuación, como las que calcula `ode2', <xval1>
     especifica el valor de la variable independiente en el primer
     punto mediante una expresión de la forma `<x> = <x0>', mientras
     que <yval1> hace lo propio para la variable dependiente.  Las
     expresiones <xval2> y <yval2> dan los valores de estas mismas
     variables en un segundo punto, utilizando el mismo formato.


 -- Función: desolve (<ecu>, <x>)
 -- Función: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     La función `desolve' resuelve sistemas de ecuaciones diferenciales
     ordinarias lineales utilizando la transformada de Laplace.  Aquí
     las <eqi> (`i'=1,..,n) son ecuaciones diferenciales con variables
     dependientes <x_1>, ..., <x_n>. La dependencia funcional de <x_1>,
     ..., <x_n> respecto de una variable independiente, por ejemplo
     <x>, debe indicarse explícitamente, tanto en las variables como en
     las derivadas. Por ejemplo,

          eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
          eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);

     no es el formato apropiado. El método correcto es

          eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
          eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);

     La llamada a la función `desolve' sería entonces
          desolve([eqn_1, eqn_2], [f(x),g(x)]);

     Si las condiciones iniciales en `x=0' son conocidas, deben ser
     suministradas antes de llamar a `desolve' haciendo uso previo de
     la función `atvalue',

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     Si `desolve' no encuentra una solución, entonces devuelve `false'.


 -- Función: ic1 (<soluc>, <xval>, <yval>)
     Resuelve el problema del valor inicial en ecuaciones diferenciales
     de primer orden.  Aquí, <soluc> es una solución general de la
     ecuación, como las que calcula `ode2', <xval> es una ecuación de
     la forma `<x> = <x0>' para la variable independiente y <yval> es
     una ecuación de la forma `<y> = <y0>' para la variable
     dependiente. Véase `ode2' para un ejemplo sobre su utilización.


 -- Función: ic2 (<soluc>, <xval>, <yval>, <dval>)
     Resuelve el problema del valor inicial en ecuaciones diferenciales
     de segundo orden.  Aquí, <soluc> es una solución general de la
     ecuación, como las que calcula `ode2', <xval> es una ecuación de
     la forma `<x> = <x0>' para la variable independiente y <yval> es
     una ecuación de la forma `<y> = <y0>' para la variable
     dependiente, siendo <dval> una expresión de la forma
     `diff(<y>,<x>) = <dy0>' que especifica la primera derivada de la
     variable dependiente respecto de la independiente en el punto
     <xval>.

     Véase `ode2' para un ejemplo de su uso.

 -- Función: ode2 (<ecu>, <dvar>, <ivar>)
     La función `ode2' resuelve ecuaciones diferenciales ordinarias de
     primer y segundo orden. Admite tres argumentos: una ecuación
     diferencial ordinaria <ecu>, la variable dependiente <dvar> y la
     variable independiente <ivar>.  Si ha tenido éxito en la
     resolución de la ecuación, devuelve una solución, explícita o
     implícita, para la variable dependiente. El símbolo `%c' se
     utiliza para representar la constante en el caso de ecuaciones de
     primer orden y los símbolos `%k1' y `%k2' son las constantes de
     las ecuaciones de segundo orden. Si por cualquier razón `ode2' no
     puede calcular la solución, devolverá `false', acompañado quizás
     de un mensaje de error. Los métodos utilizados para las ecuaciones
     de primer orden, en el orden en que se hace la tentativa de
     resolución son: lineal, separable, exacto (pudiendo solicitar en
     este caso un factor de integración), homogéneo, ecuación de
     Bernoulli y un método homogéneo generalizado. Para las ecuaciones
     de segundo orden: coeficiente constante, exacto, homogéneo lineal
     con coeficientes no constantes  que pueden ser transformados en
     coeficientes constantes, ecuación equidimensional o de Euler,
     método de variación de parámetros y ecuaciones exentas de las
     variables dependientes o independientes de manera que se puedan
     reducir a dos ecuaciones lineales de primer a ser resueltas
     secuencialmente. Durante el proceso de resolución de ecuaciones
     diferenciales ordinarias, ciertas variables se utilizan con el
     único propósito de suministrar información al usuario: `method'
     almacena el método utilizado para encontrar la solución (como por
     ejemplo `linear'), `intfactor' para el factor de integración que
     se haya podido utilizar, `odeindex' para el índice del método de
     Bernoulli o el homogéneo generalizado y `yp' para la solución
     particular del método de variación de parámetros.

     A fin de resolver problemas con valores iniciales y problemas con
     valores en la frontera, la función `ic1' está disponible para
     ecuaciones de primer orden y las funciones `ic2' y `bc2' para
     problemas de valores iniciales y de frontera, respectivamente, en
     el caso de las ecuaciones de segundo orden.

     Ejemplo:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2



File: maxima.info,  Node: Métodos numéricos,  Next: Arrays,  Prev: Ecuaciones Diferenciales,  Up: Top

23 Métodos numéricos
********************

* Menu:

* Introducción a los métodos numéricos::
* Series de Fourier::
* Funciones y variables para los métodos numéricos::
* Funciones y variables para las series de Fourier::


File: maxima.info,  Node: Introducción a los métodos numéricos,  Next: Series de Fourier,  Prev: Métodos numéricos,  Up: Métodos numéricos

23.1 Introducción a los métodos numéricos
=========================================


File: maxima.info,  Node: Series de Fourier,  Next: Funciones y variables para los métodos numéricos,  Prev: Introducción a los métodos numéricos,  Up: Métodos numéricos

23.2 Series de Fourier
======================

El paquete `fft' contiene funciones para el cálculo numérico (no
simbólico) de la transformada rápida de Fourier. La instrucción `load
("fft")' carga el paquete. Véase `fft'.

   El paquete `fourie' contiene funciones para el cálculo simbólico de
series de Fourier. La instrucción `load ("fourie")' carga el paquete.
Hay funciones en el paquete `fourie' para calcular los coeficientes de
Fourier y para la transformación de expresiones. Véase `Funciones y
variables para las series de Fourier'.


File: maxima.info,  Node: Funciones y variables para los métodos numéricos,  Next: Funciones y variables para las series de Fourier,  Prev: Series de Fourier,  Up: Métodos numéricos

23.3 Funciones y variables para los métodos numéricos
=====================================================

 -- Función: polartorect (<magnitude_array>, <phase_array>)
     Transforma valores complejos de la forma `r %e^(%i t)' a la forma
     `a + b %i', siendo <r> el módulo y <t> la fase.  Ambos valores <r>
     y <t> son arrays unidimensionales cuyos tamños son iguales a la
     misma potencia de dos.

     Los valores originales de los arrays de entrada son reemplazados
     por las partes real e imaginaria, `a' y `b', de los
     correspondientes números complejos. El resultado se calcula como

          a = r cos(t)
          b = r sin(t)

     `polartorect' es la función inversa de `recttopolar'.

     Para utilizar esta función ejecútese antes `load(fft)'.  Véase
     también `fft'.


 -- Función: recttopolar (<real_array>, <imaginary_array>)
     Transforma valores complejos de la forma `a + b %i' a la forma `r
     %e^(%i t)', siendo <a> la parte real y <a> la imaginaria.  Ambos
     valores <a> y <b> son arrays unidimensionales cuyos tamños son
     iguales a la misma potencia de dos.

     Los valores originales de los arrays de entrada son reemplazados
     por los módulos y las fases, `r' y `t', de los correspondientes
     números complejos. El resultado se calcula como

          r = sqrt(a^2 + b^2)
          t = atan2(b, a)

     El ángulo calculado pertence al rango de `-%pi' a `%pi'.

     `recttopolar' es la función inversa de `polartorect'.

     Para utilizar esta función ejecútese antes `load(fft)'.  Véase
     también `fft'.


 -- Función: inverse_fft (<y>)
     Calcula la transformada inversa rápida de Fourier.

     <y> es una lista o array (declarado o no) que contiene los datos a
     transformar. El número de elementos debe ser una potencia de dos.
     Los elementos deben ser números literales (enteros, racionales, de
     punto flotante o decimales grandes), constantes simbólicas,
     expresiones del tipo `a + b*%i', siendo `a' y `b' números
     literales, o constantes simbólicas.

     La función `inverse_fft' devuelve un nuevo objeto del mismo tipo
     que <y>, el cual no se ve modificado. Los resultados se calculan
     siempre como decimales o expresiones `a + b*%i', siendo `a' y `b'
     decimales.

     La transformada inversa discreta de Fourier se define como se
     indica a continuación. Si `x' es el resultado de la transformada
     inversa, entonces para `j' entre 0 y `n - 1' se tiene

          x[j] = sum(y[k] exp(+2 %i %pi j k / n), k, 0, n - 1)

     Para utilizar esta función ejecútese antes `load(fft)'.

     Véanse también `fft' (transformada directa), `recttopolar' y
     `polartorect'.

     Ejemplos:

     Datos reales.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2, -3, -4] $
          (%i4) L1 : inverse_fft (L);
          (%o4) [0.0, 14.49 %i - .8284, 0.0, 2.485 %i + 4.828, 0.0,
                                 4.828 - 2.485 %i, 0.0, - 14.49 %i - .8284]
          (%i5) L2 : fft (L1);
          (%o5) [1.0, 2.0 - 2.168L-19 %i, 3.0 - 7.525L-20 %i,
          4.0 - 4.256L-19 %i, - 1.0, 2.168L-19 %i - 2.0,
          7.525L-20 %i - 3.0, 4.256L-19 %i - 4.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       3.545L-16

     Datos complejos.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : inverse_fft (L);
          (%o4) [4.0, 2.711L-19 %i + 4.0, 2.0 %i - 2.0,
          - 2.828 %i - 2.828, 0.0, 5.421L-20 %i + 4.0, - 2.0 %i - 2.0,
          2.828 %i + 2.828]
          (%i5) L2 : fft (L1);
          (%o5) [4.066E-20 %i + 1.0, 1.0 %i + 1.0, 1.0 - 1.0 %i,
          1.55L-19 %i - 1.0, - 4.066E-20 %i - 1.0, 1.0 - 1.0 %i,
          1.0 %i + 1.0, 1.0 - 7.368L-20 %i]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       6.841L-17


 -- Función: fft (<x>)
     Calcula la transformada rápida compleja de Fourier.

     <x> es una lista o array (declarado o no) que contiene los datos a
     transformar. El número de elementos debe ser una potencia de dos.
     Los elementos deben ser números literales (enteros, racionales, de
     punto flotante o decimales grandes), constantes simbólicas,
     expresiones del tipo `a + b*%i', siendo `a' y `b' números
     literales, o constantes simbólicas.

     La función `fft' devuelve un nuevo objeto del mismo tipo que <x>,
     el cual no se ve modificado. Los resultados se calculan siempre
     como decimales o expresiones `a + b*%i', siendo `a' y `b'
     decimales.

     La transformada discreta de Fourier se define como se indica a
     continuación. Si `y' es el resultado de la transformada inversa,
     entonces para `k' entre 0 y `n - 1' se tiene

          y[k] = (1/n) sum(x[j] exp(-2 %i %pi j k / n), j, 0, n - 1)

     Si los datos <x> son reales, los coeficientes reales `a' y `b' se
     pueden calcular de manera que

          x[j] = sum (a[k] * cos (2*%pi*j*k / n) + b[k] * sin (2*%pi*j*k / n), k, 0, n/2)

     con

          a[0] = realpart (y[0])
          b[0] = 0

     y, para k entre 1 y n/2 - 1,

          a[k] = realpart (y[k] + y[n - k])
          b[k] = imagpart (y[n - k] - y[k])

     y

          a[n/2] = realpart (y[n/2])
          b[n/2] = 0

     Para utilizar esta función ejecútese antes `load(fft)'.

     Véanse también `inverse_fft' (transformada inversa), `recttopolar'
     y `polartorect'.

     Ejemplos:

     Datos reales.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2, -3, -4] $
          (%i4) L1 : fft (L);
          (%o4) [0.0, - 1.811 %i - .1036, 0.0, .6036 - .3107 %i, 0.0,
                                   .3107 %i + .6036, 0.0, 1.811 %i - .1036]
          (%i5) L2 : inverse_fft (L1);
          (%o5) [1.0, 2.168L-19 %i + 2.0, 7.525L-20 %i + 3.0,
          4.256L-19 %i + 4.0, - 1.0, - 2.168L-19 %i - 2.0,
          - 7.525L-20 %i - 3.0, - 4.256L-19 %i - 4.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       3.545L-16

     Datos complejos.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : fft (L);
          (%o4) [0.5, .3536 %i + .3536, - 0.25 %i - 0.25,
          0.5 - 6.776L-21 %i, 0.0, - .3536 %i - .3536, 0.25 %i - 0.25,
          0.5 - 3.388L-20 %i]
          (%i5) L2 : inverse_fft (L1);
          (%o5) [1.0 - 4.066E-20 %i, 1.0 %i + 1.0, 1.0 - 1.0 %i,
          - 1.008L-19 %i - 1.0, 4.066E-20 %i - 1.0, 1.0 - 1.0 %i,
          1.0 %i + 1.0, 1.947L-20 %i + 1.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       6.83L-17

     Cálculo de los coeficientes del seno y coseno.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, 5, 6, 7, 8] $
          (%i4) n : length (L) $
          (%i5) x : make_array (any, n) $
          (%i6) fillarray (x, L) $
          (%i7) y : fft (x) $
          (%i8) a : make_array (any, n/2 + 1) $
          (%i9) b : make_array (any, n/2 + 1) $
          (%i10) a[0] : realpart (y[0]) $
          (%i11) b[0] : 0 $
          (%i12) for k : 1 thru n/2 - 1 do
             (a[k] : realpart (y[k] + y[n - k]),
              b[k] : imagpart (y[n - k] - y[k]));
          (%o12)                        done
          (%i13) a[n/2] : y[n/2] $
          (%i14) b[n/2] : 0 $
          (%i15) listarray (a);
          (%o15)          [4.5, - 1.0, - 1.0, - 1.0, - 0.5]
          (%i16) listarray (b);
          (%o16)           [0, - 2.414, - 1.0, - .4142, 0]
          (%i17) f(j) := sum (a[k] * cos (2*%pi*j*k / n) + b[k] * sin (2*%pi*j*k / n), k, 0, n/2) $
          (%i18) makelist (float (f (j)), j, 0, n - 1);
          (%o18)      [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]


 -- Variable opcional: fortindent
     Valor por defecto: 0

     La variable `fortindent' controla el margen izquierdo de las
     expresiones que escribe la instrucción `fortran'.  El valor 0
     escribe con un margen normal de 6 espacios; valores positivos
     harán que las expresiones se escriban más a la derecha.


 -- Función: fortran (<expr>)
     Escribe <expr> en código Fortran. La salida se escribe con
     márgenes, y si ésta es demasiado larga `fortran' sigue escribiendo
     en líneas sucesivas. La función `fortran' escribe el operador de
     exponenciación `^' como `**', e imprime un número complejo `a + b
     %i' como `(a,b)'.

     El argumento <expr> puede ser una ecuación. En tal caso, `fortran'
     escribe una sentencia de asignación, dándole el valor del miembro
     derecho de la expresión al miembro izquierdo. En particular, si el
     miembro derecho de <expr> es el nombre de una matriz, entonces
     `fortran' escribe una sentencia de asignación para cada elemento
     de la matriz.

     Si <expr> no es reconozida por `fortran', la expresión se escribe
     en formato `grind' sin avisos. La función `fortran' no reconoce
     listas, arreglos ni funciones.

     La variable `fortindent' controla el margen izquierdo de las
     expresiones que escribe la instrucción `fortran'.  El valor 0
     escribe con un margen normal de 6 espacios; valores positivos
     harán que las expresiones se escriban más a la derecha.

     Si `fortspaces' vale `true', `fortran' rellena las líneas con
     espacios de 80 columnas.

     La función `fortran' evalúa sus argumentos; un argumento precedido
     de apóstrofo previene de la evaluación.  La función `fortran'
     siempre devuelve `done'.

     Ejemplos:


     (%i1) expr: (a + b)^12$
     (%i2) fortran (expr);
           (b+a)**12
     (%o2)                         done
     (%i3) fortran ('x=expr);
           x = (b+a)**12
     (%o3)                         done
     (%i4) fortran ('x=expand (expr));
           x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
          1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
          2   **3+66*a**10*b**2+12*a**11*b+a**12
     (%o4)                         done
     (%i5) fortran ('x=7+5*%i);
           x = (7,5)
     (%o5)                         done
     (%i6) fortran ('x=[1,2,3,4]);
           x = [1,2,3,4]
     (%o6)                         done
     (%i7) f(x) := x^2$
     (%i8) fortran (f);
           f
     (%o8)                         done


 -- Variable opcional: fortspaces
     Valor por defecto: `false'

     Si `fortspaces' vale `true', `fortran' rellena las líneas con
     espacios de 80 columnas.


 -- Función: horner (<expr>, <x>)
 -- Función: horner (<expr>)
     Cambia el formato de <expr> según la regla de Horner utilizando
     <x> como variable principal, si ésta se especifica. El argumento
     `x' se puede omitir, en cuyo caso se considerará como variable
     principal la de <expr> en su formato racional canónico (CRE).

     La función `horner' puede mejorar las estabilidad si `expr' va a
     ser numéricamente evaluada. También es útil si Maxima se utiliza
     para generar programas que serán ejecutados en Fortran. Véase
     también `stringout'.

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154


 -- Función: find_root (<expr>, <x>, <a>, <b>)
 -- Función: find_root (<f>, <a>, <b>)
 -- Variable opcional: find_root_error
 -- Variable opcional: find_root_abs
 -- Variable opcional: find_root_rel
     Calcula una raíz de la expresión <expr> o de la función <f> en el
     intervalo cerrado [<a>, <b>].  La expresión <expr> puede ser una
     ecuación, en cuyo caso `find_root' busca una raíz de `lhs(<expr>)
     - rhs(<expr>)'.

     Dado que Maxima puede evaluar <expr> o <f> en [<a>, <b>],
     entonces, si <expr> o <f> es continua, `find_root' encuentrará la
     raíz buscada; o raíces en caso de existir varias.

     La función `find_root' aplica al principio la búsqueda binaria. Si
     la expresión es lo suficientemente suave, entonces `find_root'
     aplicará el método de interpolación lineal.

     La precisión del resultado se controla con `find_root_abs' y
     `find_root_rel'. La búsqueda se detiene cuando la función alcanza
     valores menores o iguales a `find_root_abs', o cuando dos
     soluciones sucesivas <x_0> y <x_1> se diferencian en una cantidad
     menor o igual a `find_root_rel * max(abs(x_0), abs(x_1))'.  Los
     valores por defecto de `find_root_abs' y `find_root_rel' son ambos
     cero.

     `find_root' espera que la función en cuestión tenga signos
     diferentes en los extremos del intervalo. Si esto no se verifica,
     el comportamiento de `find_root' se controla con `find_root_error'.
     Cuando `find_root_error' vale `true', `find_root' devuelve un
     mensaje de error; en caso contrario, `find_root' devuelve el valor
     de `find_root_error'. El valor por defecto de `find_root_error' es
     `true'.

     Si en algún momento del proceso de búsqueda <f> alcanza un valor
     no numérico, `find_root' devuelve una expresión parcialmente
     evaluada.

     Se ignora el orden de <a> y <b>; la región de búsqueda es
     [min(<a>, <b>), max(<a>, <b>)].

     Ejemplos:

          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981
          (%i6) find_root (exp(x) = y, x, 0, 100);
                                      x
          (%o6)           find_root(%e  = y, x, 0.0, 100.0)
          (%i7) find_root (exp(x) = y, x, 0, 100), y = 10;
          (%o7)                   2.302585092994046
          (%i8) log (10.0);
          (%o8)                   2.302585092994046

 -- Función: newton (<expr>, <x>, <x_0>, <eps>)
     Devuelve una solución aproximada de `<expr> = 0' obtenida por el
     método de Newton, considerando <expr> como una función de una
     variable, <x>.  La búsqueda comienza con `<x> = <x_0>' y continúa
     hasta que se verifique `abs(<expr>) < <eps>', donde <expr> se
     evalúa con el valor actual de <x>.

     La función `newton' permite que en <expr> haya variables no
     definidas, siempre y cuando la condición de terminación
     `abs(<expr>) < <eps>' pueda reducirse a un valor lógico `true' o
     `false'; de este modo, no es necesario que <expr> tome un valor
     numérico.

     Ejecútese `load(newton1)' para cargar esta función.

     Véanse también `realroots', `allroots', `find_root' y `mnewton'.

     Ejemplos:

          (%i1) load (newton1);
          (%o1) /usr/share/maxima/5.10.0cvs/share/numeric/newton1.mac
          (%i2) newton (cos (u), u, 1, 1/100);
          (%o2)                   1.570675277161251
          (%i3) ev (cos (u), u = %);
          (%o3)                 1.2104963335033528E-4
          (%i4) assume (a > 0);
          (%o4)                        [a > 0]
          (%i5) newton (x^2 - a^2, x, a/2, a^2/100);
          (%o5)                  1.00030487804878 a
          (%i6) ev (x^2 - a^2, x = %);
                                                     2
          (%o6)                6.098490481853958E-4 a



File: maxima.info,  Node: Funciones y variables para las series de Fourier,  Prev: Funciones y variables para los métodos numéricos,  Up: Métodos numéricos

23.4 Funciones y variables para las series de Fourier
=====================================================

 -- Función: equalp (<x>, <y>)
     Devuelve `true' si `equal (<x>, <y>)', en otro caso devuelve
     `false'. No devuelve el mensaje de error que se obtiene de  `equal
     (x, y)' en un caso como éste.


 -- Función: remfun (<f>, <expr>)
 -- Función: remfun (<f>, <expr>, <x>)
     La llamada `remfun (<f>, <expr>)' reemplaza todas las
     subexpresiones `<f> (<arg>)' por <arg> en <expr>.

     La llamada `remfun (<f>, <expr>, <x>)' reemplaza todas las
     subexpresiones `<f> (<arg>)' por <arg> en <expr> sólo si <arg>
     contiene a la variable <x>.


 -- Función: funp (<f>, <expr>)
 -- Función: funp (<f>, <expr>, <x>)
     La llamada `funp (<f>, <expr>)' devuelve `true' si <expr> contiene
     la función <f>.

     La llamada `funp (<f>, <expr>, <x>)' devuelve `true' si <expr>
     contiene la función <f> y la variable <x> está presente en el
     argumento de alguna de las presencias de <f>.


 -- Función: absint (<f>, <x>, <halfplane>)
 -- Función: absint (<f>, <x>)
 -- Función: absint (<f>, <x>, <a>, <b>)
     La llamada `absint (<f>, <x>, <halfplane>)' devuelve la integral
     indefinida de <f> con respecto a <x> en el semiplano dado (`pos',
     `neg' o `both'). La función <f> puede contener expresiones de la
     forma `abs (x)', `abs (sin (x))', `abs (a) * exp (-abs (b) * abs
     (x))'.

     La llamada `absint (<f>, <x>)' equivale a `absint (<f>, <x>, pos)'.

     La llamada `absint (<f>, <x>, <a>, <b>)' devuelve la integral
     definida de <f> con respecto a  <x> de <a> a <b>.


 -- Función: fourier (<f>, <x>, <p>)
     Devuelve una lista con los coeficientes de Fourier de `<f>(<x>)'
     definida en el intervalo `[-p, p]'.


 -- Función: foursimp (<l>)
     Simplifica `sin (n %pi)' a 0 si `sinnpiflag' vale `true' y `cos (n
     %pi)' a `(-1)^n' si `cosnpiflag' vale `true'.


 -- Variable opcional: sinnpiflag
     Valor por defecto: `true'

     Véase `foursimp'.


 -- Variable opcional: cosnpiflag
     Valor por defecto: `true'

     Véase `foursimp'.


 -- Función: fourexpand (<l>, <x>, <p>, <limit>)
     Calcula y devuelve la serie de Fourier a partir de la lista de los
     coeficientes de Fourier <l> hasta el término <limit> (<limit>
     puede ser `inf'). Los argumentos <x> y <p> tienen el mismo
     significado que en `fourier'.


 -- Función: fourcos (<f>, <x>, <p>)
     Devuelve los coeficientes de los cosenos de Fourier de `<f>(<x>)'
     definida en `[0, <p>]'.


 -- Función: foursin (<f>, <x>, <p>)
     Devuelve los coeficientes de los senos de Fourier de `<f>(<x>)'
     definida en `[0, <p>]'.


 -- Función: totalfourier (<f>, <x>, <p>)
     Devuelve `fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>,
     <p>, 'inf)'.


 -- Función: fourint (<f>, <x>)
     Calcula y devuelve la lista de los coeficientes integrales de
     Fourier de `<f>(<x>)' definida en `[minf, inf]'.


 -- Función: fourintcos (<f>, <x>)
     Devuelve los coeficientes integrales de los cosenos  `<f>(<x>)' en
     `[0, inf]'.


 -- Función: fourintsin (<f>, <x>)
     Devuelve los coeficientes integrales de los senos  `<f>(<x>)' en
     `[0, inf]'.



File: maxima.info,  Node: Arrays,  Next: Matrices y Álgebra Lineal,  Prev: Métodos numéricos,  Up: Top

24 Arrays
*********

* Menu:

* Funciones y variables para Arrays::


File: maxima.info,  Node: Funciones y variables para Arrays,  Prev: Arrays,  Up: Arrays

24.1 Funciones y variables para Arrays
======================================

 -- Función: array (<nombre>, <dim_1>, ..., <dim_n>)
 -- Función: array (<nombre>, <type>, <dim_1>, ..., <dim_n>)
 -- Función: array ([<nombre_1>, ..., <nombre_m>], <dim_1>, ...,
          <dim_n>)
     Crea un array de dimensión n, que debe ser menor o igual que 5.
     Los subíndices de la i-ésima dimensión son enteros que toman
     valores entre 0 y <dim_i>.

     La llamada `array (<nombre>, <dim_1>, ..., <dim_n>)' crea un array
     de tipo general.

     La llamada `array (<nombre>, <type>, <dim_1>, ..., <dim_n>)' crea
     un array con sus elementos del tipo especificado. El tipo <type>
     puede ser `fixnum' para enteros de tamaño limitado o `flonum' para
     números decimales en coma flotante.

     La llamada `array ([<nombre_1>, ..., <nombre_m>], <dim_1>, ...,
     <dim_n>)' crea m arrays,  todos ellos de igual dimensión.

     Si el usuario asigna un valor a una variable subindicada antes de
     declarar el array correspondiente, entonces se construye un array
     no declarado. Los arrays no declarados, también conocidos por el
     nombre de "arrays de claves" (hashed arrays), son más generales
     que los arrays declarados. El usuario no necesita declarar su
     tamaño máximo y pueden ir creciendo de forma dinámica. Los
     subíndices de los arrays no declarados no necesitan ser
     necesariamente números. Sin embargo, a menos que un array tenga
     sus elementos dispersos, probablemente sea más eficiente
     declararlo siempre que sea posible antes que dejarlo como no
     declarado. La función `array' puede utilizarse para transformar un
     array no declarado a a uno declarado.


 -- Función: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Evalúa `<A> [<i_1>, ..., <i_n>]', donde <A> es un array y <i_1>,
     ..., <i_n> son enteros.

     Esto es como `apply', excepto por el hecho de que el primer
     argumento es un array en lugar de una función.


 -- Función: arrayinfo (<A>)
     Devuelve información sobre el array<A>.  El argumento <A> puede
     ser un array declarado o no declarado, una función array o una
     función subindicada.

     En el caso de arrays declarados, `arrayinfo' devuelve una lista
     que contiene el átomo `declared', el número de dimensiones y el
     tamaño de cada dimensión.  Los elementos del array, tanto los que
     tienen valores asignados como los que no, son devueltos por
     `listarray'.

     En el caso de arrays no declarados (hashed arrays), `arrayinfo'
     devuelve una lista que contiene el átomo `hashed', el número de
     subíndices y los subíndices de aquellos elementos que guarden un
     valor. Los valores son devueltos por `listarray'.

     En el caso de funciones array, `arrayinfo' devuelve una lista que
     contiene el átomo `hashed', el número de subíndices y los
     subíndices para los que la función tiene valores almacenados.  Los
     valores almacenados de la función array son devueltos por
     `listarray'.

     En el caso de funciones subindicadas, `arrayinfo' devuelve una
     lista que contiene el átomo `hashed', el número de subíndices y
     los subíndices para los que hay expresiones lambda.  Las
     expresiones lambda son devueltas por `listarray'.

     Ejemplos:

     `arrayinfo' y `listarray' aplicadas a una array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) arrayinfo (aa);
          (%o4)                 [declared, 2, [2, 3]]
          (%i5) listarray (aa);
          (%o5) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]

     `arrayinfo' y `listarray' aplicadas a una array no declarado
     (hashed arrays).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) arrayinfo (bb);
          (%o3)               [hashed, 1, [BAR], [FOO]]
          (%i4) listarray (bb);
                                        3         2
          (%o4)                 [(c - d) , (b + a) ]

     `arrayinfo' y `listarray' aplicadas a una función array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) arrayinfo (cc);
          (%o4)              [hashed, 2, [4, z], [u, v]]
          (%i5) listarray (cc);
                                        z  v
          (%o5)                        [-, -]
                                        4  u

     `arrayinfo' y `listarray' aplicadas a una función subindicada.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) arrayinfo (dd);
          (%o4)             [hashed, 1, [b + a], [v - u]]
          (%i5) listarray (dd);
                                   b + a                v - u
          (%o5)      [lambda([y], y     ), lambda([y], y     )]


 -- Función: arraymake (<name>, [<i_1>, ..., <i_n>])
     El resultado es una referencia a array no evaluada.

     Devuelve la expresión `<name> [<i_1>, ..., <i_n>]'.

     Esta función es similar a `funmake', excepto que el valor
     retornado es referencia a un array no evaluado, en lugar de una
     llamada a una función no evaluada.

     Ejemplos:

          (%i1) arraymake (A, [1]);
          (%o1)                          A
                                          1
          (%i2) arraymake (A, [k]);
          (%o2)                          A
                                          k
          (%i3) arraymake (A, [i, j, 3]);
          (%o3)                       A
                                       i, j, 3
          (%i4) array (A, fixnum, 10);
          (%o4)                           A
          (%i5) fillarray (A, makelist (i^2, i, 1, 11));
          (%o5)                           A
          (%i6) arraymake (A, [5]);
          (%o6)                          A
                                          5
          (%i7) ''%;
          (%o7)                          36
          (%i8) L : [a, b, c, d, e];
          (%o8)                    [a, b, c, d, e]
          (%i9) arraymake ('L, [n]);
          (%o9)                          L
                                          n
          (%i10) ''%, n = 3;
          (%o10)                          c
          (%i11) A2 : make_array (fixnum, 10);
          (%o11)          {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i12) fillarray (A2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o12)          {Array:  #(1 2 3 4 5 6 7 8 9 10)}
          (%i13) arraymake ('A2, [8]);
          (%o13)                         A2
                                           8
          (%i14) ''%;
          (%o14)                          9


 -- Variable del sistema: arrays
     Valor por defecto: `[]' La variable `arrays' es una lista con
     todos los arrays que han sido alojados, lo que comprende a los
     arrays declarados por `array', a los no declarados (hashed arrays)
     construidos implícitamente (asignando algo al elemento de un
     array) y a las funciones array definidas mediante `:=' y `define'.
     Los arrays definidos mediante `make_array' no se incluyen en este
     grupo.

     Véanse también `array', `arrayapply', `arrayinfo', `arraymake',
     `fillarray', `listarray' y `rearray'.

     Ejemplos:

          (%i1) array (aa, 5, 7);
          (%o1)                          aa
          (%i2) bb [FOO] : (a + b)^2;
                                             2
          (%o2)                       (b + a)
          (%i3) cc [x] := x/100;
                                             x
          (%o3)                      cc  := ---
                                       x    100
          (%i4) dd : make_array ('any, 7);
          (%o4)       {Array:  #(NIL NIL NIL NIL NIL NIL NIL)}
          (%i5) arrays;
          (%o5)                     [aa, bb, cc]


 -- Función: bashindices (<expr>)
     Transforma la expresión <expr> dándole a cada suma y producto un
     único índice. Esto le da a `changevar' mayor precisión cuando
     opera con sumas y productos. La forma del único índice es
     `j<number>'. La cantidad <number> se determina en función de
     `gensumnum', valor que puede cambiar el usuario.  Por ejemplo,
     haciendo `gensumnum:0$'.


 -- Función: fillarray (<A>, <B>)
     Rellena el array <A> con los valores de <B>, que puede ser una
     lista o array.

     Si se ha declarado <A> de un determinado tipo en el momento de su
     creación, sólo podrá contener elementos de ese tipo, produciéndose
     un error en caso de intentar asignarle un elemento de tipo
     distinto.

     Si las dimensiones de los arrays <A> y <B> son diferentes, <A> se
     rellena según el orden de las filas. Si no hay suficientes
     elementos en <B> el último elemento se utiliza para cubrir el
     resto de <A>. Si hay demasiados, los elementos sobrantes son
     ignorados.

     La función `fillarray' devuelve su primer argumento.

     Ejemplos:

     Creación de un array de 9 elementos y posterior relleno a partir
     de una lista.

          (%i1) array (a1, fixnum, 8);
          (%o1)                          a1
          (%i2) listarray (a1);
          (%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
          (%i3) fillarray (a1, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
          (%o3)                          a1
          (%i4) listarray (a1);
          (%o4)              [1, 2, 3, 4, 5, 6, 7, 8, 9]

     Si no hay suficientes elementos para cubrir el array, se repite el
     último elemento. Si hay demasiados, los elementos sobrantes son
     ignorados.

          (%i1) a2 : make_array (fixnum, 8);
          (%o1)             {Array:  #(0 0 0 0 0 0 0 0)}
          (%i2) fillarray (a2, [1, 2, 3, 4, 5]);
          (%o2)             {Array:  #(1 2 3 4 5 5 5 5)}
          (%i3) fillarray (a2, [4]);
          (%o3)             {Array:  #(4 4 4 4 4 4 4 4)}
          (%i4) fillarray (a2, makelist (i, i, 1, 100));
          (%o4)             {Array:  #(1 2 3 4 5 6 7 8)}

     Arrays multidimensionales se rellenan según el orden de las filas.

          (%i1) a3 : make_array (fixnum, 2, 5);
          (%o1)        {Array:  #2A((0 0 0 0 0) (0 0 0 0 0))}
          (%i2) fillarray (a3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o2)        {Array:  #2A((1 2 3 4 5) (6 7 8 9 10))}
          (%i3) a4 : make_array (fixnum, 5, 2);
          (%o3)     {Array:  #2A((0 0) (0 0) (0 0) (0 0) (0 0))}
          (%i4) fillarray (a4, a3);
          (%o4)     {Array:  #2A((1 2) (3 4) (5 6) (7 8) (9 10))}


 -- Función: listarray (<A>)
     Devuelve una lista con los elementos del array <A>.  El argumento
     <A> puede ser un array declarado o no declarado, una función array
     o una función subindicada.

     Los elementos se ordenan en primera instancia respecto del primer
     índice, después respecto del segundo índice y así sucesivamente.
     La ordenación de los índices es la misma que la establecida por
     `orderless'.

     En el caso de arrays no declarados, funciones array y funciones
     subindicadas, los elementos corresponden a los índices devueltos
     por `arrayinfo'.

     Los elementos de los arrays declarados que no tienen valores
     asignados (excepto `fixnum' y `flonum') se devuelven como `#####'.
     Los elementos sin valores asignados de los arrays `fixnum' y
     `flonum' son devueltos como 0 y 0.0, respectivamente.  Los
     elementos sin valor asignado de los arrays no declarados,
     funciones array y funciones subindicadas no son devueltos.

     Ejemplos:

     `listarray' y `arrayinfo' aplicadas a un array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) listarray (aa);
          (%o4) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]
          (%i5) arrayinfo (aa);
          (%o5)                 [declared, 2, [2, 3]]

     `listarray' y `arrayinfo' aplicadas a un array no declarado
     (hashed array).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) listarray (bb);
                                        3         2
          (%o3)                 [(c - d) , (b + a) ]
          (%i4) arrayinfo (bb);
          (%o4)               [hashed, 1, [BAR], [FOO]]

     `listarray' y `arrayinfo' aplicadas a una función array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) listarray (cc);
                                        z  v
          (%o4)                        [-, -]
                                        4  u
          (%i5) arrayinfo (cc);
          (%o5)              [hashed, 2, [4, z], [u, v]]

     `listarray' y `arrayinfo' aplicadas a una función subindicada.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) listarray (dd);
                                   b + a                v - u
          (%o4)      [lambda([y], y     ), lambda([y], y     )]
          (%i5) arrayinfo (dd);
          (%o5)             [hashed, 1, [b + a], [v - u]]


 -- Función: make_array (<tipo>, <dim_1>, ..., <dim_n>)
     Construye y devuelve un array de Lisp. El argumento <tipo> puede
     ser `any', `flonum', `fixnum', `hashed' o `functional'.  Hay n
     índices, y el índice i-ésimo va de  0 a <dim_i> - 1.

     La ventaja de `make_array' sobre `array' estriba en que el valor
     retornado no tiene nombre, y una vez que un puntero deja de
     referenciarlo, el valor desaparece. Por ejemplo, si `y: make_array
     (...)' entonces `y' apunta a un objeto que ocupa cierto espacio en
     la memoria, pero después de `y: false', `y' ya no apunta al
     objeto, por lo que éste puede ser considerado basura y
     posteriormente eliminado.

     Ejemplos:

          (%i1) A1 : make_array (fixnum, 10);
          (%o1)           {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i2) A1 [8] : 1729;
          (%o2)                         1729
          (%i3) A1;
          (%o3)          {Array:  #(0 0 0 0 0 0 0 0 1729 0)}
          (%i4) A2 : make_array (flonum, 10);
          (%o4) {Array:  #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i5) A2 [2] : 2.718281828;
          (%o5)                      2.718281828
          (%i6) A2;
          (%o6)
               {Array:  #(0.0 0.0 2.718281828 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i7) A3 : make_array (any, 10);
          (%o7) {Array:  #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)}
          (%i8) A3 [4] : x - y - z;
          (%o8)                      - z - y + x
          (%i9) A3;
          (%o9) {Array:  #(NIL NIL NIL NIL ((MPLUS SIMP) $X ((MTIMES SIMP)\
           -1 $Y) ((MTIMES SIMP) -1 $Z))
            NIL NIL NIL NIL NIL)}
          (%i10) A4 : make_array (fixnum, 2, 3, 5);
          (%o10) {Array:  #3A(((0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0)) ((0 0 \
          0 0 0) (0 0 0 0 0) (0 0 0 0 0)))}
          (%i11) fillarray (A4, makelist (i, i, 1, 2*3*5));
          (%o11) {Array:  #3A(((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15))
              ((16 17 18 19 20) (21 22 23 24 25) (26 27 28 29 30)))}
          (%i12) A4 [0, 2, 1];
          (%o12)                         12


 -- Función: rearray (<A>, <dim_1>, ..., <dim_n>)
     Cambia las dimensiones de un array. El nuevo array será rellenado
     con los elementos del viejo según el orden de las filas. Si el
     array antiguo era demasiado pequeño, los elementos restantes se
     rellenan con `false', `0.0' o `0', dependiendo del tipo del array.
     El tipo del array no se puede cambiar.


 -- Función: remarray (<A_1>, ..., <A_n>)
 -- Función: remarray (all)
     Borra los arrays y las funciones relacionadas con ellos, liberando
     el espacio de memoria ocupado.  Los argumentos pueden ser arrays
     declarados, arrays no declarados (hashed arrays), funciones array
     y funciones subindicadas.

     La llamada `remarray (all)' borra todos los elementos de la lista
     global `arrays'.

     La función `remarray' devuelve la lista de los arrays borrados.


 -- Función: subvar (<x>, <i>)
     Evalúa la expresión subindicada `<x>[<i>]'.

     La función `subvar' evalúa sus argumentos.

     La instrucción `arraymake (<x>, [<i>]' construye la expresión
     `<x>[<i>]', pero no la evalúa.

     Ejemplos:

          (%i1) x : foo $

          (%i2) i : 3 $

          (%i3) subvar (x, i);
          (%o3)                         foo
                                           3
          (%i4) foo : [aa, bb, cc, dd, ee]$

          (%i5) subvar (x, i);
          (%o5)                          cc
          (%i6) arraymake (x, [i]);
          (%o6)                         foo
                                           3
          (%i7) ''%;
          (%o7)                          cc


 -- Variable opcional: use_fast_arrays
     Valor por defecto: `false'

     Si `use_fast_arrays' vale `true' entonces tan solo se reconocen
     dos tipos de arrays.



File: maxima.info,  Node: Matrices y Álgebra Lineal,  Next: Afines,  Prev: Arrays,  Up: Top

25 Matrices y Álgebra Lineal
****************************

* Menu:

* Introducción a las matrices y el álgebra lineal::
* Funciones y variables para las matrices y el álgebra lineal::


File: maxima.info,  Node: Introducción a las matrices y el álgebra lineal,  Next: Funciones y variables para las matrices y el álgebra lineal,  Prev: Matrices y Álgebra Lineal,  Up: Matrices y Álgebra Lineal

25.1 Introducción a las matrices y el álgebra lineal
====================================================

* Menu:

* Operador punto::
* Vectores::
* Paquete eigen::


File: maxima.info,  Node: Operador punto,  Next: Vectores,  Prev: Introducción a las matrices y el álgebra lineal,  Up: Introducción a las matrices y el álgebra lineal

25.1.1 Operador punto
---------------------

El operador  `.' realiza la multiplicación matricial y el producto
escalar.  Cuando los operandos son dos matrices columna o matrices fila
`a' y `b', la expresión `a.b' es equivalente a `sum (a[i]*b[i], i, 1,
length(a))'.  Si `a' y `b' no son complejos, estamos en el caso del
producto escalar.  En caso de ser `a' y `b' vectores en el campo
complejo, el producto escalar se define como `conjugate(a).b'; la
función `innerproduct' del paquete `eigen' realiza el producto escalar
complejo.

   Cuando los operandos son matrices de índole más general, el
resultado que se obtiene es el producto matricial de `a' por `b'.  El
número de filas de `b' debe ser igual al número de columnas de `a', y
el resultado tiene un número de filas igual al de `a' y un número de
columnas igual al de `b'.

   Al objeto de distinguir `.' como operador aritmético del punto
decimal de la notación en coma flotante, puede ser necesario dejar
espacios a ambos lados.  Por ejemplo, `5.e3' es `5000.0' pero `5 . e3'
es `5' por `e3'.

   Hay algunas variables globales que controlan la simplificación de
expresiones que contengan al operador `.', a saber, `dot',
`dot0nscsimp', `dot0simp', `dot1simp', `dotassoc', `dotconstrules',
`dotdistrib', `dotexptsimp', `dotident', y `dotscrules'.


File: maxima.info,  Node: Vectores,  Next: Paquete eigen,  Prev: Operador punto,  Up: Introducción a las matrices y el álgebra lineal

25.1.2 Vectores
---------------

El paquete `vect' define funciones para análisis vectorial. Para cargar
el paquete en memoria se debe hacer `load ("vect")'  y con `demo
("vect")' se presenta una demostración sobre las funciones del paquete.

   El paquete de análisis vectorial puede combinar y simplificar
expresiones simbólicas que incluyan productos escalares y vectoriales,
junto con los operadores de gradiente, divergencia, rotacional y
laplaciano. La distribución de estos operadores sobre sumas o productos
se gobierna por ciertas variables, al igual que otras transformaciones,
incluida la expansión en componentes en cualquier sistema de
coordenadas especificado.  También hay funciones para obtener el
potencial escalar o vectorial de un campo.

   El paquete `vect' contiene las siguientes funciones: `vectorsimp',
`scalefactors', `express', `potential' y `vectorpotential'.

   Aviso: el paquete `vect' declara el operador `.' como conmutativo.


File: maxima.info,  Node: Paquete eigen,  Prev: Vectores,  Up: Introducción a las matrices y el álgebra lineal

25.1.3 Paquete eigen
--------------------

El paquete `eigen' contiene funciones para el cálculo simbólico de
valores y vectores propios. Maxima carga el paquete automáticamente si
se hace una llamada a cualquiera de las dos funciones `eigenvalues' o
`eigenvectors'. El paquete se puede cargar de forma explícita mediante
`load ("eigen")'.

   La instrucción `demo ("eigen")' hace una demostración de las
funciones de este paquete; `batch ("eigen")' realiza la misma
demostración pero sin pausas entre los sucesivos cálculos.

   Las funciones del paquete `eigen' son `innerproduct', `unitvector',
`columnvector', `gramschmidt', `eigenvalues', `eigenvectors',
`uniteigenvectors' y `similaritytransform'.


File: maxima.info,  Node: Funciones y variables para las matrices y el álgebra lineal,  Prev: Introducción a las matrices y el álgebra lineal,  Up: Matrices y Álgebra Lineal

25.2 Funciones y variables para las matrices y el álgebra lineal
================================================================

 -- Función: addcol (<M>, <lista_1>, ..., <lista_n>)
     Añade la/s columna/s dada/s por la/s lista/s (o matrices) a la
     matriz <M>.


 -- Función: addrow (<M>, <lista_1>, ..., <lista_n>)
     Añade la/s fila/s dada/s por la/s lista/s (o matrices) a la matriz
     <M>.


 -- Función: adjoint (<M>)
     Devuelve el adjunto de la matriz <M>.  La matriz adjunta es la
     transpuesta de la matriz de cofactores de <M>.


 -- Función: augcoefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ...,
          <x_n>])
     Devuelve la matriz aumentada de coeficientes del sistema de
     ecuaciones lineales <eqn_1>, ..., <eqn_m> de variables <x_1>, ...,
     <x_n>. Se trata de la matriz de coeficientes con una columna
     adicional para los términos constantes de cada ecuación, es decir,
     aquellos términos que no dependen de las variables <x_1>, ...,
     <x_n>.

          (%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
          (%i2) augcoefmatrix (m, [x, y]);
                                 [ 2  1 - a  - 5 b ]
          (%o2)                  [                 ]
                                 [ a    b      c   ]


 -- Función: charpoly (<M>, <x>)
     Calcula el polinomio característico de la matriz <M> respecto de
     la variable <x>. Esto es, `determinant (<M> - diagmatrix (length
     (<M>), <x>))'.

          (%i1) a: matrix ([3, 1], [2, 4]);
                                      [ 3  1 ]
          (%o1)                       [      ]
                                      [ 2  4 ]
          (%i2) expand (charpoly (a, lambda));
                                     2
          (%o2)                lambda  - 7 lambda + 10
          (%i3) (programmode: true, solve (%));
          (%o3)               [lambda = 5, lambda = 2]
          (%i4) matrix ([x1], [x2]);
                                       [ x1 ]
          (%o4)                        [    ]
                                       [ x2 ]
          (%i5) ev (a . % - lambda*%, %th(2)[1]);
                                    [ x2 - 2 x1 ]
          (%o5)                     [           ]
                                    [ 2 x1 - x2 ]
          (%i6) %[1, 1] = 0;
          (%o6)                     x2 - 2 x1 = 0
          (%i7) x2^2 + x1^2 = 1;
                                      2     2
          (%o7)                     x2  + x1  = 1
          (%i8) solve ([%th(2), %], [x1, x2]);
                            1               2
          (%o8) [[x1 = - -------, x2 = - -------],
                         sqrt(5)         sqrt(5)

                                                       1             2
                                              [x1 = -------, x2 = -------]]
                                                    sqrt(5)       sqrt(5)


 -- Función: coefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Devuelve la matriz de coeficientes para las variables <x_1>, ...,
     <x_n> del sistema de ecuaciones lineales <eqn_1>, ..., <eqn_m>.

          (%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                           [ 2  1 - a ]
          (%o1)                            [          ]
                                           [ a    b   ]


 -- Función: col (<M>, <i>)
     Devuelve la <i>-ésima columna de la matriz <M>.  El resultado es
     una matriz de una sola columna.


 -- Función: columnvector (<L>)
 -- Función: covect (<L>)
     Devuelve una matriz con una columna  y `length (<L>)' filas,
     conteniendo los elementos de la lista <L>.

     La llamada `covect' es un sinónimo de `columnvector'.

     Es necesario cargar la función haciendo `load ("eigen")'.

     Ejemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function eigenvalues
          Warning - you are redefining the Macsyma function eigenvectors
          (%i2) columnvector ([aa, bb, cc, dd]);
                                       [ aa ]
                                       [    ]
                                       [ bb ]
          (%o2)                        [    ]
                                       [ cc ]
                                       [    ]
                                       [ dd ]


 -- Función: conjugate (<x>)
     Devuelve el conjugado complejo de <x>.

          (%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

          (%o1)                         done
          (%i2) conjugate (aa + bb*%i);

          (%o2)                      aa - %i bb
          (%i3) conjugate (cc);

          (%o3)                     conjugate(cc)
          (%i4) conjugate (ii);

          (%o4)                         - ii
          (%i5) conjugate (xx + yy);

          (%o5)             conjugate(yy) + conjugate(xx)


 -- Función: copymatrix (<M>)
     Devuelve una copia de la matriz <M>. Esta es la única manera de
     obtener una réplica de <M> además de la de copiar elemento a
     elemento.

     Nótese que una asignación de una matriz a otra, como en `m2: m1',
     no hace una copia de `m1'. Asignaciones del tipo `m2 [i,j]: x' o
     `setelmx (x, i, j, m2' también modifica `m1 [i,j]'. Si se crea una
     copia con `copymatrix' y luego se hacen asignaciones se tendrá una
     copia separada y modificada.


 -- Función: determinant (<M>)
     Calcula el determinante de  <M> por un método similar al de
     eliminación de Gauss

     La forma del resultado depende del valor asignado a `ratmx'.

     Existe una rutina especial para calcular determinantes de matrices
     con elementos dispersas, la cual será invocada cuando las
     variables `ratmx' y `sparse' valgan ambas `true'.


 -- Variable opcional: detout
     Valor por defecto: `false'

     Cuando `detout' vale `true', el determinante de la matriz cuya
     inversa se calcula aparece como un factor fuera de la matriz.

     Para que esta variable surta efecto, `doallmxops' y `doscmxops'
     deberían tener el valor `false' (véanse sus descripciones).
     Alternativamente, esta variable puede ser suministrada a `ev'.

     Ejemplo:

          (%i1) m: matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) detout: true$
          (%i3) doallmxops: false$
          (%i4) doscmxops: false$
          (%i5) invert (m);
                                    [  d   - b ]
                                    [          ]
                                    [ - c   a  ]
          (%o5)                     ------------
                                     a d - b c


 -- Función: diagmatrix (<n>, <x>)
     Devuelve una matriz diagonal de orden <n> con los elementos de la
     diagonal todos ellos iguales a <x>. La llamada `diagmatrix (<n>,
     1)' devuelve una matriz identidad (igual que `ident (<n>)').

     La variable <n> debe ser un número entero, en caso contrario
     `diagmatrix' envía un mensaje de error.

     <x> puede ser cualquier tipo de expresión, incluso otra matriz.
     Si <x> es una matriz, no se copia; todos los elementos de la
     diagonal son iguales a <x>.


 -- Variable opcional: doallmxops
     Valor por defecto: `true'

     Cuando `doallmxops' vale `true', todas las operaciones
     relacionadas con matrices son llevadas a cabo. Cuando es `false',
     entonces las selecciones para `dot' controlan las operaciones a
     ejecutar.


 -- Variable opcional: domxexpt
     Valor por defecto: `true'

     Cuando `domxexpt' vale `true', un exponente matricial, como `exp
     (<M>)' donde <M> es una matriz, se interpreta como una matriz cuyo
     elemento `[i,j' es igual a `exp (m[i,j])'. En otro caso, `exp
     (<M>)' se evalúa como `exp (ev(<M>))'.

     La variable `domxexpt' afecta a todas las expresiones de la forma
     `<base>^<exponente>' donde <base> es una expresión escalar o
     constante y <exponente> es una lista o matriz.

     Ejemplo:

          (%i1) m: matrix ([1, %i], [a+b, %pi]);
                                   [   1    %i  ]
          (%o1)                    [            ]
                                   [ b + a  %pi ]
          (%i2) domxexpt: false$
          (%i3) (1 - c)^m;
                                       [   1    %i  ]
                                       [            ]
                                       [ b + a  %pi ]
          (%o3)                 (1 - c)
          (%i4) domxexpt: true$
          (%i5) (1 - c)^m;
                            [                      %i  ]
                            [    1 - c      (1 - c)    ]
          (%o5)             [                          ]
                            [        b + a         %pi ]
                            [ (1 - c)       (1 - c)    ]


 -- Variable opcional: domxmxops
     Valor por defecto: `true'

     Cuando `domxmxops' vale `true', se realizan todas las operaciones
     entre matrices o entre matrices y listas (pero no las operaciones
     entre matrices y escalares); si esta variable es `false' tales
     operaciones no se realizan.


 -- Variable opcional: domxnctimes
     Valor por defecto: `false'

     Cuando `domxnctimes' vale `true', se calculan los productos no
     conmutativos entre matrices.


 -- Variable opcional: dontfactor
     Valor por defecto: `[]'

     En `dontfactor' puede guardarse una lista de variables respecto de
     las cuales no se realizarán factorizaciones. Inicialmente, la lista
     está vacía.


 -- Variable opcional: doscmxops
     Valor por defecto: `false'

     Cuando `doscmxops' vale `true', se realizan las operaciones entre
     escalares y matrices.


 -- Variable opcional: doscmxplus
     Valor por defecto: `false'

     Cuando `doscmxplus' vale `true', las operaciones entre escalares y
     matrices dan como resultado una matriz.


 -- Variable opcional: dot0nscsimp
     Valor por defecto: `true'

     (Esta descripción no está clara en la versión inglesa original.)


 -- Variable opcional: dotassoc
     Valor por defecto: `true'

     Cuando `dotassoc' vale `true', una expresión como `(A.B).C' se
     transforma en `A.(B.C)'.


 -- Variable opcional: dotconstrules
     Valor por defecto: `true'

     Cuando `dotconstrules' vale `true', un producto no conmutativo de
     una constante con otro término se transforma en un producto
     conmutativo.


 -- Variable opcional: dotdistrib
     Valor por defecto: `false'

     Cuando `dotdistrib' vale `true', una expresión como `A.(B + C)' se
     transforma en `A.B + A.C'.


 -- Variable opcional: dotexptsimp
     Valor por defecto: `true'

     Cuando `dotexptsimp' vale `true', una expresión como `A.A' se
     transforma en `A^^2'.


 -- Variable opcional: dotident
     Valor por defecto: 1

     El valor de la variable `dotident' es el resultado devuelto por
     `X^^0'.


 -- Variable opcional: dotscrules
     Valor por defecto: `false'

     Cuando `dotscrules' vale `true', una expresión como `A.SC' o
     `SC.A' se transforma en `SC*A' y `A.(SC*B)' en `SC*(A.B)'.


 -- Función: echelon (<M>)
     Devuelve la forma escalonada de la matriz <M>, obtenida por
     eliminación gaussiana.  La forma escalonada se calcula a partir de
     <M> mediante operaciones elementales con sus filas, de tal manera
     que el primer elemento no nulo de cada fila en la matriz resultado
     es la unidad y que cada elemento de la columna por debajo del
     primer uno de cada fila sean todos ceros.

     La función `triangularize' también lleva a cabo la eliminación
     gaussiana, pero no normaliza el primer elemento no nulo de cada
     fila.

     Otras funciones, como `lu_factor' y `cholesky', también dan como
     resultados matrices triangularizadas.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) echelon (M);
                            [ 1  - 8  - 5      - 2     ]
                            [                          ]
                            [         28       11      ]
                            [ 0   1   --       --      ]
          (%o2)             [         37       37      ]
                            [                          ]
                            [              37 bb - 119 ]
                            [ 0   0    1   ----------- ]
                            [              37 aa - 313 ]


 -- Función: eigenvalues (<M>)
 -- Función: eivals (<M>)
     Devuelve una lista con dos sublistas. La primera sublista la
     forman los valores propios de la matriz <M> y la segunda sus
     multiplicidades correspondientes.

     El nombre `eivals' es un sinónimo de `eigenvalues'.

     La función `eigenvalues' llama a la función `solve' para calcular
     las raíces del polinomio característico de la matriz. En
     ocasiones, `solve' no podrá encontrar dichas raíces, en cuyo caso
     otras funciones de este paquete no trabajarán correctamente, a
     excepción de `innerproduct', `unitvector', `columnvector' y
     `gramschmidt'.

     En algunos casos los valores propios encontrados por `solve' serán
     expresiones complicadas, las cuales se podrán simplificar haciendo
     uso de otras funciones.

     El paquete `eigen.mac' se carga en memoria de forma automática
     cuando se invocan `eigenvalues' o `eigenvectors'. Si `eigen.mac' no
     está ya cargado, `load ("eigen")' lo carga. Tras la carga, todas
     las funciones y variables del paquete estarán activas.


 -- Función: eigenvectors (<M>)
 -- Función: eivects (<M>)
     Calcula los vectores propios de la matriz <M>.  El resultado
     devuelto es una lista con dos elementos; el primero está formado
     por dos listas, la primera con los valores propios de <M> y la
     segunda con sus respectivas multiplicidades, el segundo elemento
     es una lista de listas de vectores propios, una por cada valor
     propio, pudiendo haber uno o más vectores propios en cada lista.

     Tomando la matriz <M> como argumento, devuelve una lista de listas,
     la primera de las cuales es la salida de `eigenvalues' y las
     siguientes son los vectorios propios de la matriz asociados a los
     valores propios correspondientes. Los vectores propios calculados
     son los vectores propios por la derecha.

     El nombre `eivects' es un sinónimo de `eigenvectors'.

     El paquete `eigen.mac' se carga en memoria de forma automática
     cuando se invocan `eigenvalues' o `eigenvectors'. Si `eigen.mac' no
     está ya cargado, `load ("eigen")' lo carga. Tras la carga, todas
     las funciones y variables del paquete estarán activas.

     Las variables que afectan a esta función son:

     `nondiagonalizable' toma el valor `true' o `false' dependiendo de
     si la matriz no es diagonalizable o diagonalizable tras la
     ejecución de `eigenvectors'.

     `hermitianmatrix', si vale `true', entonces los vectores propios
     degenerados de la matriz hermítica son ortogonalizados mediante el
     algoritmo de Gram-Schmidt.

     `knowneigvals', si vale `true', entonces el paquete `eigen' da por
     sentado que los valores propios de la matriz son conocidos por el
     usuario y almacenados en la variable global `listeigvals'.
     `listeigvals' debería ser similar a la salida de `eigenvalues'.

     La función `algsys' se utiliza aquí para calcular los vectores
     propios. A veces, `algsys' no podrá calcular una solución. En
     algunos casos, será posible simplificar los valores propios
     calculándolos en primer lugar con `eigenvalues' y luego utilizando
     otras funciones para simplificarlos. Tras la simplificación,
     `eigenvectors' podrá ser llamada otra vez con la variable
     `knowneigvals' ajustada al valor `true'.

     Véase también `eigenvalues'.

     Ejemplos:

     Una matriz con un único vector propio por cada valor propio.

          (%i1) M1 : matrix ([11, -1], [1, 7]);
                                     [ 11  - 1 ]
          (%o1)                      [         ]
                                     [ 1    7  ]
          (%i2) [vals, vecs] : eigenvectors (M1);
          (%o2) [[[9 - sqrt(3), sqrt(3) + 9], [1, 1]],
                                  [[[1, sqrt(3) + 2]], [[1, 2 - sqrt(3)]]]]
          (%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
            mult[i] = vals[2][i], vec[i] = vecs[i]);
                                 val  = 9 - sqrt(3)
                                    1

                                      mult  = 1
                                          1

                              vec  = [[1, sqrt(3) + 2]]
                                 1

                                 val  = sqrt(3) + 9
                                    2

                                      mult  = 1
                                          2

                              vec  = [[1, 2 - sqrt(3)]]
                                 2

          (%o3)                         done

     Una matriz con dos vectores propios para uno de los valores
     propios.

          (%i1) M1 : matrix ([0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 2, 0], [0, 0, 0, 2]);
                                   [ 0  1  0  0 ]
                                   [            ]
                                   [ 0  0  0  0 ]
          (%o1)                    [            ]
                                   [ 0  0  2  0 ]
                                   [            ]
                                   [ 0  0  0  2 ]
          (%i2) [vals, vecs] : eigenvectors (M1);
          (%o2) [[[0, 2], [2, 2]], [[[1, 0, 0, 0]],
                                             [[0, 0, 1, 0], [0, 0, 0, 1]]]]
          (%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
            mult[i] = vals[2][i], vec[i] = vecs[i]);
                                      val  = 0
                                         1

                                      mult  = 2
                                          1

                                vec  = [[1, 0, 0, 0]]
                                   1

                                      val  = 2
                                         2

                                      mult  = 2
                                          2

                         vec  = [[0, 0, 1, 0], [0, 0, 0, 1]]
                            2

          (%o3)                         done


 -- Función: ematrix (<m>, <n>, <x>, <i>, <j>)
     Devuelve una matriz de orden <m> por <n>, con todos sus elementos
     nulos, excepto el que ocupa la posición `[<i>, <j>]', que es igual
     a <x>.


 -- Función: entermatrix (<m>, <n>)
     Devuelve una matriz de orden <m> por <n>, cuyos elementos son
     leidos de forma interactiva.

     Si <n> es igual a <m>, Maxima pregunta por el tipo de matriz
     (diagonal, simétrica, antisimétrica o general) y luego por cada
     elemento. Cada respuesta introducida por el usuario debe terminar
     con un punto y coma `;' o con un signo de dólar `$'.

     Si <n> y <m> no son iguales, Maxima pregunta por el valor de cada
     elemento.

     Los elementos de la matriz pueden ser cualquier tipo de expresión,
     que en todo caso será evaluada.  `entermatrix' evalúa sus
     argumentos.

          (%i1) n: 3$
          (%i2) m: entermatrix (n, n)$

          Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric
             4. General
          Answer 1, 2, 3 or 4 :
          1$
          Row 1 Column 1:
          (a+b)^n$
          Row 2 Column 2:
          (a+b)^(n+1)$
          Row 3 Column 3:
          (a+b)^(n+2)$

          Matrix entered.
          (%i3) m;
                          [        3                     ]
                          [ (b + a)      0         0     ]
                          [                              ]
          (%o3)           [                  4           ]
                          [    0      (b + a)      0     ]
                          [                              ]
                          [                            5 ]
                          [    0         0      (b + a)  ]


 -- Función: genmatrix (<a>, <i_2>, <j_2>, <i_1>, <j_1>)
 -- Función: genmatrix (<a>, <i_2>, <j_2>, <i_1>)
 -- Función: genmatrix (<a>, <i_2>, <j_2>)
     Devuelve una matriz generada a partir de <a>, siendo
     `<a>[<i_1>,<j_1>]' el elemento superior izquierdo y
     `<a>[<i_2>,<j_2>]' el inferior derecho de la matriz.  Aquí <a> se
     declara como una arreglo (creado por `array', pero no por
     `make_array'), o un array no declarado, o una función array, o una
     expresión lambda de dos argumentos.  (An array function is created
     like other functions with `:=' or `define', but arguments are
     enclosed in square brackets instead of parentheses.)

     Si se omite <j_1>, entonces se le asigna el valor <i_1>. Si tanto
     <j_1> como <i_1> se omiten, a las dos variables se le asigna el
     valor 1.

     Si un elemento `i,j' del arreglo no está definido, se le asignará
     el elemento simbólico `<a>[i,j]'.

          (%i1) h [i, j] := 1 / (i + j - 1);
                                              1
          (%o1)                  h     := ---------
                                  i, j    i + j - 1
          (%i2) genmatrix (h, 3, 3);
                                     [    1  1 ]
                                     [ 1  -  - ]
                                     [    2  3 ]
                                     [         ]
                                     [ 1  1  1 ]
          (%o2)                      [ -  -  - ]
                                     [ 2  3  4 ]
                                     [         ]
                                     [ 1  1  1 ]
                                     [ -  -  - ]
                                     [ 3  4  5 ]
          (%i3) array (a, fixnum, 2, 2);
          (%o3)                           a
          (%i4) a [1, 1] : %e;
          (%o4)                          %e
          (%i5) a [2, 2] : %pi;
          (%o5)                          %pi
          (%i6) genmatrix (a, 2, 2);
                                     [ %e   0  ]
          (%o6)                      [         ]
                                     [ 0   %pi ]
          (%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                                   [  0    1   2 ]
                                   [             ]
          (%o7)                    [ - 1   0   1 ]
                                   [             ]
                                   [ - 2  - 1  0 ]
          (%i8) genmatrix (B, 2, 2);
                                  [ B      B     ]
                                  [  1, 1   1, 2 ]
          (%o8)                   [              ]
                                  [ B      B     ]
                                  [  2, 1   2, 2 ]


 -- Función: gramschmidt (<x>)
 -- Función: gramschmidt (<x>, <F>)
     Ejecuta el algoritmo de ortogonalización de Gram-Schmidt sobre <x>,
     que puede ser una matriz o una lista de listas. La función
     `gramschmidt' no altera el valor de <x>.  El producto interno por
     defecto empleado en `gramschmidt' es `innerproduct', o <F>, si se
     ha hecho uso de esta opción.

     Si <x> es una matriz, el algoritmo se aplica a las filas de <x>. Si
     <x> es una lista de listas, el algoritmo se aplica a las sublistas,
     las cuales deben tener el mismo número de miembros. En cualquier
     caso, el valor devuelto es una lista de listas, cuyas sublistas
     son ortogonales.

     La función `factor' es invocada  en cada paso del algoritmo para
     simplificar resultados intermedios. Como consecuencia, el valor
     retornado puede contener enteros factorizados.

     El nombre `gschmit' es sinónimo de `gramschmidt'.

     Es necesario cargar la función haciendo `load ("eigen")'.

     Ejemplo:

     Algoritmo de Gram-Schmidt utilizando el producto interno por
     defecto.

          (%i1) load (eigen)$
          (%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                                   [ 1   2   3  ]
                                   [            ]
          (%o2)                    [ 9   18  30 ]
                                   [            ]
                                   [ 12  48  60 ]
          (%i3) y: gramschmidt (x);
                                 2      2            4     3
                                3      3   3 5      2  3  2  3
          (%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                                2 7    7   2 7       5     5
          (%i4) map (innerproduct, [y[1], y[2], y[3]], [y[2], y[3], y[1]]);
          (%o4)                       [0, 0, 0]

     Algoritmo de Gram-Schmidt utilizando un producto interno
     especificado por el usuario.

          (%i1) load (eigen)$
          (%i2) ip (f, g) := integrate (f * g, u, a, b);
          (%o2)          ip(f, g) := integrate(f g, u, a, b)
          (%i3) y : gramschmidt ([1, sin(u), cos(u)], ip), a= -%pi/2, b=%pi/2;
                                         %pi cos(u) - 2
          (%o3)              [1, sin(u), --------------]
                                              %pi
          (%i4) map (ip, [y[1], y[2], y[3]], [y[2], y[3], y[1]]), a= -%pi/2, b=%pi/2;
          (%o4)                       [0, 0, 0]


 -- Función: ident (<n>)
     Devuelve la matriz identidad de orden <n>.


 -- Función: innerproduct (<x>, <y>)
 -- Función: inprod (<x>, <y>)
     Devuelve el producto interior o escalar de <x> por <y>, que deben
     ser listas de igual longitud, o ambas matrices columa o fila de
     igual longitud. El valor devuelto es `conjugate (x) . y', donde
     `.' es el operador de multiplicación no conmutativa.

     Es necesario cargar la función haciendo `load ("eigen")'.

     El nombre `inprod' es sinónimo de `innerproduct'.


 -- Función: invert (<M>)
     Devuelve la inversa de la matriz <M>, calculada por el método del
     adjunto.

     La implementación actual no es eficiente para matrices de orden
     grande.

     Cuando `detout' vale `true', el determinante queda fuera de la
     inversa a modo de factor escalar.

     Los elementos de la matriz inversa no se expanden. Si <M> tiene
     elementos polinómicos, se puede mejorar el aspecto del resultado
     haciendo `expand (invert (m)), detout'.  Véase la descripción de
     `^^' (exponente no conmutativo) para información sobre otro método
     para invertir matrices.


 -- Variable opcional: lmxchar
     Valor por defecto: `['

     La variable `lmxchar' guarda el carácter a mostrar como
     delimitador izquierdo de la matriz.  Véase también `rmxchar'.

     Ejemplo:

          (%i1) lmxchar: "|"$
          (%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                                     | a  b  c ]
                                     |         ]
          (%o2)                      | d  e  f ]
                                     |         ]
                                     | g  h  i ]


 -- Función: matrix (<fila_1>, ..., <fila_n>)
     Devuelve una matriz rectangular con las filas  <fila_1>, ...,
     <fila_n>. Cada fila es una lista de expresiones. Todas las filas
     deben tener el mismo número de miembros.

     Las operaciones `+' (suma), `-' (resta), `*' (multiplicación) y
     `/' (división), se llevan a cabo elemento a elemento cuando los
     operandos son dos matrices, un escalar y una matriz o una matriz
     con un escalar. La operación `^' (exponenciación, equivalente a
     `**') se lleva cabo también elemento a elemento si los operandos
     son un escalr y una matriz o uma matriz y un escalar, pero no si
     los operandos son dos matrices.

     El producto matricial se representa con el operador de
     multiplicación no conmutativa `.'. El correspondiente operador de
     exponenciación no conmutativa es `^^'. Dada la matriz `<A>',
     `<A>.<A> = <A>^^2' y `<A>^^-1' es la inversa de <A>, si existe.

     Algunas variables controlan la simplificación de expresiones que
     incluyan estas operaciones: `doallmxops', `domxexpt', `domxmxops',
     `doscmxops' y `doscmxplus'.

     Hay otras opciones adicionales relacionadas con matrices:
     `lmxchar', `rmxchar', `ratmx', `listarith', `detout',
     `scalarmatrix' y `sparse'.

     Hay también algunas funciones que admiten matrices como argumentos
     o que devuelven resultados matriciales: `eigenvalues',
     `eigenvectors', `determinant', `charpoly', `genmatrix', `addcol',
     `addrow', `copymatrix', `transpose', `echelon' y `rank'.

     Ejemplos:

        * Construcción de matrices a partir de listas.

          (%i1) x: matrix ([17, 3], [-8, 11]);
                                     [ 17   3  ]
          (%o1)                      [         ]
                                     [ - 8  11 ]
          (%i2) y: matrix ([%pi, %e], [a, b]);
                                     [ %pi  %e ]
          (%o2)                      [         ]
                                     [  a   b  ]

        * Suma elemento a elemento.

          (%i3) x + y;
                                [ %pi + 17  %e + 3 ]
          (%o3)                 [                  ]
                                [  a - 8    b + 11 ]

        * Resta elemento a elemento.

          (%i4) x - y;
                                [ 17 - %pi  3 - %e ]
          (%o4)                 [                  ]
                                [ - a - 8   11 - b ]

        * Multiplicación elemento a elemento.

          (%i5) x * y;
                                  [ 17 %pi  3 %e ]
          (%o5)                   [              ]
                                  [ - 8 a   11 b ]

        * División elemento a elemento.

          (%i6) x / y;
                                  [ 17       - 1 ]
                                  [ ---  3 %e    ]
                                  [ %pi          ]
          (%o6)                   [              ]
                                  [   8    11    ]
                                  [ - -    --    ]
                                  [   a    b     ]

        * Matriz elevada a un exponente escalar, operación elemento a
          elemento.

          (%i7) x ^ 3;
                                   [ 4913    27  ]
          (%o7)                    [             ]
                                   [ - 512  1331 ]

        * Base escalar y exponente matricial, operación elemento a
          elemento.

          (%i8) exp(y);
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o8)                    [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * Base y exponente matriciales. Esta operación no se realiza
          elemento a elemento.

          (%i9) x ^ y;
                                          [ %pi  %e ]
                                          [         ]
                                          [  a   b  ]
                               [ 17   3  ]
          (%o9)                [         ]
                               [ - 8  11 ]

        * Multiplicación matricial no conmutativa.

          (%i10) x . y;
                            [ 3 a + 17 %pi  3 b + 17 %e ]
          (%o10)            [                           ]
                            [ 11 a - 8 %pi  11 b - 8 %e ]
          (%i11) y . x;
                          [ 17 %pi - 8 %e  3 %pi + 11 %e ]
          (%o11)          [                              ]
                          [  17 a - 8 b     11 b + 3 a   ]

        * Exponenciación matricial no conmutativa. Una base escalar <b>
          elevada a un exponente matricial <M> se lleva a cabo elemento
          a elemento y por lo tanto `b^^m' equivale a `b^m'.

          (%i12) x ^^ 3;
                                  [  3833   1719 ]
          (%o12)                  [              ]
                                  [ - 4584  395  ]
          (%i13) %e ^^ y;
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o13)                   [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * Una matriz elevada al exponente -1 con el operador de
          exponenciación no conmutativa equivale a la matriz inversa,
          si existe.

          (%i14) x ^^ -1;
                                   [ 11      3  ]
                                   [ ---  - --- ]
                                   [ 211    211 ]
          (%o14)                   [            ]
                                   [  8    17   ]
                                   [ ---   ---  ]
                                   [ 211   211  ]
          (%i15) x . (x ^^ -1);
                                      [ 1  0 ]
          (%o15)                      [      ]
                                      [ 0  1 ]


 -- Función: matrixmap (<f>, <M>)
     Devuelve una matriz con el elemento `i,j' igual a `<f>(<M>[i,j])'.

     Véanse también `map', `fullmap', `fullmapl' y `apply'.


 -- Función: matrixp (<expr>)
     Devuelve `true' si <expr> es una matriz, en caso contrario `false'.


 -- Variable opcional: matrix_element_add
     Valor por defecto: `+'

     La variable `matrix_element_add' guarda el símbolo del operador a
     ejecutar en lugar de la suma en el producto matricial; a
     `matrix_element_add' se le puede asignar cualquier operador n-ario
     (esto es, una función que admite cualquier número de argumentos).
     El valor asignado puede ser el nombre de un operador encerrado
     entre apóstrofos, el nombre de una función o una expresión lambda.

     Véanse también `matrix_element_mult' y `matrix_element_transpose'.

     Ejemplo:

          (%i1) matrix_element_add: "*"$
          (%i2) matrix_element_mult: "^"$
          (%i3) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o3)                      [         ]
                                     [ d  e  f ]
          (%i4) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o4)                      [         ]
                                     [ x  y  z ]
          (%i5) aa . transpose (bb);
                               [  u  v  w   x  y  z ]
                               [ a  b  c   a  b  c  ]
          (%o5)                [                    ]
                               [  u  v  w   x  y  z ]
                               [ d  e  f   d  e  f  ]


 -- Variable opcional: matrix_element_mult
     Valor por defecto: `*'

     La variable `matrix_element_mult' guarda el símbolo del operador a
     ejecutar en lugar de la multiplicación en el producto matricial; a
     `matrix_element_mult' se le puede asignar cualquier operador
     binario. El valor asignado puede ser el nombre de un operador
     encerrado entre apóstrofos, el nombre de una función o una
     expresión lambda.

     El operador `.' puede ser una opción útil en determinados
     contextos.

     Véanse también `matrix_element_add' y `matrix_element_transpose'.

     Ejemplo:

          (%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
          (%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
          (%i3) [a, b, c] . [x, y, z];
                                    2          2          2
          (%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
          (%i4) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o4)                      [         ]
                                     [ d  e  f ]
          (%i5) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o5)                      [         ]
                                     [ x  y  z ]
          (%i6) aa . transpose (bb);
                         [             2          2          2  ]
                         [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
          (%o6)  Col 1 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                                   [             2          2          2  ]
                                   [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                           Col 2 = [                                      ]
                                   [             2          2          2  ]
                                   [ sqrt((f - z)  + (e - y)  + (d - x) ) ]


 -- Variable opcional: matrix_element_transpose
     Valor por defecto: `false'

     La variable `matrix_element_transpose' es una operación que se
     aplica a cada elemento de una matriz a la que se le calcula la
     transpuesta. A `matrix_element_mult' se le puede asignar cualquier
     operador unitario. El valor asignado puede ser el nombre de un
     operador encerrador entre apóstrofos, el nombre de una función o
     una expresión lambda.

     Cuando `matrix_element_transpose' es igual a `transpose', la
     función `transpose' se aplica a cada elemento. Cuando
     `matrix_element_transpose' es igual  a `nonscalars', la función
     `transpose' se aplica a todos los elementos no escalares. Si
     alguno de los elementos es un átomo, la opción `nonscalars' se
     aplica `transpose' sólo si el átomo se declara no escalar,
     mientras que la opción `transpose' siempre aplica  `transpose'.

     La opción por defecto, `false', significa que no se aplica ninguna
     operación.

     Véanse también `matrix_element_add' y `matrix_element_mult'.

     Ejemplos:

          (%i1) declare (a, nonscalar)$
          (%i2) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o2)                   [              ]
                                  [      b       ]
          (%i3) matrix_element_transpose: nonscalars$
          (%i4) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o4)                   [              ]
                                  [      b       ]
          (%i5) matrix_element_transpose: transpose$
          (%i6) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o6)                   [              ]
                                  [ transpose(b) ]
          (%i7) matrix_element_transpose:
                     lambda ([x], realpart(x) - %i*imagpart(x))$
          (%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                               [ 5 %i + 1  3 - 2 %i ]
          (%o8)                [                    ]
                               [   7 %i       11    ]
          (%i9) transpose (m);
                                [ 1 - 5 %i  - 7 %i ]
          (%o9)                 [                  ]
                                [ 2 %i + 3    11   ]


 -- Función: mattrace (<M>)
     Devuelve la traza (esto es, la suma de los elementos de la
     diagonal principal) de la matriz cuadrada <M>.

     Para disponer de esta función es necesario cargar el paquete
     haciendo `load ("nchrpl")'.


 -- Función: minor (<M>, <i>, <j>)
     Devuelve el menor `(<i>, <j>)' de la matriz <M>.  Esto es, la
     propia matriz <M>, una vez extraídas la fila <i> y la columna <j>.


 -- Función: ncexpt (<a>, <b>)
     Si una expresión exponencial no conmutativa es demasiado grande
     para mostrarse en la forma `<a>^^<b>' entonces aparece como
     `ncexpt (<a>,<b>)'.

     El nombre `ncexpt' no corresponde al de una función u operador,
     sino que tan solo aparece en la salida y no se reconoce como una
     entrada válida.


 -- Función: ncharpoly (<M>, <x>)
     Devuelve el polinomio característico de la matriz <M> respecto de
     la variable <x>. Es una alternativa a la función `charpoly' de
     Maxima.

     La función `ncharpoly' opera calculando trazas de las potencias de
     la matriz dada, que son iguales a las sumas de las potencias de
     las raíces del polinomio característico. A partir de estas
     cantidades se pueden calcular las funciones simétricas de las
     raíces, que no son otra cosa sino los coeficientes del polinomio
     característico. La función   `charpoly' opera calculando el
     determinante de  by `<x> * ident [n] - a'. La función `ncharpoly'
     es m'as eficiente en el caso de matrices grandes y densas.

     Para disponer de esta función es necesario cargar el paquete
     haciendo `load ("nchrpl")'.


 -- Función: newdet (<M>, <n>)
     Calcula el determinante de la matriz o arreglo <M> por el
     algoritmo del árbol menor de Johnson-Gentleman.  El argumento <n>
     es el orden; es opcional si <M> es una matriz.


 -- Declaración: nonscalar
     Hace que los átomos se comporten como hace una lista o matriz con
     respecto del operador `.' del la multiplicación no conmutativa.


 -- Función: nonscalarp (<expr>)
     Devuelve `true' si <expr> no es escalar, es decir, si contiene
     átomos declarados como no escalares, listas o matrices.


 -- Función: permanent (<M>, <n>)
     Calcula la permanente de la matriz <M>. La permanente es como un
     determinante pero sin cambios de signo.


 -- Función: rank (<M>)
     Calcula el rango de la matriz <M>.  Esto es, el orden del mayor
     subdeterminante no singular de <M>.

     La función <rango> puede retornar una respuesta errónea si no
     detecta que un elemento de la matriz equivalente a cero lo es.


 -- Variable opcional: ratmx
     Valor por defecto: `false'

     Si `ratmx' vale `false', el determinante y la suma, resta y
     producto matriciales se calculan cuando las matrices se expresan
     en términos de sus elementos, pero no se calcula la inversión
     matricial en su representación general.

     Si `ratmx' vale `true', las cuatro operaciones citadas más arriba
     se calculan en el formato CRE y el resultado de la matriz inversa
     también se da en formato CRE. Esto puede hacer que se expandan los
     elementos de la matriz, dependiendo del valor de `ratfac', lo que
     quizás no sea siempre deseable.


 -- Función: row (<M>, <i>)
     Devuelve la <i>-ésima fila de la matriz <M>. El valor que devuelve
     tiene formato de matriz.


 -- Variable opcional: scalarmatrixp
     Valor por defecto: `true'

     Si `scalarmatrixp' vale `true', entonces siempre que una matriz 1
     x 1 se produce como resultado del cálculo del producto no
     conmutativo de matrices se cambia al formato escalar.

     Si `scalarmatrixp' vale `all', entonces todas las matrices 1 x 1
     se simplifican a escalares.

     Si `scalarmatrixp' vale `false', las matrices 1 x 1 no se
     convierten en escalares.


 -- Función: setelmx (<x>, <i>, <j>, <M>)
     Asigna el valor <x> al (<i>, <j>)-ésimo elemento de la matriz <M>
     y devuelve la matriz actualizada.

     La llamada `<M> [<i>, <j>]: <x>' hace lo mismo, pero devuelve  <x>
     en lugar de <M>.


 -- Función: similaritytransform (<M>)
 -- Función: simtran (<M>)
     La función `similaritytransform' calcula la transformada de
     similitud de la matriz `M'. Devuelve una lista que es la salida de
     la instrucción `uniteigenvectors'. Además, si la variable
     `nondiagonalizable' vale `false' entonces se calculan dos matrices
     globales `leftmatrix' y `rightmatrix'. Estas matrices tienen la
     propiedad de que `leftmatrix . <M> . rightmatrix' es una matriz
     diagonal con los valores propios de <M> en su diagonal.  Si
     `nondiagonalizable' vale `true' entonces no se calculan estas
     matrices.

     Si la variable `hermitianmatrix' vale `true' entonces `leftmatrix'
     es el conjugado complejo de la transpuesta de `rightmatrix'.  En
     otro caso `leftmatrix' es la inversa de `rightmatrix'.

     Las columnas de la matriz `rightmatrix' son los vectores propios
     de <M>.  Las otras variables (véanse `eigenvalues' y
     `eigenvectors') tienen el mismo efecto, puesto que
     `similaritytransform' llama a las otras funciones del paquete para
     poder formar `rightmatrix'.

     Estas funciones se cargan con `load ("eigen")'.

     El nombre `simtran' es sinónimo de `similaritytransform'.


 -- Variable opcional: sparse
     Valor por defecto: `false'

     Si `sparse' vale `true' y si `ratmx' vale `true', entonces
     `determinant' utilizará rutinas especiales para calcular
     determinantes dispersos.


 -- Función: submatrix (<i_1>, ..., <i_m>, <M>, <j_1>, ..., <j_n>)
 -- Función: submatrix (<i_1>, ..., <i_m>, <M>)
 -- Función: submatrix (<M>, <j_1>, ..., <j_n>)
     Devuelve una nueva matriz formada a partir de la matriz <M> pero
     cuyas filas <i_1>, ..., <i_m> y columnas  <j_1>, ..., <j_n> han
     sido eliminadas.


 -- Función: transpose (<M>)
     Calcula la transpuesta de <M>.

     Si <M> es una matriz, el valor devuelto es otra matriz <N> tal que
     `N[i,j] = M[j,i]'.

     Si <M> es una lista, el valor devuelto es una matriz <N> de
     `length (m)' filas y 1 columna, tal que `N[i,1] = M[i]'.

     En caso de no ser <M> ni matriz ni lista, se devuelve la expresión
     nominal `'transpose (<M>)'.

 -- Función: triangularize (<M>)
     Devuelve la forma triangular superior de la matriz `M', obtenida
     por eliminación gaussiana.  El resultado es el mismo que el
     devuelto por `echelon', con la salvedad de que el primer elemento
     no nulo de cada fila no se normaliza a 1.

     Las funciones `lu_factor' y `cholesky' también triangularizan
     matrices.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) triangularize (M);
                       [ - 1   8         5            2      ]
                       [                                     ]
          (%o2)        [  0   - 74     - 56         - 22     ]
                       [                                     ]
                       [  0    0    626 - 74 aa  238 - 74 bb ]


 -- Función: uniteigenvectors (<M>)
 -- Función: ueivects (<M>)
     Calcula los vectores propios unitarios de la matriz <M>. El valor
     que devuelve es una lista de listas, la primera de las cuales es
     la salida de la función `eigenvalues' y el resto de sublistas son
     los vectores propios unitarios de la matriz correspondiente a esos
     valores propios, respectivamente.

     Las variables citadas en la descripción de la función
     `eigenvectors' tienen los mismos efectos en `uniteigenvectors'.

     Si `knowneigvects' vale `true', el paquete `eigen' da por supuesto
     que el usuario conoce los vectores propios de la matriz y que
     están guardados en la variable global `listeigvects', en tal caso
     el contenido de  `listeigvects' debe ser una lista de estructura
     similar a la que devuelve la función `eigenvectors'.

     Si `knowneigvects' vale `true' y la lista de vectores propios está
     en la variable `listeigvects', el valor de la variable
     `nondiagonalizable' puede que no sea el correcto. Si tal es el
     caso, debe asignarsele el valor correcto.  Para utilizar esta
     fucnión es necesario cargarla haciendo `load ("eigen")'.

     El nombre `ueivects' es sinónimo de `uniteigenvectors'.


 -- Función: unitvector (<x>)
 -- Función: uvect (<x>)
     Devuelve <x>/norm(<x>), esto es, el vector unitario de igual
     dirección y sentido que <x>.

     `load ("eigen")' loads this function.

     Para utilizar esta fucnión es necesario cargarla haciendo `load
     ("eigen")'.

     El nombre `uvect' es sinónimo de `unitvector'.


 -- Función: vectorsimp (<expr>)
     Realiza simplificaciones y expansiones de acuerdo con los valores
     de las siguientes variables globales:

     `expandall', `expanddot', `expanddotplus', `expandcross',
     `expandcrossplus', `expandcrosscross', `expandgrad',
     `expandgradplus', `expandgradprod', `expanddiv', `expanddivplus',
     `expanddivprod', `expandcurl', `expandcurlplus', `expandcurlcurl',
     `expandlaplacian', `expandlaplacianplus' y `expandlaplacianprod'.

     Todas estas variables tienen por defecto el valor `false'. El
     sufijo `plus' se refiere al uso de la suma o la distributividad.
     El sufijo `prod' se refiere a la expansión de operadores que
     realizan cualquier tipo de producto.

    `expandcrosscross'
          Simplifica p ~ (q ~ r) en (p . r)*q - (p . q)*r.

    `expandcurlcurl'
          Simplifica curl curl p en grad div p + div grad p.

    `expandlaplaciantodivgrad'
          Simplifica laplacian p en div grad p.

    `expandcross'
          Activa `expandcrossplus' y `expandcrosscross'.

    `expandplus'
          Activa `expanddotplus', `expandcrossplus', `expandgradplus',
          `expanddivplus', `expandcurlplus' y `expandlaplacianplus'.

    `expandprod'
          Activa `expandgradprod', `expanddivprod' y
          `expandlaplacianprod'.

     Estas variables están declaradas como `evflag'.


 -- Función: zeromatrix (<m>, <n>)
     Devuelve una matriz rectangular <m> por <n> con todos sus
     elementos iguales a cero.


 -- Símbolo especial: [
 -- Símbolo especial: [
     Los símbolos `[' y `]' marcan el comienzo y final,
     respectivamente, de una lista.

     Los símbolos `[' y `]' también se utilizan para indicar los
     subíndices de los elementos de una lista, arreglo o función
     arreglo.

     Ejemplos:

          (%i1) x: [a, b, c];
          (%o1)                       [a, b, c]
          (%i2) x[3];
          (%o2)                           c
          (%i3) array (y, fixnum, 3);
          (%o3)                           y
          (%i4) y[2]: %pi;
          (%o4)                          %pi
          (%i5) y[2];
          (%o5)                          %pi
          (%i6) z['foo]: 'bar;
          (%o6)                          bar
          (%i7) z['foo];
          (%o7)                          bar
          (%i8) g[k] := 1/(k^2+1);
                                            1
          (%o8)                     g  := ------
                                     k     2
                                          k  + 1
          (%i9) g[10];
                                          1
          (%o9)                          ---
                                         101



File: maxima.info,  Node: Afines,  Next: itensor,  Prev: Matrices y Álgebra Lineal,  Up: Top

26 Afines
*********

* Menu:

* Funciones y variables para Afines::


File: maxima.info,  Node: Funciones y variables para Afines,  Prev: Afines,  Up: Afines

26.1 Funciones y variables para Afines
======================================

 -- Función: fast_linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ...,
          <x_n>])
     Resuelve las ecuaciones lineales simultáneas <expr_1>, ...,
     <expr_m> para las variables <x_1>, ..., <x_n>.  Cada <expr_i>
     puede ser una ecuación o una expresión general; en caso de
     tratarse de una expresión general, será tratada como una ecuación
     de la forma `<expr_i> = 0'.

     El valor que devuelve es una lista de ecuaciones de la forma
     `[<x_1> = <a_1>, ..., <x_n> = <a_n>]' donde todas las <a_1>, ...,
     <a_n> están exentas de <x_1>, ..., <x_n>.

     La función `fast_linsolve' es más rápida que `linsolve' para
     sistemas de ecuaciones con coeficientes dispersos.

     Antes de utilizar esta función ejecútese `load(affine)'.

 -- Función: grobner_basis ([<expr_1>, ..., <expr_m>])
     Devuelve una base de Groebner para las ecuaciones <expr_1>, ...,
     <expr_m>.  La función `polysimp' puede ser entonces utilizada para
     simplificar otras funciones relativas a las ecuaciones.

          grobner_basis ([3*x^2+1, y*x])$

          polysimp (y^2*x + x^3*9 + 2) ==> -3*x + 2

     `polysimp(f)' alcanza 0 si y sólo si <f> está en el ideal generado
     por <expr_1>, ..., <expr_m>, es decir, si y sólo si <f> es una
     combinación  polinómica de los elementos de <expr_1>, ...,
     <expr_m>.

     Antes de utilizar esta función ejecútese `load(affine)'.

 -- Función: set_up_dot_simplifications (<eqns>, <check_through_degree>)
 -- Función: set_up_dot_simplifications (<eqns>)
     Las <eqns> son ecuaciones polinómicas de variables no conmutativas.
     El valor de `current_variables' es la lista de variables
     utilizadas para el cálculo de los grados. Las ecuaciones deben ser
     homogéneas, al objeto de completar el procedimiento.

     El grado es el devuelto por `nc_degree'. Éste a su vez depende de
     los pesos de las variables individuales.

     Antes de utilizar esta función ejecútese `load(affine)'.

 -- Función: declare_weights (<x_1>, <w_1>, ..., <x_n>, <w_n>)
     Asigna los pesos <w_1>, ..., <w_n> a <x_1>, ..., <x_n>,
     respectivamente.  Estos pesos son los utilizados en el cálculo de
     `nc_degree'.

     Antes de utilizar esta función ejecútese `load(affine)'.

 -- Función: nc_degree (<p>)
     Devuelve el grado de un polinomio no conmutativo <p>. Véase
     `declare_weights'.

     Antes de utilizar esta función ejecútese `load(affine)'.

 -- Función: dotsimp (<f>)
     Devuelve 0 si y sólo si  <f> está en el ideal generado por las
     ecuaciones, esto es, si y sólo si <f> es una combinación lineal de
     los elementos de las ecuaciones.

     Antes de utilizar esta función ejecútese `load(affine)'.

 -- Función: fast_central_elements ([<x_1>, ..., <x_n>], <n>)
     Si se ha ejecutado `set_up_dot_simplifications' con antelación,
     obtiene los polinomios centrales de grado <n> de variables <x_1>,
     ..., <x_n>.

     Por ejemplo:
          set_up_dot_simplifications ([y.x + x.y], 3);
          fast_central_elements ([x, y], 2);
          [y.y, x.x];

     Antes de utilizar esta función ejecútese `load(affine)'.

 -- Función: check_overlaps (<n>, <add_to_simps>)
     Revisa la superposición hasta el grado <n>, asegurándose de que el
     usuario tiene suficientes reglas de simplificación en cada grado
     para que `dotsimp' trabaje correctamente. Este proceso puede
     acelerarse si se conoce de antemano cuál es la dimensión del
     espacio de monomios.  Si éste es de dimensión global finita,
     entonces debería usarse `hilbert'. Si no se conoce la dimensiones
     de los monomios, no se debería especificar una `rank_function'.
     Un tercer argumento opcional es `reset'.

     Antes de utilizar esta función ejecútese `load(affine)'.

 -- Función: mono ([<x_1>, ..., <x_n>], <n>)
     Devuelve la lista de monomios independientes.  Antes de utilizar
     esta función ejecútese `load(affine)'.

 -- Función: monomial_dimensions (<n>)
     Calcula el desarrollo de Hilbert de grado <n> para el algebra
     actual.

     Antes de utilizar esta función ejecútese `load(affine)'.

 -- Función: extract_linear_equations ([<p_1>, ..., <p_n>], [<m_1>,
          ..., <m_n>])
     Hace una lista de los coeficientes de los polinomios no
     conmutativos <p_1>, ..., <p_n> de los monomios no conmutativos
     <m_1>, ..., <m_n>. Los coeficientes deben escalares. Hágase uso de
     `list_nc_monomials' para construir la lista de monomios.

     Antes de utilizar esta función ejecútese `load(affine)'.

 -- Función: list_nc_monomials ([<p_1>, ..., <p_n>])
 -- Función: list_nc_monomials (<p>)
     Devuelve  una lista de los monomios no conmutativos que aparecen
     en el polinomio  <p> o una lista de polinomios en <p_1>, ...,
     <p_n>.

     Antes de utilizar esta función ejecútese `load(affine)'.

 -- Variable: all_dotsimp_denoms
     Valor por defecto: `false'

     Cuando `all_dotsimp_denoms' es una lista, los denominadores
     encontrados por `dotsimp' son añadidos a la lista. La variable
     `all_dotsimp_denoms' puede inicializarse como una lista vacía `[]'
     antes de llamar a `dotsimp'.

     Por defecto, `dotsimp' no recolecta los denominadores.



File: maxima.info,  Node: itensor,  Next: ctensor,  Prev: Afines,  Up: Top

27 itensor
**********

* Menu:

* Introducción a itensor::
* Funciones y variables para itensor::


File: maxima.info,  Node: Introducción a itensor,  Next: Funciones y variables para itensor,  Prev: itensor,  Up: itensor

27.1 Introducción a itensor
===========================

Maxima implementa dos tipos diferentes de manipulación simbólica de
tensores: la manipulación de componentes (paquete `ctensor') y la
manipulación indexada (paquete `itensor').

   Véase más abajo la nota sobre 'notación tensorial'.

   La manipulación de componentes significa que los objetos geométricos
tensoriales se representan como arreglos (arrays) o matrices.
Operaciones tensoriales como la contracción o la diferenciación
covariante se llevan a cabo sumando índices mudos con la sentencia
`do'. Esto es, se realizan operaciones directamente con las componentes
del tensor almacenadas en un arreglo o matriz.

   La manipulación indexada de tensores se lleva a cabo mediante la
representación de los tensores como funciones de sus índices
covariantes, contravariantes y de derivadas. Operaciones tensoriales
como la contracción o la diferenciación covariante se realizan
manipulando directamente los índices, en lugar de sus componentes
asociadas.

   Estas dos técnicas para el tratamiento de los procesos
diferenciales, algebraicos y analíticos en el contexto de la geometría
riemanniana tienen varias ventajas y desventajas que surgen según la
naturaleza y dificultad del problema que está abordando el usuario. Sin
embargo, se deben tener presentes las siguientes características de
estas dos técnicas:

   La representación de los tensores y sus operaciones en términos de
sus componentes facilita el uso de paquete `ctensor'. La especificación
de la métrica y el cálculo de los tensores inducidos e invariantes es
inmediato. Aunque toda la potencia de simplificación de Maxima se
encuentra siempre a mano, una métrica compleja con dependencias
funcionales y de coordenadas intrincada, puede conducir a expresiones
de gran tamaño en las que la estructura interna quede oculta. Además,
muchos cálculos requieren de expresiones intermedias que pueden
provocar la detención súbita de los programas antes de que se termine
el cálculo. Con la experiencia, el usuario podrá evitar muchas de estas
dificultades.

   Devido a la forma en que los tensores y sus operaciones se
representan en términos de operaciones simbólicas con sus índices,
expresiones que serían intratables en su representación por componentes
pueden en ocasiones simplificarse notablemente utilizando las rutinas
especiales para objetos simétricos del paquete `itensor'. De esta
manera, la estructura de expresiones grandes puede hacerse más
transparente. Por otro lado, debido a la forma especial de la
representación indexada de tensores en `itensor', en algunos casos el
usuario encontrará dificultades con la especificación de la métrica o
la definición de funciones.

   El paquete `itensor' puede derivar respecto de una variable
indexada, lo que permite utilizar el paquete cuando se haga uso del
formalismo de lagrangiano y hamiltoniano. Puesto que es posible derivar
un campo lagrangiano respecto de una variable de campo indexada, se
puede hacer uso de Maxima para derivar las ecuaciones de Euler-Lagrange
correspondientes en forma indexada. Estas ecuaciones pueden traducirse
a componentes tensoriales (`ctensor') con la función `ic_convert', lo
que permite resolver las ecuaciones de campo en cualquier sistema de
coordenadas, o obtener las ecuaciones de movimiento en forma
hamiltoniana. Véanse dos ejemplos en `einhil.dem' y `bradic.dem'; el
primero utiliza la acción de Einstein-Hilbert para derivar el campo
tensorial de Einstein en el caso homogéneo e isotrópico (ecuaciones de
Friedmann), así como en el caso esferosimétrico estático (solución de
Schwarzschild); el segundo demuestra cómo calcular las ecuaciones de
Friedmann a partir de la acción de la teoría de la gravedad de
Brans-Dicke, y también muestra cómo derivar el hamiltoniano asociado
con la teoría del campo escalar.

27.1.1 Notación tensorial
-------------------------

Hasta ahora, el paquete `itensor' de Maxima utilizaba una notación que
algunas veces llevaba a una ordenación incorrecta de los índices. Por
ejemplo:

     (%i2) imetric(g);
     (%o2)                                done
     (%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                      i l  j k
     (%t3)                           g    g    a
                                                i j
     (%i4) ishow(contract(%))$
                                           k l
     (%t4)                                a

   Este resultado no es correcto a menos que `a' sea un tensor
simétrico. La razón por la que esto ocurre es que aunque `itensor'
mantenga correctamente el orden dentro del conjunto de índices
covariantes y contravariantes, una vez un índice sea aumentado o
disminuido, su posición relativa al otro conjunto de índices se pierde.

   Para evitar este problema, se ha desarrollado una notación
totalmente compatible con la anterior.En esta notación, los índices
contravariantes se insertan en las posiciones correctas en la lista de
índices covariantes, pero precedidos del signo negativo.

   En esta notación, el ejemplo anterior da el resultado correcto:

     (%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                      i l       j k
     (%t5)                           g    a    g
                                           i j
     (%i6) ishow(contract(%))$
                                           l k
     (%t6)                                a

   El único código que hace uso de esta notación es la función
`lc2kdt'.  Devido a que este código es nuevo, puede contener errores.

27.1.2 Manipulación indexada de tensores
----------------------------------------

El paquete `itensor' se carga haciendo `load(itensor)'. Para acceder a
las demos se hará `demo(tensor)'.

   En el paquete `itensor' un tensor se representa como un objeto
indexado, esto es, como una función de tres grupos de índices: los
covariantes, los contravariantes y los de derivadas. Los índices
covariantes se especifican mediante una lista que será el primer
argumento del objeto indexado, siendo los índices contravariantes otra
lista que será el segundo argumento del mismo objeto indexado. Si al
objeto indexado le falta cualquiera de estos grupos de índices,
entonces se le asignará al argumento correspondiente la lista vacía
`[]'.  Así, `g([a,b],[c])' representa un objeto indexado llamado `g',
el cual tiene dos índices covariantes `(a,b)', un índice contravariante
(`c') y no tiene índices de derivadas.

   Los índices de derivadas, si están presentes, se añaden como
argumentos adicionales a la función simbólica que representa al tensor.
Se pueden especificar explícitamente por el usuario o pueden crearse
durante el proceso de diferenciación respecto de alguna coordenada.
Puesto que la diferenciación ordinaria es conmutativa, los índices de
derivadas se ordenan alfanuméricamente, a menos que la variable
`iframe_flag' valga `true', indicando que se está utilizando una
métrica del sistema de referencia. Esta ordenación canónica hace
posible que Maxima reconozca, por ejemplo, que `t([a],[b],i,j)' es lo
mismo que `t([a],[b],j,i)'. La diferenciación de un objeto indexado con
respecto de alguna coordenada cuyo índice no aparece como argumento de
dicho objeto indexado, dará como resultado cero. Esto se debe a que
Maxima no sabe si el tensor representado por el objeto indexado depende
implícitamente de la coordenada correspondiente. Modificando la función
`diff' de Maxima en `itensor', se da por hecho que todos los objetos
indexados dependen de cualquier variable de diferenciación, a menos que
se indique lo contrario. Esto hace posible que la convención sobre la
sumación se extienda a los índices de derivadas. El paquete `itensor'
trata a los índices de derivadas como covariantes.

   Las siguientes funciones forman parte del paquete `itensor' para la
manipulación indexada de vectores. En lo que respecta a las rutinas de
simplificación, no se considera en general que los objetos indexados
tengan propiedades simétricas. Esto puede cambiarse reasignando a la
variable `allsym[false]' el valor `true', con lo cual los objetos
indexados se considerarán simétricos tanto respecto de sus índices
covariantes como contravariantes.

   En general, el paquete `itensor' trata a los tensores como objetos
opacos. Las ecuaciones tensoriales se manipulan en base a reglas
algebraicas, como la simetría y la contracción. Además, en el paquete
`itensor' hay funciones para la diferenciación covariante, la curvatura
y la torsión. Los cálculos se pueden realizar respecto de una métrica
del sistema de referencia móvil, dependiendo de las asignaciones dadas
a la variable `iframe_flag'.

   La siguiente sesión de ejemplo demuestra cómo cargar el paquete
`itensor', especificar el nombre de la métrica y realizar algunos
cálculos sencillos.

     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) imetric(g);
     (%o2)                                done
     (%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
     (%i4) ishow(g([k,l],[]))$
     (%t4)                               e p
                                            k l
     (%i5) ishow(diff(v([i],[]),t))$
     (%t5)                                  0
     (%i6) depends(v,t);
     (%o6)                               [v(t)]
     (%i7) ishow(diff(v([i],[]),t))$
                                         d
     (%t7)                               -- (v )
                                         dt   i
     (%i8) ishow(idiff(v([i],[]),j))$
     (%t8)                                v
                                           i,j
     (%i9) ishow(extdiff(v([i],[]),j))$
     (%t9)                             v    - v
                                        j,i    i,j
                                       -----------
                                            2
     (%i10) ishow(liediff(v,w([i],[])))$
                                    %3          %3
     (%t10)                        v   w     + v   w
                                        i,%3    ,i  %3
     (%i11) ishow(covdiff(v([i],[]),j))$
                                                   %4
     (%t11)                        v    - v   ichr2
                                    i,j    %4      i j
     (%i12) ishow(ev(%,ichr2))$
                     %4 %5
     (%t12) v    - (g      v   (e p       + e   p     - e p       - e    p
             i,j            %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                              + e p       + e   p    ))/2
                                                   i %5,j    ,j  i %5
     (%i13) iframe_flag:true;
     (%o13)                               true
     (%i14) ishow(covdiff(v([i],[]),j))$
                                                  %6
     (%t14)                        v    - v   icc2
                                    i,j    %6     i j
     (%i15) ishow(ev(%,icc2))$
                                                  %6
     (%t15)                        v    - v   ifc2
                                    i,j    %6     i j
     (%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
                  %6 %7                    %6 %7
     (%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                         %6    j %7 i             %6    i j %7      i,j

                                                  %6 %7
                                             - ifg      v   ifb      )/2
                                                         %6    %7 i j
     (%i17) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t17)                            s    - s
                                        i j    j i
     (%i18) decsym(s,2,0,[sym(all)],[]);
     (%o18)                               done
     (%i19) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t19)                                 0
     (%i20) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t20)                            a    + a
                                        j i    i j
     (%i21) decsym(a,2,0,[anti(all)],[]);
     (%o21)                               done
     (%i22) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t22)                                 0



Local Variables:
coding: iso-8859-1
End:
