This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Este é o Manual do Maxima no formato Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definições para Entrada e Saída,  Prev: Ficheiros,  Up: Entrada e Saída

9.3 Definições para Entrada e Saída de Dados
============================================

 -- Variável de sistema: __
     `__' é a expressão de entrada actualmente sendo avaliada.  Isto é,
     enquanto um expressão de entrada <expr> está sendo avaliada, `__'
     é <expr>.

     `__' é atribuída à expressão de entrada antes de a entrada ser
     simplificada ou avaliada.  Todavia, o valor de `__' é simplificado
     (mas não avaliado) quando for mostrado.

     `__' é reconhecido por `batch' e `load'.  Em um ficheiro
     processado por `batch', `__' tem o mesmo significado que na linha
     de comando interativa.  Em um ficheiro processado por `load', `__'
     está associado à expressão de entrada mais recentemente informada
     no prompt interativo ou em um ficheiro de lote (batch); `__' não é
     associado à expressões de entrada no ficheiro que está sendo
     processado.  Em particular, quando `load (<nomeficheiro>)' for
     chamado a partir da linha de comando interativa, `__' é associado
     a `load (<filename>)' enquanto o ficheiro está sendo processado.

     Veja também `_' e `%'.

     Exemplos:

          (%i1) print ("Eu fui chamada como", __);
          Eu fui chamada como print(Eu fui chamada como, __)
          (%o1)              print(Eu fui chamada como, __)
          (%i2) foo (__);
          (%o2)                     foo(foo(__))
          (%i3) g (x) := (print ("Expressão actual de entrada =", __), 0);
          (%o3) g(x) := (print("Expressão actual de entrada =", __), 0)
          (%i4) [aa : 1, bb : 2, cc : 3];
          (%o4)                       [1, 2, 3]
          (%i5) (aa + bb + cc)/(dd + ee + g(x));
                                         cc + bb + aa
          Expressão actual de entrada = --------------
                                        g(x) + ee + dd
                                          6
          (%o5)                        -------
                                       ee + dd


 -- Variável de sistema: _
     `_' é a mais recente expressão de  entrada (e.g., `%i1', `%i2',
     `%i3', ...).

     A `_' é atribuída à expressão de entrada antes dela ser
     simplificada ou avaliada.  Todavia, o valor de `_' é simplificado
     (mas não avaliado) quando for mostrado.

     `_' é reconhecido por `batch' e `load'.  Em um ficheiro processado
     por `batch', `_' tem o mesmo significado que na linha de comando
     interativa.  Em um ficheiro processado por load `load', `_' está
     associado à expressão de entrada mais recentemente avaliada na
     linha de comando interativa ou em um ficheiro de lote; `_' não
     está associada a expressões de entrada no ficheiro que está sendo
     processado.

     Veja também `__' e `%'.

     Exemplos:

          (%i1) 13 + 29;
          (%o1)                          42
          (%i2) :lisp $_
          ((MPLUS) 13 29)
          (%i2) _;
          (%o2)                          42
          (%i3) sin (%pi/2);
          (%o3)                           1
          (%i4) :lisp $_
          ((%SIN) ((MQUOTIENT) $%PI 2))
          (%i4) _;
          (%o4)                           1
          (%i5) a: 13$
          (%i6) b: 29$
          (%i7) a + b;
          (%o7)                          42
          (%i8) :lisp $_
          ((MPLUS) $A $B)
          (%i8) _;
          (%o8)                         b + a
          (%i9) a + b;
          (%o9)                          42
          (%i10) ev (_);
          (%o10)                         42


 -- Variável de sistema: %
     `%' é a expressão de saída (e.g., `%o1', `%o2', `%o3', ...)  mais
     recentemente calculada pelo Maxima, pode ou não ser mostrada.

     `%' é reconhecida por `batch' e `load'.  Em um ficheiro processado
     por `batch', `%' tem o mesmo significado que na linha de comando
     interativa.  Em um ficheiro processado por `load', `%' é associado
     à expressão de entrada mais recentemente calculada na linha de
     comando interativa ou em um ficheiro de lote; `%' não está
     associada a expressões de saída no ficheiro que está sendo
     processado.

     Veja também `_', `%%', e `%th'


 -- Variável de sistema: %%
     Em declaração composta, a saber `block', `lambda', ou `(<s_1>,
     ..., <s_n>)', `%%' é os valor da declaração anterior.  Por exemplo,

          block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
          block ([prev], prev: integrate (x^5, x), ev (prev, x=2) - ev (prev, x=1));

     retornam o mesmo resultado, a saber `21/2'.

     Uma declaração composta pode compreender outras declarações
     compostas.  Pode uma declaração ser simples ou composta, `%%' é o
     valor da declaração anterior.  Por exemplo,

          block (block (a^n, %%*42), %%/6)

     retorna `7*a^n'.

     Dentro da declaração composta, o valor de `%%' pode ser
     inspecionado em uma parada de linha de comando, que é aberta pela
     execução da função `break'.  Por exemplo, na parada de linha de
     comando aberta por

          block (a: 42, break ())$

     digitando `%%;' retorna `42'.

     Na primeira declaração em uma declaração composta, ou fora de uma
     declaração composta, `%%' é indefinido.

     `%%'  reconhecido por `batch' e `load', e possem o mesmo
     significao que na linha de comando interativa.

     Veja também `%'.


 -- Variável de opção: %edispflag
     Valor por omissão: `false'

     Quando `%edispflag' é `true', Maxima mostra `%e' para um expoente
     negativo como um quociente.  Por exemplo, `%e^-x' é mostrado como
     `1/%e^x'.


 -- Função: %th (<i>)
     O valor da <i>'ésima expressão prévia de saída.  Isto é, se a
     próxima expressão a ser calculada for a <n>'ésima saída, `%th
     (<m>)' será a (<n> - <m>)'ésima saída.

     `%th' é útil em ficheiros `batch' ou para referir-se a um grupo de
     expressões de saída.  Por exemplo,

          block (s: 0, for i:1 thru 10 do s: s + %th (i))$

     escolhe `s' para a soma das últimas dez expressões de saída.

     `%th' é reconhecido por `batch' e `load'.  Em um ficheiro
     processado por `batch', `%th' possue o mesmo significado que na
     linha de comando interativa.  Em um ficheiro processado por `load',
     `%th' refere-se a expressões de saída mais recentemente calculadas
     na linha de comando interativa ou em um ficheiro de lote; `%th'
     não se refere a expressões de saída no ficheiro que está sendo
     processado.

     Veja também `%'.


 -- Símbolo especial: ?
     Como prefixo para uma função ou nome de variável, `?' significa que
     o nome é um nome Lisp, não um nome Maxima.  Por exemplo, `?round'
     significa a função Lisp `ROUND'.  Veja _Lisp e Maxima_ para mais
     sobre esse ponto.

     A notação `? palavra' (um ponto de interrogação seguido de uma
     palavra e separado desta por um espaço em branco) é equivalente a
     `describe("palavra")'.  O ponto de interrogação deve aparecer no
     início de uma linha de entrada; de outra forma o ponto de
     interrogação não é reconhecido com um pedido de documentação.


 -- Símbolo especial: ??
     A notação `?? palavra' (`??' seguido de um espaço em branco e uma
     palavra) é equivalente a `describe("palavra", inexact)'.  O ponto
     de interrogação deve ocorrer no início de uma linha de entrada; de
     outra forma não é reconhecido com um pedido de documentação.


 -- Variável de opção: absboxchar
     Valor por omissão: `!'

     `absboxchar' é o caracter usado para para desenhar o sinal de valor
     absoluto em torno de expressões que são maiores que uma linha de
     altura.


 -- Variável de opção: file_output_append
     Valor por omissão: `false'

     `file_output_append' governa se funções de saída de ficheiro
     anexam ao final ou truncam seu ficheiro de saída.  Quando
     `file_output_append' for `true', tais funções anexam ao final de
     seu ficheiro de saída.  De outra forma, o ficheiro de saída é
     truncado.

     `save', `stringout', e `with_stdout' respeitam
     `file_output_append'.  Outras funções que escrevem ficheiros de
     saída não respeitam `file_output_append'.  Em partivular, montagem
     de gráficos e traduções de funções sempre truncam seu ficheiro de
     saída, e `tex' e `appendfile' sempre anexam ao final.


 -- Função: appendfile (<filename>)
     Adiciona ao final de <filename> uma transcrição do console.
     `appendfile' é o mesmo que `writefile', excepto que o ficheiro
     transcrito, se já existe, terá sempre alguma coisa adicionada ao
     seu final.

     `closefile' fecha o ficheiro transcrito que foi aberto
     anteriormente por `appendfile' ou por `writefile'.


 -- Função: batch (<filename>)
     Lê expressões Maxima do ficheiro <filename> e as avalia.  `batch'
     procura pelo ficheiro <filename> na lista `file_search_maxima'.
     Veja `file_search'.

     <filename> compreende uma sequência de expressões Maxima, cada uma
     terminada com `;' ou `$'.  A varável especial `%' e a função `%th'
     referem-se a resultados prévios dentro do ficheiro.  O ficheiro
     pode incluir construções `:lisp'.  Espaços, tabulações, e o
     caracter de nova linha no ficheiro serão ignorados.  um ficheiro
     de entrada conveniente pode ser criado por um editor de texto ou
     pela função `stringout'.

     `batch' lê cada expressão de entrada de <filename>, mostra a
     entrada para o console, calcula a correspondente expressão de
     saída, e mostra a expressão de saída.  Rótulos de entrada são
     atribuídos para expressões de entrada e rótulos de saída são
     atribuídos para expressões de saída.  `batch' avalia toda
     expressão de entrada no ficheiro a menos que exista um erro.  Se
     uma entrada de utilizador for requisitada (by `asksign' ou
     `askinteger', por exemplo) `batch' interrompe para colectar a
     entrada requisitada e então continua.

     Isso possibilita interromper `batch' pela digitação de `control-C'
     no console.  O efeito de `control-C' depende da subjacente
     implementação do Lisp.

     `batch' tem muitos usos, tais como fornecer um reservatório para
     trabalhar linhas de comando, para fornecer demonstrações livres de
     erros, ou para ajudar a organizar alguma coisa na solução de
     problemas complexos.

     `batch' avalia seu argumento.  `batch' não possui valor de retorno.

     Veja também `load', `batchload', e `demo'.


 -- Função: batchload (<filename>)
     Lê expressões Maxima de <filename> e as avalia, sem mostrar a
     entrada ou expressões de saída e sem atribuir rótulos para
     expressões de saída.  Saídas impressas (tais como produzidas por
     `print' ou `describe') são mostradas, todavia.

     A variável especial `%' e a função `%th' referem-se a resultados
     anteriores do interpretador interativo, não a resultados dentro do
     ficheiro.  O ficheiro não pode incluir construções `:lisp'.

     `batchload' retorna o caminho de <filename>, como uma sequência de
     caracteres.  `batchload' avalia seu argumento.

     Veja também `batch' e `load'.


 -- Função: closefile ()
     Fecha o ficheiro transcrito aberto por `writefile' ou `appendfile'.


 -- Função: collapse (<expr>)
     Reduz <expr> fazendo com que todas as suas subexpressões comuns
     (i.e., iguais) serem compartilhadas (i.e., usam a mesma células),
     dessa forma exonomizando espaço.  (`collapse' é uma subrotina
     usada pelo comando `optimize'.)  Dessa forma, chamar `collapse'
     pode ser útil após um `save' ficheiro.  Pode diminuir muitas
     expressões juntas pelo uso de `collapse ([<expr_1>, ...,
     <expr_n>])'.  Similarmente, pode diminuir os elementos de um array
     `A' fazendo `collapse (listarray ('A))'.


 -- Função: concat (<arg_1>, <arg_2>, ...)
     Concatena seus argumentos.  Os argumentos devem obrigatóriamente
     serem avaliados para atomos.  O valor de retorno é um símbolo se o
     primeiro argumento for um símbolo e uma sequência de caracteres no
     formato do Maxima em caso contrário.

     `concat' avalia seus argumentos.  O apóstrofo `'' evita avaliação.

          (%i1) y: 7$
          (%i2) z: 88$
          (%i3) concat (y, z/2);
          (%o3)                          744
          (%i4) concat ('y, z/2);
          (%o4)                          y44

     Um símbolo construído por `concat' pode ser atribuído a um valor e
     aparecer em expressões.  O operador de atribuição `::' (duplo dois
     pontos) avalia seu lado esquerdo.

          (%i5) a: concat ('y, z/2);
          (%o5)                          y44
          (%i6) a:: 123;
          (%o6)                          123
          (%i7) y44;
          (%o7)                          123
          (%i8) b^a;
                                         y44
          (%o8)                         b
          (%i9) %, numer;
                                         123
          (%o9)                         b

     Note que embora `concat (1, 2)' seja visto como um números, isso é
     uma sequência de caracteres no formato do Maxima.

          (%i10) concat (1, 2) + 3;
          (%o10)                       12 + 3


 -- Função: sconcat (<arg_1>, <arg_2>, ...)
     Concatena seus argumentos em uma sequência de caracteres.  Ao
     contrário de `concat', os argumentos arrumados não precisam ser
     atômicos.

     O resultado é uma sequência de caracteres no format do Lisp.

          (%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
          (%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3


 -- Função: disp (<expr_1>, <expr_2>, ...)
     é como `display' mas somente os valores dos argumentos são
     mostrados em lugar de equações.  Isso é útil para argumentos
     complicados que não possuem nomes ou onde somente o valor do
     argumento é de interesse e não o nome.


 -- Função: dispcon (<tensor_1>, <tensor_2>, ...)
 -- Função: dispcon (all)
     Mostram as propriedades de contração de seus argumentos como foram
     dados para `defcon'.  `dispcon (all)' mostra todas as propriedades
     de contração que foram definidas.


 -- Função: display (<expr_1>, <expr_2>, ...)
     Mostra equações cujo lado esquerdo é <expr_i> não avaliado, e cujo
     lado direito é o valor da expressão centrada na linha.  Essa
     função é útil em blocos e em `for' declarações com o objectivo de
     ter resultados intermédios mostrados.  The Os argumentos para
     `display' são usualmente átomos, variáveis subscritas, ou chamadas
     de função.  Veja também `disp'.

          (%i1) display(B[1,2]);
                                                2
                                   B     = X - X
                                    1, 2
          (%o1)                            done


 -- Variável de opção: display2d
     Valor por omissão: `true'

     Quando `display2d' é `false', O console visualizador é
     unidimensional ao invés de bidimensional.


 -- Variável de opção: display_format_internal
     Valor por omissão: `false'

     Quando `display_format_internal' é `true', expressões são
     mostradas sem ser por caminhos que escondam a representação
     matemática interna.  O visualizador então corresponde ao que
     `inpart' retorna em lugar de `part'.

     Exemplos:

          User     part       inpart
          a-b;      A - B     A + (- 1) B

                     A            - 1
          a/b;       -         A B
                     B
                                 1/2
          sqrt(x);   sqrt(X)    X

                    4 X        4
          X*4/3;    ---        - X
                     3         3


 -- Função: dispterms (<expr>)
     Mostra <expr> em partes uma abaixo da outra.  Isto é, primeiro o
     operador de <expr> é mostrado, então cada parcela em uma adição,
     ou factores em um produto, ou parte de uma expressão mais geral é
     mostrado separadamente.  Isso é útil se <expr> é muito larga para
     ser mostrada de outra forma.  Por exemplo se `P1', `P2', ...  são
     expressões muito largas então o programa visualizador pode sair
     fora do espaço de armazenamento na tentativa de mostrar `P1 + P2 +
     ...'  tudo de uma vez.  Todavia, `dispterms (P1 + P2 + ...)'
     mostra `P1', então abaixo disso `P2', etc.  Quando não usando
     `dispterms', se uma expressão exponencial é muito alta para ser
     mostrada como `A^B' isso aparece como `expt (A, B)' (ou como
     `ncexpt (A, B)' no caso de `A^^B').


 -- Variável de opção: error_size
     Valor por omissão: 10

     `error_size' modifica mensagens de erro conforme o tamanho das
     expressões que aparecem nelas.  Se o tamanho de uma expressão
     (como determinado pela função Lisp `ERROR-SIZE') é maior que
     `error_size', a expressão é substituída na mensagem por um símbolo,
     e o o símbolo é atribuído à expressão.  Os símbolos são obtidos da
     lista `error_syms'.

     De outra forma, a expressão é menor que `error_size', e a
     expressão é mostrada na mensagem.

     Veja também `error' e `error_syms'.

     Exemplo:

     O tamanho de `U', como determinado por `ERROR-SIZE', é 24.

          (%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

          (%i2) error_size: 20$

          (%i3) error ("Expressão exemplo é", U);

          Expressão exemplo é errexp1
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) errexp1;
                                      E
                                     D
                                    C   + B + A
          (%o4)                    --------------
                                   cos(X - 1) + 1
          (%i5) error_size: 30$

          (%i6) error ("Expressão exemplo é", U);

                                     E
                                    D
                                   C   + B + A
          Expressão exemplo é --------------
                                  cos(X - 1) + 1
           -- an error.  Quitting.  To debug this try debugmode(true);


 -- Variável de opção: error_syms
     Valor por omissão: `[errexp1, errexp2, errexp3]'

     Em mensagens de erro, expressões mais largas que `error_size' são
     substituídas por símbolos, e os símbolos são escolhidos para as
     expressões.  Os símbolos são obtidos da lista `error_syms'.  A
     primeira expressão muito larga é substituída por `error_syms[1]',
     a segunda por `error_syms[2]', e assim por diante.

     Se houverem mais expressões muito largas que há elementos em
     `error_syms', símbolos são construídos automaticamente, com o
     <n>-ésimo símbolo equivalente a `concat ('errexp, <n>)'.

     Veja também `error' e `error_size'.


 -- Função: expt (<a>, <b>)
     Se uma expressão exponencial é muito alta para ser mostrada cmo
     `<a>^<b>' isso aparece como `expt (<a>, <b>)' (ou como `ncexpt
     (<a>, <b>)' no caso de `<a>^^<b>').

     `expt' e `ncexpt' não são reconhecidas em entradas.


 -- Variável de opção: exptdispflag
     Valor por omissão: `true'

     Quando `exptdispflag' é `true', Maxima mostra expressões com
     expoente negativo usando quocientes, e.g., `X^(-1)' como `1/X'.


 -- Função: filename_merge (<path>, <filename>)
     Constroem um caminho modificado de <path> e <filename>.  Se o
     componente final de <path> é da forma `###.<algumacoisa>', o
     componente é substituído com `<filename>.<algumacoisa>'.  De outra
     forma, o componente final é simplesmente substituído por
     <filename>.


 -- Função: file_search (<filename>)
 -- Função: file_search (<filename>, <pathlist>)
     `file_search' procura pelo ficheiro <filename> e retorna o caminho
     para o ficheiro (como uma sequência de caracteres) se ele for
     achado; de outra forma `file_search' retorna `false'.
     `file_search (<filename>)' procura nos directórios padrões de
     busca, que são especificados pelas variáveis `file_search_maxima',
     `file_search_lisp', e `file_search_demo'.

     `file_search' primeiro verifica se o nome actual passado existe,
     antes de tentar coincidir esse nome actual com o modelo "coringa"
     de busca do ficheiro.  Veja `file_search_maxima' concernente a
     modelos de busca de ficheiros.

     O argumento <filename> pode ser um caminho e nome de ficheiro, ou
     apenas um nome de ficheiro, ou, se um directório de busca de
     ficheiro inclui um modelo de busca de ficheiro, apenas a base do
     nome de ficheiro (sem uma extensão).  Por exemplo,

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     todos acham o mesmo ficheiro, assumindo que o ficheiro exista e
     `/home/wfs/special/###.mac' está em `file_search_maxima'.

     `file_search (<filename>, <pathlist>)' procura somente nesses
     directórios especificados por <pathlist>, que é uma lista de
     sequências de caracteres.  O argumento <pathlist> substitui os
     directórios de busca padrão, então se a lista do caminho é dada,
     `file_search' procura somente nesses especificados, e não qualquer
     dos directórios padrão de busca.  Mesmo se existe somente um
     directório em <pathlist>, esse deve ainda ser dado como uma lista
     de um único elemento.

     O utilizador pode modificar o directório de busca padrão.  Veja
     `file_search_maxima'.

     `file_search' é invocado por `load' com `file_search_maxima' e
     `file_search_lisp' como directórios de busca.


 -- Variável de opção: file_search_maxima
 -- Variável de opção: file_search_lisp
 -- Variável de opção: file_search_demo
     Essas variáveis especificam listas de directórios a serem
     procurados por `load', `demo', e algumas outras funções do Maxima.
     O valor padrão dessas variáveis nomeia vários directórios na
     instalaçã padrão do Maxima.

     O usuáro pode modificar essas variáveis, quer substituindo os
     valores padrão ou colocando no final directórios adicionais.  Por
     exemplo,

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     substitui o valor padrão de `file_search_maxima', enquanto

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     adiciona no final da lista dois directórios adicionais.  Isso pode
     ser conveniente para colocar assim uma expressão no ficheiro
     `maxima-init.mac' de forma que o caminho de busca de ficheiro é
     atribuído automaticamente quando o Maxima inicia.

     Múltiplas extensões de ficheiro e e múltiplos caminhos podem ser
     especificados por construções "coringa" especiais.  A sequência de
     caracteres `###' expande a busca para além do nome básico,
     enquanto uma lista separada por vírgulas e entre chaves
     `{foo,bar,baz}' expande em múltiplas sequências de caracteres.
     Por exemplo, supondo que o nome básico a ser procurado seja
     `neumann',

          "/home/{wfs,gcj}/###.{lisp,mac}"

     expande em `/home/wfs/neumann.lisp', `/home/gcj/neumann.lisp',
     `/home/wfs/neumann.mac', e `/home/gcj/neumann.mac'.


 -- Função: file_type (<filename>)
     Retorna uma suposta informação sobre o conteúdo de <filename>,
     baseada na extensão do ficheiro.  <filename> não precisa
     referir-se a um ficheiro actual; nenhuma tentativa é feita para
     abrir o ficheiro e inspecionar seu conteúdo.

     O valor de retorno é um símbolo, qualquer um entre `object',
     `lisp', ou `maxima'.  Se a extensão começa com `m' ou `d',
     `file_type' retorna `maxima'.  Se a extensão começa om `l',
     `file_type' retorna `lisp'.  Se nenhum dos acima, `file_type'
     retorna `object'.


 -- Função: grind (<expr>)
 -- Variável de opção: grind
     A função `grind' imprime <expr> para o console em uma forma
     adequada de entrada para Maxima.  `grind' sempre retorna `done'.

     Quando <expr> for um nome de uma função ou o nome de uma macro,
     `grind' mostra na tela a definição da função ou da macro em lugar
     de apenas o nome.

     Veja também `string', que retorna uma sequência de caracteres em
     lugar de imprimir sua saída.  `grind' tenta imprimir a expressão
     de uma maneira que a faz levemente mais fácil para ler que a saída
     de `string'.

     Quando a variável `grind' é `true', a saída de `string' e
     `stringout' tem o mesmo formato que `grind'; de outra forma
     nenhuma tentativa é feita para formatar especialmente a saída
     dessas funções.  O valor padrão da variável `grind' é `false'.

     `grind' pode também ser especificado como um argumento de
     `playback'.  Quando `grind' está presente, `playback' imprime
     expressões de entrada no mesmo formato que a função `grind'.  De
     outra forma, nenhuma tentativa é feita para formatar especialmente
     as expressões de entrada.  `grind' avalia seus argumentos.

     Exemplos:

          (%i1) aa + 1729;
          (%o1)                       aa + 1729
          (%i2) grind (%);
          aa+1729$
          (%o2)                         done
          (%i3) [aa, 1729, aa + 1729];
          (%o3)                 [aa, 1729, aa + 1729]
          (%i4) grind (%);
          [aa,1729,aa+1729]$
          (%o4)                         done
          (%i5) matrix ([aa, 17], [29, bb]);
                                     [ aa  17 ]
          (%o5)                      [        ]
                                     [ 29  bb ]
          (%i6) grind (%);
          matrix([aa,17],[29,bb])$
          (%o6)                         done
          (%i7) set (aa, 17, 29, bb);
          (%o7)                   {17, 29, aa, bb}
          (%i8) grind (%);
          {17,29,aa,bb}$
          (%o8)                         done
          (%i9) exp (aa / (bb + 17)^29);
                                          aa
                                      -----------
                                               29
                                      (bb + 17)
          (%o9)                     %e
          (%i10) grind (%);
          %e^(aa/(bb+17)^29)$
          (%o10)                        done
          (%i11) expr: expand ((aa + bb)^10);
                   10           9        2   8         3   7         4   6
          (%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
                   5   5         6   4         7   3        8   2
           + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
                  9        10
           + 10 aa  bb + aa
          (%i12) grind (expr);
          bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
               +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
               +10*aa^9*bb+aa^10$
          (%o12)                        done
          (%i13) string (expr);
          (%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
          +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
          bb+aa^10
          (%i14) cholesky (A):= block ([n : length (A), L : copymatrix (A),
          p : makelist (0, i, 1, length (A))], for i thru n do for j : i thru n do
          (x : L[i, j], x : x - sum (L[j, k] * L[i, k], k, 1, i - 1), if i = j then
          p[i] : 1 / sqrt(x) else L[j, i] : x * p[i]), for i thru n do L[i, i] : 1 / p[i],
          for i thru n do for j : i + 1 thru n do L[i, j] : 0, L)$
          (%i15) grind (cholesky);
          cholesky(A):=block(
                   [n:length(A),L:copymatrix(A),
                    p:makelist(0,i,1,length(A))],
                   for i thru n do
                       (for j from i thru n do
                            (x:L[i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),
                             if i = j then p[i]:1/sqrt(x)
                                 else L[j,i]:x*p[i])),
                   for i thru n do L[i,i]:1/p[i],
                   for i thru n do (for j from i+1 thru n do L[i,j]:0),L)$
          (%o15)                        done
          (%i16) string (fundef (cholesky));
          (%o16) cholesky(A):=block([n:length(A),L:copymatrix(A),p:makelis\
          t(0,i,1,length(A))],for i thru n do (for j from i thru n do (x:L\
          [i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),if i = j then p[i]:1/sqrt(x\
          ) else L[j,i]:x*p[i])),for i thru n do L[i,i]:1/p[i],for i thru \
          n do (for j from i+1 thru n do L[i,j]:0),L)


 -- Variável de opção: ibase
     Valor por omissão: 10

     Inteiros fornecidos dentro do Maxima são interpretados com
     respeito à base `ibase'.

     A `ibase' pode ser atribuído qualquer inteiro entre 2 e 35
     (decimal), inclusive.  Quando `ibase' é maior que 10, os numerais
     compreendem aos numerais decimais de 0 até 9 mais as letras
     maiúsculas do alfabeto A, B, C, ..., como necessário.  Os numerais
     para a base 35, a maior base aceitável, compreendem de 0 até 9 e
     de A até Y.

     Veja também `obase'.


 -- Variável de opção: inchar
     Valor por omissão: `%i'

     `inchar' é o prefixo dos rótulos de expressões fornecidas pelo
     utilizador.  Maxima automaticamente constrói um rótulo para cada
     expressão de entrada por concatenação de `inchar' e `linenum'.  A
     `inchar' pode ser atribuído qualquer sequência de caracteres ou
     símbolo, não necessariamente um caracter simples.

          (%i1) inchar: "input";
          (%o1)                                input
          (input1) expand ((a+b)^3);
                                      3        2      2      3
          (%o1)                      b  + 3 a b  + 3 a  b + a
          (input2)

     Veja também `labels'.


 -- Função: ldisp (<expr_1>, ..., <expr_n>)
     Mostra expressões <expr_1>, ..., <expr_n> para o console como
     saída impressa na tela.  `ldisp' atribue um rótulo de expressão
     intermédia a cada argumento e retorna a lista de rótulos.

     Veja também `disp'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisp (e, f);
                                             3
          (%t3)                       (b + a)

                               3        2      2      3
          (%t4)               b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                             3
          (%o4)                       (b + a)
          (%i5) %t4;
                               3        2      2      3
          (%o5)               b  + 3 a b  + 3 a  b + a


 -- Função: ldisplay (<expr_1>, ..., <expr_n>)
     Mostra expressões <expr_1>, ..., <expr_n> para o console como
     saída impressa na tela.  Cada expressão é impressa como uma
     equação da forma `lhs = rhs' na qual `lhs' é um dos argumentos de
     `ldisplay' e `rhs' é seu valor.  Tipicamente cada argumento é uma
     variável.  `ldisp' atribui um rótulo de expressão intermediáia a
     cada equação e retorna a lista de rótulos.

     Veja também `display'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisplay (e, f);
                                               3
          (%t3)                     e = (b + a)

                                 3        2      2      3
          (%t4)             f = b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                               3
          (%o4)                     e = (b + a)
          (%i5) %t4;
                                 3        2      2      3
          (%o5)             f = b  + 3 a b  + 3 a  b + a


 -- Variável de opção: linechar
     Valor por omissão: `%t'

     `linechar' é o refixo de rótulos de expressões intermédias gerados
     pelo Maxima.  Maxima constrói um rótulo para cada expressão
     intermédia (se for mostrada) pela concatenação de `linechar' e
     `linenum'.  A `linechar' pode ser atribuído qualquer sequência de
     caracteres ou símbolo, não necessáriamente um caractere simples.

     Expressões intermédias podem ou não serem mostradas.  See
     `programmode' e `labels'.


 -- Variável de opção: linel
     Valor por omissão: 79

     `linel' é a largura assumida (em caracteres) do console para o
     propósito de mostrar expressões.  A `linel' pode ser atribuído
     qualquer valor pelo utilizador, embora valores muio pequenos ou
     muito grandes possam ser impraticáveis.  Textos impressos por
     funções internas do Maxima, tais como mensagens de erro e a saída
     de `describe', não são afectadas por `linel'.


 -- Variável de opção: lispdisp
     Valor por omissão: `false'

     Quando `lispdisp' for `true', símbolos Lisp são mostrados com um
     ponto de interrogação `?' na frente.  De outra forma, símbolos
     Lisp serão mostrados sem o ponto de interrogaçõ na frente.

     Exemplos:

          (%i1) lispdisp: false$
          (%i2) ?foo + ?bar;
          (%o2)                       foo + bar
          (%i3) lispdisp: true$
          (%i4) ?foo + ?bar;
          (%o4)                      ?foo + ?bar


 -- Função: load (<nomeficheiro>)
     Avalia expressões em <nomeficheiro>, dessa forma conduzindo
     variáveis, funções, e outros objectos dentro do Maxima.  A
     associação de qualquer objecto existente é substituída pela
     associação recuperada de <nomeficheiro>.  Para achar o ficheiro,
     `load' chama `file_search' com `file_search_maxima' e
     `file_search_lisp' como directórios de busca.  Se `load' obtém
     sucesso, isso retorna o nome do ficheiro.  De outra forma `load'
     imprime uma mensagem e erro.

     `load' trabalha igualmente bem para códigos Lisp e códigos Maxima.
     Ficheiros criados por `save', `translate_file', e `compile_file',
     que criam códigos Lisp, e `stringout', que criam códigos Maxima,
     podem ser processadas por `load'.  `load' chama `loadfile' para
     carregar ficheiros Lisp e `batchload' para carregar ficheiros
     Maxima.

     `load' não reconhece construções `:lisp' em ficheiros do Maxima, e
     quando processando <nomeficheiro>, as variáveis globais `_', `__',
     `%', e `%th' possuem as mesmas associações que possuiam quando
     `load' foi chamada.

     Veja também `loadfile', `batch', `batchload', e `demo'.
     `loadfile' processa ficheiros Lisp; `batch', `batchload', e `demo'
     processam ficheiros Maxima.

     Veja `file_search' para mais detalhes sobre o mecanismo de busca
     de ficheiros.

     `load' avalia seu argumento.


 -- Função: loadfile (<nomeficheiro>)
     Avalia expressões Lisp em <nomeficheiro>.  `loadfile' não invoca
     `file_search', então `nomeficheiro' deve obrigatóriamente incluir
     a extensão do ficheiro e tanto quanto o caminho como necessário
     para achar o ficheiro.

     `loadfile' pode processar ficheiros criados por `save',
     `translate_file', e `compile_file'.  O utilizador pode achar isso
     mais conveniente para usar `load' em lugar de `loadfile'.

     `loadfile' avalia seu argumento, então `nomeficheiro' deve
     obrigatóriamente ser uma sequência de caracteres literal, não uma
     variável do tipo sequência de caracteres.  O operador
     apóstrofo-apóstrofo `''' não aceita avaliação.


 -- Variável de opção: loadprint
     Valor por omissão: `true'

     `loadprint' diz se deve imprimir uma mensagem quando um ficheiro é
     chamado.

        * Quando `loadprint' é `true', sempre imprime uma mensagem.

        * Quando `loadprint' é `'loadfile', imprime uma mensagem
          somente se um ficheiro é chamado pela função `loadfile'.

        * Quando `loadprint' é `'autoload', imprime uma mensagem
          somente se um ficheiro é automaticamente carregado.  Veja
          `setup_autoload'.

        * Quando `loadprint' é `false', nunca imprime uma mensagem.


 -- Variável de opção: obase
     Valor por omissão: 10

     `obase' é a base para inteiros mostrados pelo Maxima.

     A `obase' poode ser atribuído qualquer inteiro entre 2 e 35
     (decimal), inclusive.  Quando `obase' é maior que 10, os numerais
     compreendem os numerais decimais de 0 até 9 e letras maiúsulas do
     alfabeto A, B, C, ..., quando necessário.  Os numerais para a base
     35, a maior base aceitável, compreendem de 0 até 9, e de A até Y.

     Veja também `ibase'.


 -- Variável de opção: outchar
     Valor por omissão: `%o'

     `outchar' é o prefixo dos rótulos de expressões calculadas pelo
     Maxima.  Maxima automaticamente constrói um rótulo para cada
     expressão calculada pela concatenação de `outchar' e `linenum'.  A
     `outchar' pode ser atribuído qualquer sequência de caracteres ou
     símbolo, não necessáriamente um caractere simples.

          (%i1) outchar: "output";
          (output1)                           output
          (%i2) expand ((a+b)^3);
                                      3        2      2      3
          (output2)                  b  + 3 a b  + 3 a  b + a
          (%i3)

     Veja também `labels'.


 -- Variável de opção: packagefile
     Valor por omissão: `false'

     Projetistas de pacotes que usam `save' ou `translate' para criar
     pacotes (ficheiros) para outros usarem podem querer escolher
     `packagefile: true' para prevenir qu informações sejam
     acrescentadas à lista de informações do Maxima (e.g. `values',
     `funções') excepto onde necessário quando o ficheiro é carregado.
     Nesse caminho, o conteúdo do pacote não pegará no caminho do
     utilizador quando ele adicionar seus próprios dados.  Note que
     isso não resolve o problema de possíveis conflitos de nome.
     Também note que o sinalizador simplesmente afecta o que é saída
     para o ficheiro pacote.  Escolhendo o sinalizador para `true' é
     também útil para criar ficheiros de init do Maxima.


 -- Variável de opção: pfeformat
     Valor por omissão: `false'

     Quando `pfeformat' é `true', uma razão de inteiros é mostrada com
     o caractere sólido (barra normal), e um denominador inteiro `n' é
     mostrado como um termo multiplicativo em primeiro lugar `1/n'.

          (%i1) pfeformat: false$
          (%i2) 2^16/7^3;
                                        65536
          (%o2)                         -----
                                         343
          (%i3) (a+b)/8;
                                        b + a
          (%o3)                         -----
                                          8
          (%i4) pfeformat: true$
          (%i5) 2^16/7^3;
          (%o5)                       65536/343
          (%i6) (a+b)/8;
          (%o6)                      1/8 (b + a)


 -- Função: print (<expr_1>, ..., <expr_n>)
     Avalia e mostra <expr_1>, ..., <expr_n> uma após a outra, da
     esquerda para a direita, iniciando no lado esquerdo do console.

     O valor retornado por `print' é o valor de seu último argumento.
     `print' não gera rótulos de expressão intermédia.

     Veja também `display', `disp', `ldisplay', e `ldisp'.  Essas
     funções mostram uma expressão por linha, enquanto `print' tenta
     mostrar duas ou mais expressões por linha.

     Para mostrar o conteúdo de um ficheiro, veja `printfile'.

          (%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is", radcan (log (a^10/b)))$
                      3        2      2      3
          (a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is

                                                        10 log(a) - log(b)
          (%i2) r;
          (%o2)                  10 log(a) - log(b)
          (%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is", radcan (log (a^10/b)))$
                                     (a+b)^3 is

                               3        2      2      3
                              b  + 3 a b  + 3 a  b + a

                                   log (a^10/b) is

                                 10 log(a) - log(b)


 -- Função: tcl_output (<list>, <i0>, <skip>)
 -- Função: tcl_output (<list>, <i0>)
 -- Função: tcl_output ([<list_1>, ..., <list_n>], <i>)
     Imprime os elementos de uma lista entre chaves `{ }', conveniente
     como parte de um programa na linguagem Tcl/Tk.

     `tcl_output (<list>, <i0>, <skip>)' imprime <list>, começando com
     o elemento <i0> e imprimindo elementos `<i0> + <skip>', `<i0> + 2
     <skip>', etc.

     `tcl_output (<list>, <i0>)' é equivalente a `tcl_output (<list>,
     <i0>, 2)'.

     `tcl_output ([<list_1>, ..., <list_n>], <i>)' imprime os
     <i>'ésimos elementos de <list_1>, ..., <list_n>.

     Exemplos:

          (%i1) tcl_output ([1, 2, 3, 4, 5, 6], 1, 3)$

           {1.000000000     4.000000000
           }
          (%i2) tcl_output ([1, 2, 3, 4, 5, 6], 2, 3)$

           {2.000000000     5.000000000
           }
          (%i3) tcl_output ([3/7, 5/9, 11/13, 13/17], 1)$

           {((RAT SIMP) 3 7) ((RAT SIMP) 11 13)
           }
          (%i4) tcl_output ([x1, y1, x2, y2, x3, y3], 2)$

           {$Y1 $Y2 $Y3
           }
          (%i5) tcl_output ([[1, 2, 3], [11, 22, 33]], 1)$

           {SIMP 1.000000000     11.00000000
           }


 -- Função: read (<expr_1>, ..., <expr_n>)
     Imprime <expr_1>, ..., <expr_n>, então lê uma expressão do console
     e retorna a expressão avaliada.  A expressão é terminada com um
     ponto e vírgula `;' ou o sinal de dólar `$'.

     Veja também `readonly'.

          (%i1) foo: 42$
          (%i2) foo: read ("foo is", foo, " -- enter new value.")$
          foo is 42  -- enter new value.
          (a+b)^3;
          (%i3) foo;
                                               3
          (%o3)                         (b + a)


 -- Função: readonly (<expr_1>, ..., <expr_n>)
     Imprime <expr_1>, ..., <expr_n>, então lê uma expressão do console
     e retorna a expressão (sem avaliação).  A expressão é terminada
     com um `;' (ponto e vírgula) ou `$' (sinal de dólar).

          (%i1) aa: 7$
          (%i2) foo: readonly ("Forneça uma expressão:");
          Enter an expressão:
          2^aa;
                                            aa
          (%o2)                            2
          (%i3) foo: read ("Forneça uma expressão:");
          Enter an expressão:
          2^aa;
          (%o3)                            128

     Veja também `read'.


 -- Função: reveal (<expr>, <depth>)
     Substitue partes de <expr> no inteiro especificado <depth> com
     sumário descritivo.

        * Somas e diferenças são substituídas por `sum(<n>)' onde <n> é
          o número de operandos do produto.

        * Produtos são substituídos por `product(<n>)' onde <n> é o
          número de operandos da multiplicação.

        * Exponenciais são substituídos por `expt'.

        * Quocientes são substituídos por `quotient'.

        * Negação unária é substituída por `negterm'.

     Quando <depth> é maior que ou igual à máxima intensidade de <expr>,
     `reveal (<expr>, <depth>)' retornam <expr> sem modificações.

     `reveal' avalia seus argumentos.  `reveal' retorna expressão
     sumarizada.

     Exemplo:

          (%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                                    2            2
                                   b  - 2 a b + a
          (%o1)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e
          (%i2) reveal (e, 1);
          (%o2)                       quotient
          (%i3) reveal (e, 2);
                                       sum(3)
          (%o3)                        ------
                                       sum(3)
          (%i4) reveal (e, 3);
                               expt + negterm + expt
          (%o4)               ------------------------
                              product(2) + expt + expt
          (%i5) reveal (e, 4);
                                 2                 2
                                b  - product(3) + a
          (%o5)         ------------------------------------
                                   product(2)     product(2)
                        2 expt + %e           + %e
          (%i6) reveal (e, 5);
                                   2            2
                                  b  - 2 a b + a
          (%o6)              --------------------------
                                 sum(2)     2 b     2 a
                             2 %e       + %e    + %e
          (%i7) reveal (e, 6);
                                    2            2
                                   b  - 2 a b + a
          (%o7)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e


 -- Variável de opção: rmxchar
     Valor por omissão: `]'

     `rmxchar' é the caractere desenhado lado direito de uma matriz.

     Veja também `lmxchar'.


 -- Função: save (<filename>, <nome_1>, <nome_2>, <nome_3>, ...)
 -- Função: save (<filename>, values, functions, labels, ...)
 -- Função: save (<filename>, [<m>, <n>])
 -- Função: save (<filename>, <nome_1>=<expr_1>, ...)
 -- Função: save (<filename>, all)
 -- Função: save (<filename>, <nome_1>=<expr_1>, <nome_2>=<expr_2>, ...)
     Armazena os valores correntes de <nome_1>, <nome_2>, <nome_3>,
     ..., em <filename>.  Os argumentos são os nomes das variáveis,
     funções, ou outros objectos.  Se um nome não possui valore ou
     função associada a ele, esse nome sem nenhum valor ou função
     associado será ignorado.  `save' retorna <filename>.

     `save' armazena dados na forma de expressões Lisp.  Os dados
     armazenados por `save' podem ser recuperados por `load
     (<filename>)'.

     O sinalizador global `file_output_append' governa se `save' anexa
     ao final ou trunca o ficheiro de saída.  Quando
     `file_output_append' for `true', `save' anexa ao final doficheiro
     de saída.  De outra forma, `save' trunca o ficheiro de saída.
     Nesse caso, `save' cria o ficheiro se ele não existir ainda.

     A forma especial `save (<filename>, values, functions, labels,
     ...)'  armazena os ítens nomeados por `values', `funções',
     `labels', etc.  Os nomes podem ser quaisquer especificados pela
     variável `infolists'.  `values' compreende todas as variáveis
     definidas pelo utilizador.

     A forma especial `save (<filename>, [<m>, <n>])' armazena os
     valores de rótulos de entrada e saída de <m> até <n>.  Note que
     <m> e <n> devem obrigatóriamente ser inteiros literais.  Rótulos
     de entrada e saída podem também ser armazenados um a um, e.g.,
     `save ("foo.1", %i42, %o42)'.  `save (<filename>, labels)'
     armazena todos os rótulos de entrada e saída.  Quando rótulos
     armazenados são recuperados, eles substituem rótulos existentes.

     A forma especial `save (<filename>, <nome_1>=<expr_1>,
     <nome_2>=<expr_2>, ...)' armazena os valores de <expr_1>,
     <expr_2>, ..., com nomes <nome_1>, <nome_2>, ....  Isso é útil
     para aplicar essa forma para rótulos de entrada e saída, e.g.,
     `save ("foo.1", aa=%o88)'.  O lado direito dessa igualdade nessa
     forma pode ser qualquer expressão, que é avaliada.  Essa forma não
     introduz os novos nomes no ambiente corrente do Maxima, mas
     somente armazena-os em <filename>.

     Essa forma especial e a forma geral de `save' podem ser misturados.
     Por exemplo, `save (<filename>, aa, bb, cc=42, funções, [11, 17])'.

     A forma especial `save (<filename>, all)' armazena o estado
     corrente do Maxima.  Isso inclui todas as variáveis definidas pelo
     utilizador, funções, arrays, etc., bem como alguns ítens definidos
     automaticamente.  Os ítes salvos incluem variáveis de sistema,
     tais como `file_search_maxima' ou `showtime', se a elas tiverem
     sido atribuídos novos valores pelo utilizador; veja `myoptions'.

     `save' avalia seus argumentos.  <filename> deve obrigatóriamente
     ser uma sequência de caracteres, não uma variável tipo sequência
     de caracteres.  O primeiro e o último rótulos a salvar, se
     especificado, devem obrigatóriamente serem inteiros.  O operador
     apóstrofo-apóstrofo `''' avalia uma variável tipo sequência de
     caracteres para seu valor sequência de caracteres, e.g., `s:
     "foo.1"$ save (''s, all)$', e variáveis inteiras para seus valores
     inteiros, e.g., `m: 5$ n: 12$ save ("foo.1", [''m, ''n])$'.


 -- Variável de opção: savedef
     Valor por omissão: `true'

     Quando `savedef' é `true', a vesão Maxima de uma função de
     utilizador é preservada quando a função é traduzida.  Isso permite
     que a definição seja mostrada por `dispfun' e autoriza a função a
     ser editada.

     Quando `savedef' é `false', os nomes de funções traduzidas são
     removidos da lista de `funções'.


 -- Função: show (<expr>)
     Mostra `expr' com os objectos indexados tendo índices covariantes
     como subscritos, índices contravariantes como sobrescritos.  Os
     índices derivativos são mostrados como subscritos, separados dos
     índices covariantes por uma vírgula.


 -- Função: showratvars (<expr>)
     Retorna uma lista de variáveis expressão racional canónica (CRE)
     na expressão `expr'.

     Veja também `ratvars'.


 -- Variável de opção: stardisp
     Valor por omissão: `false'

     Quando `stardisp' é `true', multiplicação é mostrada com um
     asterisco `*' entre os operandos.


 -- Função: string (<expr>)
     Converte `expr' para a notação linear do Maxima apenas como se
     tivesse sido digitada.

     O valor de retorno de `string' é uma sequência de caracteres, e
     dessa forma não pode ser usada em um cálculo.


 -- Variãvel de opção: stringdisp
     Valor por omissão: `false'

     Quando `stringdisp' for `true', sequências de caracteres serão
     mostradas contidas em aspas duplas.  De outra forma, aspas não são
     mostradas.

     `stringdisp' é sempre `true' quando mostrando na tela uma
     definição de função.

     Exemplos:

          (%i1) stringdisp: false$
          (%i2) "This is an example string.";
          (%o2)              This is an example string.
          (%i3) foo () := print ("This is a string in a function definition.");
          (%o3) foo() :=
                        print("This is a string in a function definition.")
          (%i4) stringdisp: true$
          (%i5) "This is an example string.";
          (%o5)             "This is an example string."


 -- Função: stringout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Função: stringout (<filename>, [<m>, <n>])
 -- Função: stringout (<filename>, input)
 -- Função: stringout (<filename>, functions)
 -- Função: stringout (<filename>, values)
     `stringout' escreve expressões para um ficheiro na mesma forma de
     expressões que foram digitadas para entrada.  O ficheiro pode
     então ser usado como entrada para comandos `batch' ou `demo', e
     isso pode ser editado para qualquer propósito.  `stringout' pode
     ser executado enquanto `writefile' está em progresso.

     O sinalizador global `file_output_append' governa se `stringout'
     anexa ao final ou trunca o ficheiro de saída.  Quando
     `file_output_append' for `true', `stringout' anexa ao final do
     ficheiro de sad'a.  De outra forma, `stringout' trunca o ficheiro
     de saída.  Nesse caso, `stringout' cria o ficheiro de saída se ele
     não existir ainda.

     A forma geral de `stringout' escreve os valores de um ou mais
     expressões para o ficheiro de saída.  Note que se uma expressão é
     uma variável, somente o valor da variável é escrito e não o nome
     da variável.  Como um útil caso especial, as expressões podem ser
     rótulos de entrada (`%i1', `%i2', `%i3', ...) ou rótulos de saída
     (`%o1', `%o2', `%o3', ...).

     Se `grind' é `true', `stringout' formata a saída usando o formato
     `grind'.  De outra forma o formato `string' é usado.  Veja `grind'
     e `string'.

     A forma especial `stringout (<filename>, [<m>, <n>])' escreve os
     valores dos rótulos de entrada de m até n, inclusive.

     A forma especial `stringout (<filename>, input)' escreve todos os
     rótulos de entrada para o ficheiro.

     A forma especial `stringout (<filename>, functions)' escreve todas
     as funções definidas pelo utilizador (nomeadas pela lista global
     `functions') para o ficheiro.

     A forma especial `stringout (<filename>, values)' escreve todas as
     variáveis atribuídas pelo utilizador (nomeadas pela lista global
     `values') para o ficheiro.  Cada variável é impressa como uma
     declaração de atribuição, com o nome da variável seguida de dois
     pontos, e seu valor.  Note que a forma geral de `stringout' não
     imprime variáveis como declarações de atribuição.


 -- Função: tex (<expr>)
 -- Função: tex (<rótulo>)
 -- Função: tex (<expr>, <momeficheiro>)
 -- Função: tex (<label>, <nomeficheiro>)
     Imprime uma representação de uma expressão adequada para o sistema
     TeX  de preparação de documento.  O resultado é um fragmento de um
     documento, que pode ser copiado dentro de um documento maior.
     Esse fragmento não pode ser processado de forma directa e isolada.

     `tex (<expr>)' imprime uma representação TeX da <expr> no console.

     `tex (<rótulo>)' imprime uma representação TeX de uma expressão
     chamada <rótulo> e atribui a essa um rótulo de equação (a ser
     mostrado à esquerda da expressão).  O rótulo de equação TeX é o
     mesmo que o rótulo da equação no Maxima.

     `tex (<expr>, <nomeficheiro>)' anexa ao final uma representação
     TeX de <expr> no ficheiro <nomeficheiro>.  `tex' não avalia o
     argumento <nomeficheiro>; apóstrofo-apóstrofo `''' força a
     avaliação so argumento.

     `tex (<rótulo>, <nomeficheiro>)' anexa ao final uma representação
     TeX da expressão chamada de <rótulo>, com um rótulo de equação, ao
     ficheiro <nomeficheiro>.

     `tex' não avalia o argumento <nomeficheiro>; apóstrofo-apóstrofo
     `''' força a avaliação so argumento.  `tex' avalia seus argumentos
     após testar esse argumento para ver se é um rótulo.  duplo
     apóstrofo `''' força a avaliação do argumento, desse modo
     frustrando o teste e prevenindo o rótulo.

     Veja também `texput'.

     Exemplos:

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)


 -- Função: texput (<a>, <s>)
 -- Função: texput (<a>, <s>, <operator_type>)
 -- Função: texput (<a>, [<s_1>, <s_2>], matchfix)
 -- Função: texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)
     Atribui a saída TeX para o átomo <a>, que pode ser um símbolo ou o
     nome de um operador.

     `texput (<a>, <s>)' faz com que a função `tex' interpole a
     sequência de caracteres <s> dentro da saída TeX em lugar de <a>.

     `texput (<a>, <s>, <operator_type>)', onde <operator_type> é
     `prefix', `infix', `postfix', `nary', ou `nofix', faz com que a
     função `tex' interpole <s> dentro da saída TeX em lugar de <a>, e
     coloca o texto interpolado na posição apropriada.

     `texput (<a>, [<s_1>, <s_2>], matchfix)' faz com que a função
     `tex' interpole <s_1> e <s_2> dentro da saída TeX sobre qualquer
     lado dos argumentos de <a>.  Os argumentos (se mais de um) são
     separados por vírgulas.

     `texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)' faz com que a
     função `tex' interpole <s_1> e <s_2> dentro da saída TeX sobre
     qualquer lado dos argumentos de <a>, com <s_3> separando os
     argumentos.

     Exemplos:

     Atribui saída TeX a uma variável.

          (%i1) texput (me,"\\mu_e");
          (%o1)                         \mu_e
          (%i2) tex (me);
          $$\mu_e$$
          (%o2)                         false

     Atribui saída TeX a uma função comum (não a um operador).

          (%i1) texput (lcm, "\\mathrm{lcm}");
          (%o1)                     \mathrm{lcm}
          (%i2) tex (lcm (a, b));
          $$\mathrm{lcm}\left(a , b\right)$$
          (%o2)                         false

     Atribui saída TeX a um operador prefixado.

          (%i1) prefix ("grad");
          (%o1)                         grad
          (%i2) texput ("grad", " \\nabla ", prefix);
          (%o2)                        \nabla
          (%i3) tex (grad f);
          $$ \nabla f$$
          (%o3)                         false

     Atribui saída TeX a um operador infixado.

          (%i1) infix ("~");
          (%o1)                           ~
          (%i2) texput ("~", " \\times ", infix);
          (%o2)                        \times
          (%i3) tex (a ~ b);
          $$a \times b$$
          (%o3)                         false

     Atribui saída TeX a um operadro pósfixado.

          (%i1) postfix ("##");
          (%o1)                          ##
          (%i2) texput ("##", "!!", postfix);
          (%o2)                          !!
          (%i3) tex (x ##);
          $$x!!$$
          (%o3)                         false

     Atribui saída TeX a um operador n-ário.

          (%i1) nary ("@@");
          (%o1)                          @@
          (%i2) texput ("@@", " \\circ ", nary);
          (%o2)                         \circ
          (%i3) tex (a @@ b @@ c @@ d);
          $$a \circ b \circ c \circ d$$
          (%o3)                         false

     Atribui saída TeX a um operador nofix.

          (%i1) nofix ("foo");
          (%o1)                          foo
          (%i2) texput ("foo", "\\mathsc{foo}", nofix);
          (%o2)                     \mathsc{foo}
          (%i3) tex (foo);
          $$\mathsc{foo}$$
          (%o3)                         false

     Atribui saída TeX a um operadro matchfix.

          (%i1) matchfix ("<<", ">>");
          (%o1)                          <<
          (%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
          (%o2)                [ \langle ,  \rangle ]
          (%i3) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o3)                         false
          (%i4) tex (<<a, b>>);
          $$ \langle a , b \rangle $$
          (%o4)                         false
          (%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"], matchfix);
          (%o5)           [ \langle ,  \rangle ,  \, | \,]
          (%i6) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o6)                         false
          (%i7) tex (<<a, b>>);
          $$ \langle a \, | \,b \rangle $$
          (%o7)                         false


 -- Função: system (<comando>)
     Executa <comando> como um processo separado.  O comando é passado
     ao shell padraõ para execução.  `system' não é suportado por todos
     os sistemas operacionais, mas geralmente existe em ambientes Unix
     e Unix-like.

     Supondo que `_hist.out' é uma lista de frequências que deseja
     imprimir como um gráfico em barras usando `xgraph'.

          (%i1) (with_stdout("_hist.out",
                     for i:1 thru length(hist) do (
                       print(i,hist[i]))),
                 system("xgraph -bar -brw .7 -nl < _hist.out"));

     Com o objectivo de fazer com que a impressão do gráfico seja
     concluída em segundo plano (retornando o controle para o Maxima) e
     remover o ficheiro temporário após isso ter sido concluído faça:

          system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")


 -- Variável de opção: ttyoff
     Valor por omissão: `false'

     Quando `ttyoff' é `true', expressões de saída não são mostradas.
     Expressões de saída são ainda calculadas e atribuídas rótulos.
     Veja `labels'.

     Textos impresso por funções internas do Maxima, tais como
     mensagens de erro e a saída de `describe', não são afectadas por
     `ttyoff'.


 -- Função: with_stdout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
     Abre <filename> e então avalia <expr_1>, <expr_2>, <expr_3>, ....
     Os valores dos argumentos não são armazenados em <filename>, mas
     qualquer saída impressa gerada pela avaliação dos argumentos (de
     `print', `display', `disp', ou `grind', por exemplo) vai para
     <filename> em lugar do console.

     O sinalizador global `file_output_append' governa se `with_stdout'
     anexa ao final ou trunca o ficheiro de saída.  Quando
     `file_output_append' for `true', `with_stdout' anexa ao final do
     ficheiro de saída.  De outra forma, `with_stdout' trunca o
     ficheiro de saída.  Nesse caso, `with_stdout' cria o ficheiro se
     ele não existir ainda.

     `with_stdout' retorna o valor do seu argumento final.

     Veja também `writefile'.

          (%i1) with_stdout ("tmp.out", for i:5 thru 10 do print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800


 -- Função: writefile (<filename>)
     Começa escrevendo uma transcrição da sessão Maxima para <filename>.
     Toda interação entre o utilizador e Maxima é então gravada nesse
     ficheiro, da mesma forma que aparece no console.

     Como a transcrição é impressa no formato de saída do console, isso
     não pode ser reaproveitado pelo Maxima.  Para fazer um ficheiro
     contendo expressões que podem ser reaproveitadas, veja `save' e
     `stringout'.  `save' armazena expressões no formato Lisp, enquanto
     `stringout' armazena expressões no formato Maxima.

     O efeito de executar `writefile' quando <filename> ainda existe
     depende da implementação Lisp subjacente; o ficheiro transcrito
     pode ser substituído, ou o ficheiro pode receber um anexo.
     `appendfile' sempre anexa para o ficheiro transcrito.

     Isso pode ser conveniente para executar `playback' após
     `writefile' para salvar a visualização de interações prévias.
     Como `playback' mostra somente as variáveis de entrada e saída
     (`%i1', `%o1', etc.), qualquer saída gerada por uma declaração de
     impressão em uma função (como oposição a um valor de retorno) não
     é mostrada por `playback'.

     `closefile' fecha o ficheiro transcrito aberto por `writefile' ou
     `appendfile'.



File: maxima.info,  Node: Ponto Flutuante,  Next: Contextos,  Prev: Entrada e Saída,  Up: Top

10 Ponto Flutuante
******************

* Menu:

* Definições para ponto Flutuante::


File: maxima.info,  Node: Definições para ponto Flutuante,  Prev: Ponto Flutuante,  Up: Ponto Flutuante

10.1 Definições para ponto Flutuante
====================================

 -- Função: bffac (<expr>, <n>)
     Versão para grandes números em ponto flutuante da função
     `factorial' (usa o artifício gamma).  O segundo argumento informa
     quantos dígitos reter e retornar, isso é uma boa idéia para
     requisitar precisão adicional.

     `load ("bffac")' chama essa função.


 -- Variável de Opção: algepsilon
     Valor por omissão: 10^8

     `algepsilon' é usada por `algsys'.


 -- Função: bfloat (<expr>)
     Converte todos os números e funções de números em <expr> para
     grandes números em ponto flutuante (bigfloat).  O número de
     algarismos significativos no grande número em ponto flutuante
     resultante é especificado através da variável global `fpprec'.

     Quando `float2bf' for `false' uma mensagem de alerta é mostrada
     quando uma número em ponto flutuante (float) é convertido em um
     grande número em ponto flutuante (bigfloat - uma vez que isso pode
     resultar em perda de precisão).


 -- Função: bfloatp (<expr>)
     Retorna `true' se a avaliação da <expr> resultar em um grande
     número em ponto flutuante, de outra forma retorna `false'.


 -- Função: bfpsi (<n>, <z>, <fpprec>)
 -- Função: bfpsi0 (<z>, <fpprec>)
     `bfpsi' é a função `polygamma' de argumentos reais <z> e ordem de
     inteiro <n>.  `bfpsi0' é a função `digamma'.  `bfpsi0 (<z>,
     <fpprec>)' é equivalente a `bfpsi (0, <z>, <fpprec>)'.

     Essas funções retornam valores em grandes números em ponto
     flutuante.  <fpprec> é a precisão do valor de retorno dos grandes
     números em ponto flutuante.

     `load ("bffac")' chama essas funções.


 -- Variável de Opção: bftorat
     Valor por omissão: `false'

     `bftorat' controla a conversão de `bfloats' para números racionais.
     Quando `bftorat' for `false', `ratepsilon' será usada para
     controlar a conversão (isso resulta em números racionais
     relativametne pequenos).  Quando `bftorat' for `true', o número
     racional gerado irá representar precisamente o `bfloat'.


 -- Variável de Opção: bftrunc
     Valor por omissão: `true'

     `bftrunc' faz com que tilhas de zeros em grandes números em ponto
     flutuante diferentes de zero sejam ocultadas.  Desse modo, se
     `bftrunc' for `false', `bfloat (1)' será mostrado como
     `1.000000000000000B0'. De outra forma, será mostrado como `1.0B0'.


 -- Função: cbffac (<z>, <fpprec>)
     Factorial complexo de grandes números em ponto flutuante.

     `load ("bffac")' chama essa função.


 -- Função: float (<expr>)
     Converte inteiros, números racionais e grandes números em ponto
     flutuante em <expr> para números em ponto flutuante.  Da mesma
     forma um `evflag', `float' faz com que números racionais
     não-inteiros e grandes números em ponto flutuante sejam
     convertidos para ponto flutuante.


 -- Variável de Opção: float2bf
     Valor por omissão: `false'

     Quando `float2bf' for `false', uma mensagem de alerta é mostrada
     quando um número em ponto flutuante é convertido em um grande
     número em ponto flutuante (uma vez que isso pode resultar em perda
     de precisão).


 -- Função: floatnump (<expr>)
     Retorna `true' se <expr> for um número em ponto flutuante, de
     outra forma retorna `false'.


 -- Variável de Opção: fpprec
     Valor por omissão: 16

     `fpprec' é o número de algarismos significativos para aritmética
     sobre grandes números em ponto flutuante `fpprec' não afecta
     cálculos sobre números em ponto flutuante comuns.

     Veja também `bfloat' e `fpprintprec'.


 -- Variável de Opção: fpprintprec
     Valor por omissão: 0

     `fpprintprec' é o n;umero de dígitos a serem mostrados na tela
     quando no caso de nuúmeros em ponto flutuante e no caso de grandes
     números em ponto flutuante.

     Para números em ponto flutuante comuns, quando `fpprintprec' tiver
     um valor entre 2 e 16  (inclusive), o n;umero de dígitos mostrado
     na tela é igual a `fpprintprec'.  De outra forma, `fpprintprec' é
     0, ou maior que 16, e o número de dígitos mostrados é 16.

     Para grandes números em ponto flutuante, quando `fpprintprec'
     tiver um valor entre 2 e `fpprec' (inclusive), o n;umero de
     dígitos mostrados é giaul a `fpprintprec'.  De outra forma,
     `fpprintprec' é 0, ou maior que `fpprec', e o n;umero de dígitos
     mostrados é igual a `fpprec'.

     `fpprintprec' não pode ser 1.



File: maxima.info,  Node: Contextos,  Next: Polinómios,  Prev: Ponto Flutuante,  Up: Top

11 Contextos
************

* Menu:

* Definições para Contextos::


File: maxima.info,  Node: Definições para Contextos,  Prev: Contextos,  Up: Contextos

11.1 Definições para Contextos
==============================

 -- Função: activate (<context_1>, ..., <context_n>)
     Ativa os contextos <context_1>, ..., <context_n>.  Os factos
     nesses contextos estão então disponíveis para fazer deduções e
     recuperar informação.  Os factos nesses contextos não são listadas
     através de `facts ()'.

     A variável `activecontexts' é a lista de contextos que estão
     activos pelo caminho da função `activate'.


 -- Variável de sistema: activecontexts
     Valor por omissão: `[]'

     `activecontexts' é a lista de contextos que estão activos pelo
     caminho da função `activate', em oposição a sendo activo porque
     eles são subcontextos do contexto corrente.


 -- Função: assume (<pred_1>, ..., <pred_n>)
     Adiciona predicados <pred_1>, ..., <pred_n> ao contexto corrente.
     Se um predicado for incossistente ou redundante com os predicados
     no contexto corrente, esses predicados não são adicionados ao
     contexto.  O contexto acumula predicados de cada chamada a
     `assume'.

     `assume' retorna uma lista cujos elementos são os predicados
     adicionados ao contexto ou os átomos `redundant' ou `inconsistent'
     onde for aplicável.

     Os predicados <pred_1>, ..., <pred_n> podem somente ser expressões
     com os operadores relacionais `< <= equal notequal >=' e `>'.
     Predicados não podem ser expressões de igualdades literais `=' ou
     expressões de desigualdades literais `#', nem podem elas serem
     funções de predicado tais como `integerp'.

     Predicados combinados da forma `<pred_1> and ... and <pred_n>' são
     reconhecidos, mas não `<pred_1> or ... or <pred_n>'.  `not
     <pred_k>' é reconhecidos se <pred_k> for um predicado relacional.
     Expressões da forma `not (<pred_1> e <pred_2>)' and `not (<pred_1>
     or <pred_2>)' não são reconhecidas.

     O mecanismo de dedução do Maxima não é muito forte; exitem
     consequências muito óbvias as quais não podem ser determinadas por
     meio de `is'.  Isso é uma fraqueza conhecida.

     `assume' avalia seus argumentos.

     Veja também `is', `facts', `forget', `context', e `declare'.

     Exemplos:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown


 -- Variável de opção: assumescalar
     Valor por omissão: `true'

     `assumescalar' ajuda a governar se expressões `expr' para as quais
     `nonscalarp (expr)' for `false' são assumidas comportar-se como
     escalares para certas transformações.

     Tomemos `expr' representando qualquer expressão outra que não uma
     lista ou uma matriz, e tomemos `[1, 2, 3]' representando qualquer
     lista ou matriz.  Então `expr . [1, 2, 3]' retorna `[expr, 2 expr,
     3 expr]' se `assumescalar' for `true', ou `scalarp (expr)' for
     `true', ou `constantp (expr)' for `true'.

     Se `assumescalar' for `true', tais expressões irão comportar-se
     como escalares somente para operadores comutativos, mas não para
     multiplicação não comutativa `.'.

     Quando `assumescalar' for `false', tais expressões irão
     comportar-se como não escalares.

     Quando `assumescalar' for `all', tais expressões irão comportar-se
     como escalares para todos os operadores listados acima.


 -- Variável de opção: assume_pos
     Valor por omissão: `false'

     Quando `assume_pos' for `true' e o sinal de um parâmetro <x> não
     pode ser determinado a partir do contexto corrente ou outras
     considerações, `sign' e `asksign (<x>)' retornam `true'.  Isso
     pode impedir algum questionamento de `asksign' gerado
     automaticamente, tal como pode surgir de `integrate' ou de outros
     cálculos.

     Por padrão, um parâmetro é <x> tal como `symbolp (<x>)' or
     `subvarp (<x>)'.  A classe de expressões consideradas parâmetros
     pode ser modificada para alguma abrangência através da variável
     `assume_pos_pred'.

     `sign' e `asksign' tentam deduzir o sinal de expressões a partir
     de sinais de operandos dentro da expressão.  Por exemplo, se `a' e
     `b' são ambos positivos, então `a + b' é também positivo.

     Todavia, não existe caminho para desviar todos os questionamentos
     de `asksign'.  Particularmente, quando o argumento de `asksign'
     for uma diferença `<x> - <y>' ou um logaritmo `log(<x>)',
     `asksign' sempre solicita uma entrada ao utilizador, mesmo quando
     `assume_pos' for `true' e `assume_pos_pred' for uma função que
     retorna `true' para todos os argumentos.


 -- Variável de opção: assume_pos_pred
     Valor por omissão: `false'

     Quando `assume_pos_pred' for atribuído o nome de uma função ou uma
     expressão lambda de um argumento <x>, aquela função é chamada para
     determinar se <x> é considerado um parâmetro para o propósito de
     `assume_pos'.  `assume_pos_pred' é ignorado quando `assume_pos'
     for `false'.

     A função `assume_pos_pred' é chamada através de `sign' e de
     `asksign' com um argumento <x> que é ou um átomo, uma variável
     subscrita, ou uma expressão de chamada de função.  Se a função
     `assume_pos_pred' retorna `true', <x> é considerado um parâmetro
     para o propósito de `assume_pos'.

     Por padrão, um parâmetro é <x> tal que `symbolp (x)' ou `subvarp
     (x)'.

     Veja também `assume' e `assume_pos'.

     Exemplos:

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz
          (%i5) assume_pos_pred: lambda ([x], display (x), true)$
          (%i6) asksign (a);
                                        x = a

          (%o6)                          pos
          (%i7) asksign (a[1]);
                                       x = a
                                            1

          (%o7)                          pos
          (%i8) asksign (foo (a));
                                     x = foo(a)

          (%o8)                          pos
          (%i9) asksign (foo (a) + bar (b));
                                     x = foo(a)

                                     x = bar(b)

          (%o9)                          pos
          (%i10) asksign (log (a));
                                        x = a

          Is  a - 1  positive, negative, or zero?

          p;
          (%o10)                         pos
          (%i11) asksign (a - b);
                                        x = a

                                        x = b

                                        x = a

                                        x = b

          Is  b - a  positive, negative, or zero?

          p;
          (%o11)                         neg


 -- Variável de opção: context
     Valor por omissão: `initial'

     `context' nomeia a colecção de factos mantida através de `assume'
     e `forget'.  `assume' adiciona factos à colecção nomeada através
     de `context', enquanto `forget' remove factos.

     Associando `context' para um nome <foo> altera o contexto corrente
     para <foo>.  Se o contexto especificado <foo> não existe ainda,
     ele é criado automaticamente através de uma chamada a `newcontext'.
     O contexto especificado é activado automaticamente.

     Veja `contexts' para uma descrição geral do mecanismo de contexto.


 -- Variável de opção: contexts
     Valor por omissão: `[initial, global]'

     `contexts' é uma lista dos contextos que existem actualmente,
     incluindo o contexto activo actualmente.

     O mecanismo de contexto torna possível para um utilizador associar
     e nomear uma porção seleccionada de factos, chamada um contexto.
     Assim que isso for concluído, o utilizador pode ter o Maxima
     assumindo ou esquecendo grande quantidade de factos meramente
     através da activação ou desativação seu contexto.

     Qualquer átomo simbólico pode ser um contexto, e os factos
     contidos naquele contexto irão ser retidos em armazenamento até
     que sejam destruídos um por um através de chamadas a `forget' ou
     destruídos com um conjunto através de uma chamada a `kill' para
     destruir o contexto que eles pertencem.

     Contextos existem em uma hierarquía, com o raíz sempre sendo o
     contexto `global', que contém informações sobre Maxima que alguma
     função precisa.  Quando em um contexto dado, todos os factos
     naquele contexto estão "ativos" (significando que eles são usados
     em deduções e recuperados) como estão também todos os factos em
     qualquer contexto que for um subcontexto do contexto activo.

     Quando um novo Maxima for iniciado, o utilizador está em um
     contexto chamado `initial', que tem `global' como um subcontexto.

     Veja também `facts', `newcontext', `supcontext', `killcontext',
     `activate', `deactivate', `assume', e `forget'.


 -- Função: deactivate (<context_1>, ..., <context_n>)
     Desativa os contextos especificados <context_1>, ..., <context_n>.


 -- Função: facts (<item>)
 -- Função: facts ()
     Se <item> for o nome de um contexto, `facts (<item>)' retorna uma
     lista de factos no contexto especificado.

     Se <item> não for o nome de um contexto, `facts (<item>)' retorna
     uma lista de factos conhecidos sobre <item> no contexto actual.
     Fatos que estão atuvos, mas em um diferente contexto, não são
     listados.

     `facts ()' (i.e., sem argumento) lista o contexto actual.


 -- Declaração: features
     Maxima recnhece ceertas propriedades matemáticas de funções e
     variáveis.  Essas são chamadas "recursos".

     `declare (<x>, <foo>)' fornece a propriedade <foo> para a
     função ou variável <x>.

     `declare (<foo>, recurso)' declara um novo recurso <foo>.  Por
     exemplo, `declare ([red, green, blue], feature)' declara três
     novos recursos, `red', `green', e `blue'.

     O predicado `featurep (<x>, <foo>)' retorna `true' se <x> possui a
     propriedade <foo>, e `false' de outra forma.

     A infolista `features' é uma lista de recursos conhecidos.  São
     esses `integer', `noninteger', `even', `odd', `rational',
     `irrational', `real', `imaginary', `complex', `analytic',
     `increasing', `decreasing', `oddfun', `evenfun', `posfun',
     `commutative', `lassociative', `rassociative', `symmetric', e
     `antisymmetric', mais quaisquer recursos definidos pelo utilizador.

     `features' é uma lista de recursos matemáticos.  Existe também uma
     lista de recursos não matemáticos, recursos dependentes do
     sistema. Veja `status'.


 -- Função: forget (<pred_1>, ..., <pred_n>)
 -- Função: forget (<L>)
     Remove predicados estabelecidos através de `assume'.  Os
     predicados podem ser expressões equivalentes a (mas não
     necessáriamente idênticas a) esses prevamentes assumidos.

     `forget (<L>)', onde <L> é uma lista de predicados, esquece cada
     item da lista.


 -- Função: killcontext (<context_1>, ..., <context_n>)
     Mata os contextos <context_1>, ..., <context_n>.

     Se um dos contextos estiver for o contexto actual, o novo contexto
     actual irá tornar-se o primeiro subcontexto disponível do contexto
     actual que não tiver sido morto.  Se o primeiro contexto disponível
     não morto for `global' então `initial' é usado em seu lugar.  Se o
     contexto `initial' for morto, um novo, porém vazio contexto
     `initial' é criado.

     `killcontext' recusa-se a matar um contexto que estiver ativo
     actualmente, ou porque ele é um subcontexto do contexto actual, ou
     através do uso da função `activate'.

     `killcontext' avalia seus argumentos.  `killcontext' retorna
     `done'.


 -- Função: newcontext (<nome>)
     Cria um novo contexto, porém vazio, chamado <nome>, que tem
     `global' como seu único subcontexto.  O contexto recentemente
     criado torna-se o contexto activo actualmente.

     `newcontext' avalia seu argumento.  `newcontext' retorna <nome>.


 -- Função: supcontext (<nome>, <context>)
 -- Função: supcontext (<nome>)
     Cria um novo contexto, chamado <nome>, que tem <context> como um
     subcontexto.  <context> deve existir.

     Se <context> não for especificado, o contexto actual é assumido.



File: maxima.info,  Node: Polinómios,  Next: Constantes,  Prev: Contextos,  Up: Top

12 Polinómios
*************

* Menu:

* Introdução a Polinómios::
* Definições para Polinómios::


File: maxima.info,  Node: Introdução a Polinómios,  Next: Definições para Polinómios,  Prev: Polinómios,  Up: Polinómios

12.1 Introdução a Polinómios
============================

Polinómios são armazenados no Maxima ou na forma geral ou na forma de
Expressões Racionais Canónicas (CRE).  Essa última é uma forma padrão,
e é usada internamente por operações tais como `factor', `ratsimp', e
assim por diante.

   Expressões Racionais Canónicas constituem um tipo de
representação que é especialmente adequado para polinómios expandidos e
funções racionais (também para polinómios parcialmente factorizados e
funções racionais quando RATFAC for escolhida para `true').  Nessa
forma CRE uma ordenação de variáveis (da mais para a menos importante)
é assumida para cada expressão.  Polinómios são representados
recursivamente por uma lista consistindo da variável principal seguida
por uma série de pares de expressões, uma para cada termo do polinómio.
O primeiro membro de cada par é o expoente da variável principal
naquele termo e o segundo membro é o coeficiente daquele termo que pode
ser um número ou um polinómio em outra variável novamente respresentado
nessa forma.  Sendo assim a parte principal da forma CRE de 3*X^2-1 é
(X 2 3 0 -1) e que a parte principal da forma CRE de 2*X*Y+X-3 é (Y 1
(X 1 2) 0 (X 1 1 0 -3)) assumindo Y como sendo a variável principal, e
é (X 1 (Y 1 2 0 1) 0 -3) assumindo X como sendo a variável principal. A
variável principal é usualmente determineda pela ordem alfabética
reversa.  As "variáveis" de uma expressão CRE não necessariamente devem
ser atômicas.  De facto qualquer subexpressão cujo principal operador
não for + - * / or ^ com expoente inteiro será considerado uma
"variável" da expressão (na forma CRE) na qual essa ocorrer.  Por
exemplo as variáveis CRE da expressão X+SIN(X+1)+2*SQRT(X)+1 são X,
SQRT(X), e SIN(X+1).  Se o utilizador não especifica uma ordem de
variáveis pelo uso da função RATVARS Maxima escolherá a alfabética por
conta própria.  Em geral, CREs representam expressões racionais, isto
é, razões de polinómios, onde o numerador e o denominador não possuem
factores comuns, e o denominador for positivo.  A forma interna é
essencialmente um par de polinómios (o numerador e o denominador)
precedidos pela lista de ordenação de variável.  Se uma expressão a ser
mostrada estiver na forma CRE ou se contiver quaisquer subexpressões na
forma CRE, o símbolo /R/ seguirá o rótulo da linha.  Veja a função RAT
para saber como converter uma expressão para a forma CRE.  Uma forma
CRE extendida é usada para a representação de séries de Taylor.  A
noção de uma expressão racional é extendida de modo que os expoentes das
variáveis podem ser números racionais positivos ou negativos em lugar
de apenas inteiros positivos e os coeficientes podem eles mesmos serem
expressões racionais como descrito acima em lugar de apenas polinómios.
Estes são representados internamente por uma forma polinomial
recursiva que é similar à forma CRE e é a generalização dessa mesma
forma CRE, mas carrega informação adicional tal com o grau de
truncação.  Do mesmo modo que na forma CRE, o símbolo /T/ segue o
rótulo de linha que contém as tais expressões.


File: maxima.info,  Node: Definições para Polinómios,  Prev: Introdução a Polinómios,  Up: Polinómios

12.2 Definições para Polinómios
===============================

 -- Variável de opção: algebraic
     Valor Padrão: `false'

     `algebraic' deve ser escolhida para `true' com o objectivo de que a
     simplificação de inteiros algébricos tenha efeito.


 -- Variável de opção: berlefact
     Valor Padrão: `true'

     Quando `berlefact' for `false' então o algoritmo de
     factorização de Kronecker será usado.  De outra forma o algoritmo
     de Berlekamp, que é o padrão, será usado.


 -- Função: bezout (<p1>, <p2>, <x>)
     uma alternativa para o comando `resultant'.  Isso retorna uma
     matriz.  `determinant' dessa matriz é o resultante desejado.


 -- Função: bothcoef (<expr>, <x>)
     Retorna uma lista da qual o primeiro membro é o coeficiente de <x>
     em <expr> (como achado por `ratcoef' se <expr> está na forma CRE
     de outro modo por `coeff') e cujo segundo membro é a parte
     restante de <expr>.  Isto é, `[A, B]' onde `<expr> = A*<x> + B'.

     Exemplo:

          (%i1) islinear (expr, x) := block ([c],
                  c: bothcoef (rat (expr, x), x),
                  é (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true


 -- Função: coeff (<expr>, <x>, <n>)
     Retorna o coeficiente de `<x>^<n>' em <expr>.  <n> pode ser
     omitido se for 1.  <x> pode ser um átomo, ou subexpressão completa
     de <expr> e.g., `sin(x)', `a[i+1]', `x + y', etc. (No último caso a
     expressão `(x + y)' pode ocorrer em <expr>).  Algumas vezes isso
     pode ser necessário para expandir ou factorizar <expr> com o
     objectivo de fazer `<x>^<n>' explicito.  Isso não é realizado por
     `coeff'.

     Exemplos:

          (%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
          (%o1)                      2 a + 1 = 5
          (%i2) coeff (y + x*%e^x + 1, x, 0);
          (%o2)                         y + 1


 -- Função: combine (<expr>)
     Simplifica a adição <expr> por termos combinados com o mesmo
     denominador dentro de um termo simples.


 -- Função: content (<p_1>, <x_1>, ..., <x_n>)
     Retorna uma lista cujo primeiro elemento é o máximo divisor comum
     dos coeficientes dos termos do polinómio <p_1> na variável <x_n>
     (isso é o conteúdo) e cujo segundo elemento é o polinómio <p_1>
     dividido pelo conteúdo.

     Exemplos:

          (%i1) content (2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]


 -- Função: denom (<expr>)
     Retorna o denominador da expressão racional <expr>.


 -- Função: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     calcula o quocietne e o resto do polinómio <p_1> dividido pelo
     polinómio <p_2>, na variável principal do polinómio, <x_n>.  As
     outras variáveis são como na função `ratvars'.  O resultado é uma
     lista cujo primeiro elemento é o quociente e cujo segundo elemento
     é o resto.

     Exemplos:

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Note que `y' é a variável principal no segundo exemplo.


 -- Função: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])
     Elimina variáveis de equações (ou expressões assumidas iguais a
     zero) obtendo resultantes sucessivos. Isso retorna uma lista de
     `<n> - <k>' expressões com <k> variáveis <x_1>, ..., <x_k>
     eliminadas.  Primeiro <x_1> é eliminado retornando `<n> - 1'
     expressões, então `x_2' é eliminado, etc.  Se `<k> = <n>' então
     uma expressão simples em uma lista é retornada livre das variáveis
     <x_1>, ..., <x_k>.  Nesse caso `solve' é chamado para resolver a
     última resultante para a última variável.

     Exemplo:

          (%i1) expr1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) expr2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) expr3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate ([expr3, expr2, expr1], [y, z]);
                       8         7         6          5          4
          (%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                              3         2
                                      - 5154 x  - 1291 x  + 7688 x + 15376]


 -- Função: ezgcd (<p_1>, <p_2>, <p_3>, ...)
     Retorna uma lista cujo primeiro elemento é o m.d.c. dos polinómios
     <p_1>, <p_2>, <p_3>, ...  e cujos restantes elementos são os
     polinómios divididos pelo mdc.  Isso sempre usa o algoritmo
     `ezgcd'.


 -- Variável de opção: facexpand
     Valor Padrão: `true'

     `facexpand' controla se os factores irredutíveis retornados por
     `factor' estão na forma expandida (o padrão) ou na forma recursiva
     (CRE normal).


 -- Função: factcomb (<expr>)
     Tenta combinar os coeficientes de factoriais em <expr> com os
     próprios factoriais convertendo, por exemplo, `(n + 1)*n!' em `(n
     + 1)!'.

     `sumsplitfact' se escolhida para `false' fará com que
     `minfactorial' seja aplicado após um `factcomb'.


 -- Função: factor (<expr>)
 -- Função: factor (<expr>, <p>)
     Factoriza a expressão <expr>, contendo qualquer número de
     variáveis ou funções, em factores irredutíveis sobre os inteiros.
     `factor (<expr>, <p>)' factoriza <expr> sobre o campo dos inteiros
     com um elemento adjunto cujo menor polinómio é <p>.

     `factor' usa a função `ifactors' para factorizar inteiros.

     `factorflag' se `false' suprime a factorização de factores inteiros
     de expressões racionais.

     `dontfactor' pode ser escolhida para uma lista de variáveis com
     relação à qual factorização não é para ocorrer.  (Essa é
     inicialmente vazia).  Factorização também não acontece com
     relação a quaisquer variáveis que são menos importantes (usando a
     ordenação de variável assumida pela forma CRE) como essas na lista
     `dontfactor'.

     `savefactors' se `true' faz com que os factores de uma expressão
     que é um produto de factores seja guardada por certas funções com
     o objectivo de aumentar a velocidade de futuras factorizações de
     expressões contendo alguns dos mesmos factores.

     `berlefact' se `false' então o algoritmo de factorização de
     Kronecker será usado de outra forma o algoritmo de Berlekamp, que
     é o padrão, será usado.

     `intfaclim' se `true' maxima irá interromper a factorização de
     inteiros se nenhum factor for encontrado após tentar divisões e o
     método rho de Pollard.  Se escolhida para `false' (esse é o caso
     quando o utilizador chama `factor' explicitamente), a
     factorização completa do inteiro será tentada.  A escolha do
     utilizador para `intfaclim' é usada para chamadas internas a
     `factor'. Dessa forma, `intfaclim' pode ser resetada para evitar
     que o Maxima gaste um tempo muito longo factorizando inteiros
     grandes.

     Exemplos:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)


 -- Variável de opção: factorflag
     Valor Padrão: `false'

     Quando `factorflag' for `false', suprime a factorização de
     factores inteiros em expressões racionais.


 -- Função: factorout (<expr>, <x_1>, <x_2>, ...)
     Rearranja a adição <expr> em uma adição de parcelas da forma `f
     (<x_1>, <x_2>, ...)*g' onde `g' é um produto de expressões que não
     possuem qualquer <x_i> e `f' é factorizado.


 -- Função: factorsum (<expr>)
     Tenta agrupar parcelas em factores de <expr> que são adições em
     grupos de parcelas tais que sua adição é factorável.  `factorsum'
     pode recuperar o resultado de `expand ((x + y)^2 + (z + w)^2)' mas
     não pode recuperar `expand ((x + 1)^2 + (x + y)^2)' porque os
     termos possuem variáveis em comum.

     Exemplo:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum (%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )


 -- Função: fasttimes (<p_1>, <p_2>)
     Retorna o produto dos polinómios <p_1> e <p_2> usando um algoritmo
     especial para a multiplicação de polinómios.  `p_1' e `p_2' podem
     ser de várias variáveis, densos, e aproximadamente do mesmo
     tamanho.  A multiplicação clássica é de ordem `n_1 n_2' onde `n_1'
     é o grau de `p_1' and `n_2' é o grau de `p_2'.  `fasttimes' é da
     ordem `max (n_1, n_2)^1.585'.


 -- Função: fullratsimp (<expr>)
     `fullratsimp' aplica repetidamente `ratsimp' seguido por
     simplificação não racional a uma expressão até que nenhuma
     mudança adicional ocorra, e retorna o resultado.

     Quando expressões não racionais estão envolvidas, uma chamada a
     `ratsimp' seguida como é usual por uma simplificação não racional
     ("geral") pode não ser suficiente para retornar um resultado
     simplificado.  Algumas vezes, mais que uma tal chamada pode ser
     necessária.  `fullratsimp' faz esse processo convenientemente.

     `fullratsimp (<expr>, <x_1>, ..., <x_n>)' aceita um ou mais
     argumentos similar a `ratsimp' e `rat'.

     Exemplo:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1


 -- Função: fullratsubst (<a>, <b>, <c>)
     é o mesmo que `ratsubst' excepto que essa chama a si mesma
     recursivamente sobre esse resultado até que o resultado para de
     mudar.  Essa função é útil quando a expressão de substituição e a
     expressão substituída tenham uma ou mais variáveis em comum.

     `fullratsubst' irá também aceitar seus argumentos no formato de
     `lratsubst'.  Isto é, o primeiro argumento pode ser uma
     substituição simples de equação ou uma lista de tais equações,
     enquanto o segundo argumento é a expressão sendo processada.

     `load ("lrats")' chama `fullratsubst' e `lratsubst'.

     Exemplos:

          (%i1) load ("lrats")$

        * `subst' pode realizar multiplas substituições.  `lratsubst' é
          analogo a `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * Se somente uma substituição é desejada, então uma equação
          simples pode ser dada como primeiro argumento.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

        * `fullratsubst' é equivalente a `ratsubst' excepto que essa
          executa recursivamente até que seu resultado para de mudar.

          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b

        * `fullratsubst' também aceita uma lista de equações ou uma
          equação simples como primeiro argumento.

          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b

        * `fullratsubst' pode causar uma recursão infinita.

          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET


 -- Função: gcd (<p_1>, <p_2>, <x_1>, ...)
     Retorna o máximo divisor comum entre <p_1> e <p_2>.  O sinalizador
     `gcd' determina qual algoritmo é empregado.  Escolhendo `gcd' para
     `ez', `subres', `red', ou `spmod' selecciona o algoritmo `ezgcd',
     subresultante `prs', reduzido, ou modular, respectivamente.  Se
     `gcd' for `false' então `gcd (<p_1>, <p_2>, <x>)' sempre retorna 1
     para todo <x>.  Muitas funções (e.g.  `ratsimp', `factor', etc.)
     fazem com que mdc's sejam feitos implicitamente.  Para polinómios
     homogêneos é recomendado que `gcd' igual a `subres' seja usado.
     Para obter o mdc quando uma expressão algébrica está presente,
     e.g. `gcd (<x>^2 - 2*sqrt(2)*<x> + 2, <x> - sqrt(2))', `algebraic'
     deve ser `true' e `gcd' não deve ser `ez'.  `subres' é um novo
     algoritmo, e pessoas que tenham estado usando a opção `red' podem
     provavelmente alterar isso para `subres'.

     O sinalizador `gcd', padrão: `subres', se `false' irá também
     evitar o máximo divisor comum de ser usado quando expressões são
     convertidas para a forma de expressão racional canónica (CRE).
     Isso irá algumas vezes aumentar a velocidade dos cálculos se mdc's
     não são requeridos.


 -- Função: gcdex (<f>, <g>)
 -- Função: gcdex (<f>, <g>, <x>)
     Retornam uma lista `[<a>, <b>, <u>]' onde <u> é o máximo divisor
     comum (mdc) entre <f> e <g>, e <u> é igual a `<a> <f> + <b> <g>'.
     Os argumentos <f> e <g> podem ser polinómios de uma variável, ou
     de outra forma polinómios em <x> uma main(principal) variável
     suprida desde que nós precisamos estar em um domínio de ideal
     principal para isso trabalhar.  O mdc significa o mdc considerando
     <f> e <g> como polinómios de uma única variável com coeficientes
     sendo funções racionais em outras variáveis.

     `gcdex' implementa o algoritmo Euclideano, onde temos a sequência
     of `L[i]: [a[i], b[i], r[i]]' que são todos perpendiculares a `[f,
     g, -1]' e o próximo se é construído como se `q =
     quotient(r[i]/r[i+1])' então `L[i+2]: L[i] - q L[i+1]', e isso
     encerra em `L[i+1]' quando o resto `r[i+2]' for zero.

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0

     Note que o mdc adiante é `1' uma vez que trabalhamos em `k(y)[x]',
     o `y+1' não pode ser esperado em `k[y, x]'.

          (%i1) gcdex (x*(y + 1), y^2 - 1, x);
                                         1
          (%o1)/R/                 [0, ------, 1]
                                        2
                                       y  - 1


 -- Função: gcfactor (<n>)
     Factoriza o inteiro Gaussiano <n> sobre os inteiros Gaussianos,
     i.e., números da forma `<a> + <b> `%i'' onde <a> e <b> são
     inteiros raconais (i.e.,  inteiros comuns).  Factorizações são
     normalizadas fazendo <a> e <b> não negativos.


 -- Função: gfactor (<expr>)
     Factoriza o polinómio <expr> sobre os inteiros de Gauss (isto é,
     os inteiros com a unidade imaginária `%i' adjunta).  Isso é como
     `factor (<expr>, <a>^2+1)' trocando <a> por `%i'.

     Exemplo:

          (%i1) gfactor (x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)


 -- Função: gfactorsum (<expr>)
     é similar a `factorsum' mas aplica `gfactor' em lugar de `factor'.


 -- Função: hipow (<expr>, <x>)
     Retorna o maior expoente explícito de <x> em <expr>.  <x> pode ser
     uma variável ou uma expressão geral.  Se <x> não aparece em <expr>,
     `hipow' retorna `0'.

     `hipow' não considera expressões equivalentes a `expr'.  Em
     particular, `hipow' não expande `expr', então `hipow (<expr>,
     <x>)' e `hipow (expand (<expr>, <x>))' podem retornar diferentes
     resultados.

     Exemplos:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0


 -- Variável de opção: intfaclim
     Valor por omissão: true

     Se `true', maxima irá interromper a factorização de inteiros se
     nenhum factor for encontrado após tentar divisões e o método rho de
     Pollard e a factorização não será completada.

     Quando `intfaclim' for `false' (esse é o caso quando o utilizador
     chama `factor' explicitamente), a factorização completa será
     tentada.  `intfaclim' é escolhida para `false' quando factores são
     calculados em `divisors', `divsum' e `totient'.

     Chamadas internas a `factor' respeitam o valor especificado pelo
     utilizador para `intfaclim'. Setting `intfaclim' to `true' may
     reduce `intfaclim'.  Escolhendo `intfaclim' para `true' podemos
     reduzir o tempo gasto factorizando grandes inteiros.


 -- Variável de opção: keepfloat
     Valor Padrão: `false'

     Quando `keepfloat' for `true', evitamos que números em ponto
     flutuante sejam racionalizados quando expressões que os possuem
     são então convertidas para a forma de expressão racional canónica
     (CRE).


 -- Função: lratsubst (<L>, <expr>)
     é análogo a `subst (<L>, <expr>)' excepto que esse usa `ratsubst'
     em lugar de `subst'.

     O primeiro argumento de `lratsubst' é uma equação ou uma lista de
     equações idênticas em formato para que sejam aceitas por `subst'.
     As substituições são feitas na ordem dada pela lista de equações,
     isto é, da esquerda para a direita.

     `load ("lrats")' chama `fullratsubst' e `lratsubst'.

     Exemplos:

          (%i1) load ("lrats")$

        * `subst' pode realizar multiplas substituições.  `lratsubst' é
          analoga a `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * Se somente uma substituição for desejada, então uma
          equação simples pode ser dada como primeiro argumento.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b


 -- Variável de opção: modulus
     Valor Padrão: `false'

     Quando `modulus' for um número positivo <p>, operações sobre os
     números racionais (como retornado por `rat' e funções relacionadas)
     são realizadas módulo <p>, usando o então chamado sistema de
     módulo "balanceado" no qual `<n> módulo <p>' é definido como um
     inteiro <k> em `[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' quando <p>
     for ímpar, ou `[-(<p>/2 - 1), ..., 0, ...., <p>/2]' quando <p> for
     par, tal que `<a> <p> + <k>' seja igual a <n> para algum inteiro
     <a>.

     Se <expr> já estiver na forma de expressão racional canónica (CRE)
     quando `modulus' for colocado no seu valor original, então pode
     precisar repetir o rat <expr>, e.g., `expr: rat (ratdisrep
     (expr))', com o objectivo de obter resultados correctos.

     Tipicamente `modulus' é escolhido para um número primo.  Se
     `modulus' for escolhido para um inteiro não primo positivo, essa
     escolha é aceita, mas uma mensagem de alerta é mostrada.  Maxima
     permitirá que zero ou um inteiro negativo seja atribuído a
     `modulus', embora isso não seja limpo se aquele tiver quaisquer
     consequências úteis.


 -- Função: num (<expr>)
     Retorna o numerador de <expr> se isso for uma razão.  Se <expr>
     não for uma razão, <expr> é retornado.

     `num' avalia seu argumento.


 -- Função: polydecomp (<p>, <x>)
     Decompões o polinómio <p> na variável  <x> em uma composição
     funcional de polinómios em <x>.  `polydecomp' retorna uma lista
     `[<p_1>, ..., <p_n>]' tal que

          lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x)) ...))

     seja igual a <p>.  O grau de <p_i> é maior que 1 para <i> menor
     que <n>.

     Tal decomposição não é única.

     Exemplos:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     As seguintes funções compõem `L = [e_1, ..., e_n]' como funções em
     `x'; essa funçào é a inversa de `polydecomp':

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Re-exprimindo o exemplo acima usando `compose':

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Note que apesar de `compose (polydecomp (<p>, <x>), <x>)' sempre
     retornar <p> (não expandido), `polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)' não necessáriamente retorna `[<p_1>, ...,
     <p_n>]':

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2


 -- Função: quotient (<p_1>, <p_2>)
 -- Função: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Retorna o polinómio <p_1> dividido pelo polinómio <p_2>.  Os
     argumentos <x_1>, ..., <x_n> são interpretados como em `ratvars'.

     `quotient' retorna o primeiro elemento de uma lista de dois
     elementos retornada por `divide'.


 -- Função: rat (<expr>)
 -- Função: rat (<expr>, <x_1>, ..., <x_n>)
     Converte <expr> para a forma de expressão racional canónica (CRE)
     expandindo e combinando todos os termos sobre um denominador comum
     e cancelando para fora o máximo divisor comum entre o numerador e
     o denominador, também convertendo números em ponto flutuante para
     números racionais dentro da tolerância de `ratepsilon'.  As
     variáveis são ordenadas de acordo com <x_1>, ..., <x_n>, se
     especificado, como em `ratvars'.

     `rat' geralmente não simplifica funções outras que não sejam
     adição `+', subtração `-', multiplicação `*', divisão `/', e
     exponenciação com expoente inteiro, uma vez que `ratsimp' não
     manuseia esses casos.  Note que átomos (números e variáveis) na
     forma CRE não são os mesmos que eles são na forma geral.  Por
     exemplo, `rat(x)- x' retorna `rat(0)' que tem uma representação
     interna diferente de 0.

     Quando `ratfac' for `true', `rat' retorna uma forma parcialmente
     factorizada para CRE.  Durante operações racionais a expressão é
     mantida como totalmente factorizada como possível sem uma chamada
     ao pacote de factorização (`factor').  Isso pode sempre economizar
     espaço de memória e algum tempo em algumas computações.  O
     numerador e o denominador são ainda tidos como relativamente primos
     (e.g.  `rat ((x^2 - 1)^4/(x + 1)^2)' retorna `(x - 1)^4 (x +
     1)^2)', mas os factores dentro de cada parte podem não ser
     relativamente primos.

     `ratprint' se `false' suprime a impressão de mensagens informando
     o utilizador de conversões de números em ponto flutuante para
     números racionais.

     `keepfloat' se `true' evita que números em ponto flutuante sejam
     convertidos para números racionais.

     Veja também `ratexpand' e  `ratsimp'.

     Exemplos:

          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y


 -- Variável de opção: ratalgdenom
     Valor Padrão: `true'

     Quando `ratalgdenom' for `true', permite racionalização de
     denominadores com respeito a radicais tenham efeito.
     `ratalgdenom' tem efeito somente quando expressões racionais
     canónicas (CRE) forem usadas no modo algébrico.


 -- Função: ratcoef (<expr>, <x>, <n>)
 -- Função: ratcoef (<expr>, <x>)
     Retorna o coeficiente da expressão `<x>^<n>' dentro da expressão
     <expr>.  Se omitido, <n> é assumido ser 1.

     O valor de retorno está livre (excepto possivelmente em um senso
     não racional) das variáveis em <x>.  Se nenhum coeficiente desse
     tipo existe, 0 é retornado.

     `ratcoef' expande e simplifica racionalmente seu primeiro
     argumento e dessa forma pode produzir respostas diferentes das de
     `coeff' que é puramente sintática.  Dessa forma `ratcoef ((x +
     1)/y + x, x)' retorna `(y + 1)/y' ao passo que `coeff' retorna 1.

     `ratcoef (<expr>, <x>, 0)', visualiza <expr> como uma adição,
     retornando uma soma desses termos que não possuem <x>.  portanto
     se <x> ocorre para quaisquer expoentes negativos, `ratcoef' pode
     não ser usado.

     Uma vez que <expr> é racionalmente simplificada antes de ser
     examinada, coeficientes podem não aparecer inteiramente no caminho
     que eles foram pensados.

     Exemplo:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x


 -- Função: ratdenom (<expr>)
     Retorna o denominador de <expr>, após forçar a conversão de <expr>
     para expressão racional canónica (CRE).  O valor de retorno é a
     CRE.

     <expr> é forçada para uma CRE por `rat' se não for já uma CRE.
     Essa conversão pode mudar a forma de <expr> colocando todos os
     termos sobre um denominador comum.

     `denom' é similar, mas retorna uma expressão comum em lugar de uma
     CRE.  Também, `denom' não tenta colocar todos os termos sobre um
     denominador comum, e dessa forma algumas expressões que são
     consideradas razões por `ratdenom' não são consideradas razões por
     `denom'.


 -- Variável de opção: ratdenomdivide
     Valor Padrão: `true'

     Quando `ratdenomdivide' for `true', `ratexpand' expande uma razão
     cujo o numerador for uma adição dentro de uma soma de razões,
     tendo todos um denominador comum.  De outra forma, `ratexpand'
     colapsa uma adição de razões dentro de uma razão simples, cujo
     numerador seja a adição dos numeradores de cada razão.

     Exemplos:

          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3


 -- Função: ratdiff (<expr>, <x>)
     Realiza a derivação da expressão racional <expr> com relação a <x>.
     <expr> deve ser uma razão de polinómios ou um polinómio em <x>.  O
     argumento <x> pode ser uma variável ou uma subexpressão de <expr>.

     O resultado é equivalente a `diff', embora talvez em uma forma
     diferente.  `ratdiff' pode ser mais rápida que `diff', para
     expressões racionais.

     `ratdiff' retorna uma expressão racional canónica (CRE) se `expr'
     for uma CRE.  De outra forma, `ratdiff' retorna uma expressão
     geral.

     `ratdiff' considera somente as dependências de <expr> sobre <x>, e
     ignora quaisquer dependências estabelecidas por `depends'.

     Exemplo:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a


 -- Função: ratdisrep (<expr>)
     Retorna seu argumento como uma expressão geral.  Se <expr> for uma
     expressão geral, é retornada inalterada.

     Tipicamente `ratdisrep' é chamada para converter uma expressão
     racional canónica (CRE) em uma expressão geral.  Isso é algumas
     vezes conveniente se deseja-se parar o "contágio", ou caso se
     esteja usando funções racionais em contextos não racionais.

     Veja também `totaldisrep'.


 -- Variável de opção: ratepsilon
     Valor Padrão: 2.0e-8

     `ratepsilon' é a tolerância usada em conversões de números em
     ponto flutuante para números racionais.


 -- Função: ratexpand (<expr>)
 -- Variável de opção: ratexpand
     Expande <expr> multiplicando para fora produtos de somas e somas
     exponenciadas, combinando frações sobre um denominador comum,
     cancelando o máximo divisor comum entre entre o numerador e o
     denominador, então quebrando o numerador (se for uma soma) dentro
     de suas respectivas parcelas divididas pelo denominador.

     O valor de retorno de `ratexpand' é uma expressão geral, mesmo se
     <expr> for uma expressão racional canónica (CRE).

     O comutador `ratexpand' se `true' fará com que expressões CRE
     sejam completamente expandidas quando forem convertidas de volta
     para a forma geral ou mostradas, enquanto se for `false' então
     elas serão colocadas na forma recursiva.  Veja também `ratsimp'.

     Quando `ratdenomdivide' for `true', `ratexpand' expande uma razão
     na qual o numerador é uma adição dentro de uma adição de razões,
     todas tendo um denominador comum.  De outra forma, `ratexpand'
     contrai uma soma de razões em uma razão simples, cujo numerador é
     a soma dos numeradores de cada razão.

     Quando `keepfloat' for `true', evita que números em ponto
     flutuante sejam racionalizados quando expressões que contenham
     números em ponto flutuante forem convertidas para a forma de
     expressão racional canónica (CRE).

     Exemplos:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1


 -- Variável de opção: ratfac
     Valor Padrão: `false'

     Quando `ratfac' for `true', expressões racionais canónicas (CRE)
     são manipuladas na forma parcialmente factorizada.

     Durante operações racionais a expressão é mantida como
     completamente factorizada como foi possível sem chamadas a
     `factor'.  Isso pode sempre economizar espaço e pode economizar
     tempo em algumas computações.  O numerador e o denominador são
     feitos relativamente primos, por exemplo `rat ((x^2 - 1)^4/(x +
     1)^2)' retorna `(x - 1)^4 (x + 1)^2)', mas o factor dentro de cada
     parte pode não ser relativamente primo.

     No pacote `ctensor' (Manipulação de componentes de tensores),
     tensores de Ricci, Einstein, Riemann, e de Weyl e a curvatura
     escalar são factorizados automaticamente quando `ratfac' for
     `true'.  `ratfac' pode somente ser escolhido para casos onde as
     componentes tensoriais sejam sabidametne consistidas de poucos
     termos.

     Os esquemas de `ratfac' e de `ratweight' são incompatíveis e não
     podem ambos serem usados ao mesmo tempo.


 -- Função: ratnumer (<expr>)
     Retorna o numerador de <expr>, após forçar <expr> para uma
     expressão racional canónica (CRE).  O valor de retorno é uma CRE.

     <expr> é forçada para uma CRE por `rat' se isso não for já uma CRE.
     Essa conversão pode alterar a forma de <expr> pela colocação de
     todos os termos sobre um denominador comum.

     `num' é similar, mas retorna uma expressão comum em lugar de uma
     CRE.  Também, `num' não tenta colocar todos os termos sobre um
     denominador comum, e dessa forma algumas expressões que são
     consideradas razões por `ratnumer' não são consideradas razões por
     `num'.


 -- Função: ratnump (<expr>)
     Retorna `true' se <expr> for um inteiro literal ou razão de
     inteiros literais, de outra forma retorna `false'.


 -- Função: ratp (<expr>)
     Retorna `true' se <expr> for uma expressão racional canónica (CRE)
     ou CRE extendida, de outra forma retorna `false'.

     CRE são criadas por `rat' e funções relacionadas.  CRE extendidas
     são criadas por `taylor' e funções relacionadas.


 -- Variável de opção: ratprint
     Valor Padrão: `true'

     Quando `ratprint' for `true', uma mensagem informando ao
     utilizador da conversão de números em ponto flutuante para números
     racionais é mostrada.


 -- Função: ratsimp (<expr>)
 -- Função: ratsimp (<expr>, <x_1>, ..., <x_n>)
     Simplifica a expressão <expr> e todas as suas subexpressões,
     incluindo os argumentos para funções não racionais.  O resultado é
     retornado como o quociente de dois polinómios na forma recursiva,
     isto é, os coeficientes de variável principal são polinómios em
     outras variáveis.  Variáveis podem incluir funções não racionais
     (e.g., `sin (x^2 + 1)') e os argumentos para quaisquer tais
     funções são também simplificados racionalmente.

     `ratsimp (<expr>, <x_1>, ..., <x_n>)' habilita simplificação
     racional com a especiicação de variável ordenando como em
     `ratvars'.

     Quando `ratsimpexpons' for `true', `ratsimp' é aplicado para os
     expoentes de expressões durante a simplificação.

     Veja também `ratexpand'.  Note que `ratsimp' é afectado por algum
     dos sinalizadores que afectam `ratexpand'.

     Exemplos:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x


 -- Variável de opção: ratsimpexpons
     Valor Padrão: `false'

     Quando `ratsimpexpons' for `true', `ratsimp' é aplicado para os
     expoentes de expressões durante uma simplificação.


 -- Função: ratsubst (<a>, <b>, <c>)
     Substitue <a> por <b> em <c> e retorna a expressão resultante.
     <b> pode também ser uma adição, produto, expoente, etc.

     `ratsubst' sabe alguma coisa do significado de expressões uma vez
     que `subst' não é uma substituição puramente sintática.  Dessa
     forma `subst (a, x + y, x + y + z)' retorna `x + y + z' ao passo
     que `ratsubst' retorna `z + a'.

     Quando `radsubstflag' for `true', `ratsubst' faz substituição de
     radicais em expressões que explicitamente não possuem esses
     radicais.

     Exemplos:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u


 -- Função: ratvars (<x_1>, ..., <x_n>)
 -- Função: ratvars ()
 -- Variável de sistema: ratvars
     Declara variáveis principais <x_1>, ..., <x_n> para expressões
     racionais.  <x_n>, se presente em uma expressão racional, é
     considerada a variável principal.  De outra forma, <x_[n-1]> é
     considerada a variável principal se presente, e assim por diante
     até as variáveis precedentes para <x_1>, que é considerada a
     variável principal somente se nenhuma das variáveis que a sucedem
     estiver presente.

     Se uma variável em uma expressão racional não está presente na
     lista `ratvars', a ela é dada uma prioridade menor que <x_1>.

     Os argumentos para `ratvars' podem ser ou variáveis ou funções não
     racionais tais como `sin(x)'.

     A variável `ratvars' é uma lista de argumentos da função `ratvars'
     quando ela foi chamada mais recentemente.  Cada chamada para a
     função `ratvars' sobre-grava a lista apagando seu conteúdo
     anterior.  `ratvars ()' limpa a lista.


 -- Função: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Função: ratweight ()
     Atribui um peso <w_i> para a variável <x_i>.  Isso faz com que um
     termo seja substituído por 0 se seu peso exceder o valor da
     variável `ratwtlvl' (o padrão retorna sem truncação).  O peso de
     um termo é a soma dos produtos dos pesos de uma variável no termo
     vezes seu expoente.  Por exemplo, o peso de `3 x_1^2 x_2' é `2 w_1
     + w_2'.  A truncação de acordo com `ratwtlvl' é realizada somente
     quando multiplicando ou exponencializando expressões racionais
     canónicas (CRE).

     `ratweight ()' retorna a lista cumulativa de atribuições de pesos.

     Nota: Os esquemas de `ratfac' e `ratweight' são incompatíveis e
     não podem ambo serem usados ao mesmo tempo.

     Exemplos:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1


 -- Variável de sistema: ratweights
     Valor Padrão: `[]'

     `ratweights' é a lista de pesos atribuídos por `ratweight'.  A
     lista é cumulativa: cada chamada a `ratweight' coloca ítens
     adicionais na lista.

     `kill (ratweights)' e `save (ratweights)' ambos trabalham como
     esperado.


 -- Variável de opção: ratwtlvl
     Valor Padrão: `false'

     `ratwtlvl' é usada em combinação com a função `ratweight' para
     controlar a truncação de expressão racionais canónicas (CRE).
     Para o valor padrão `false', nenhuma truncação ocorre.


 -- Função: remainder (<p_1>, <p_2>)
 -- Função: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Retorna o resto do polinómio <p_1> dividido pelo polinómio <p_2>.
     Os argumentos <x_1>, ..., <x_n> são interpretados como em
     `ratvars'.

     `remainder' retorna o segundo elemento de uma lista de dois
     elementos retornada por `divide'.


 -- Função: resultant (<p_1>, <p_2>, <x>)
 -- Variável: resultant
     Calcula o resultante de dois polinómios <p_1> e <p_2>, eliminando
     a variável <x>.  O resultante é um determinante dos coeficientes
     de <x> em <p_1> e <p_2>, que é igual a zero se e somente se <p_1>
     e <p_2> tiverem um factor em comum não constante.

     Se <p_1> ou <p_2> puderem ser factorizados, pode ser desejável
     chamar `factor' antes de chamar `resultant'.

     A variável `resultant' controla que algoritmo será usado para
     calcular o resultante.  `subres' para o prs subresultante, `mod'
     para o algoritmo resultante modular, e `red' para prs reduzido.
     Para muitos problemas `subres' pode ser melhor.  Para alguns
     problemas com valores grandes de grau de uma única variável ou de
     duas variáveis `mod' pode ser melhor.

     A função `bezout' aceita os mesmos argumentos que `resultant' e
     retorna uma matriz.  O determinante do valor de retorno é o
     resultante desejado.


 -- Variável de opção: savefactors
     Valor Padrão: `false'

     Quando `savefactors' for `true', faz com que os factores de uma
     expressão que é um produto de factores sejam gravados por certas
     funções com o objectivo de aumentar a velocidade em posteriores
     factorizações de expressões contendo algum desses mesmos factores.


 -- Função: sqfr (<expr>)
     é similar a `factor' excepto que os factores do polinómio são
     "livres de raízes".  Isto é, eles possuem factores somente de grau
     um.  Esse algoritmo, que é também usado no primeiro estágio de
     `factor', utiliza o facto que um polinómio tem em comum com sua
     n'ésima derivada todos os seus factores de grau maior que n.
     Dessa forma obtendo o maior divisor comum com o polinómio das
     derivadas com relação a cada variável no polinómio, todos os
     factores de grau maior que 1 podem ser achados.

     Exemplo:

          (%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                          2   2
          (%o1)                  (2 x + 1)  (x  - 1)


 -- Função: tellrat (<p_1>, ..., <p_n>)
 -- Função: tellrat ()
     Adiciona ao anel dos inteiros algébricos conhecidos do Maxima os
     elementos que são as soluções dos polinómios <p_1>, ..., <p_n>.
     Cada argumento <p_i> é um polinómio concoeficientes inteiros.

     `tellrat (<x>)' efectivamente significa substituir 0 por <x> em
     funções racionais.

     `tellrat ()' retorna uma lista das substituições correntes.

     `algebraic' deve ser escolhida para `true' com o objectivo de que
     a simplificação de inteiros algébricos tenha efeito.

     Maxima inicialmente sabe sobre a unidade imaginária `%i' e todas
     as raízes de inteiros.

     Existe um comando `untellrat' que recebe núcleos e remove
     propriedades `tellrat'.

     Quando fazemos `tellrat' em um polinómio de várias variáveis,
     e.g., `tellrat (x^2 - y^2)', pode existir uma ambiguidade como para
     ou substituir `<y>^2' por `<x>^2' ou vice-versa.  Maxima
     selecciona uma ordenação particular, mas se o utilizador desejar
     especificar qual e.g.  `tellrat (y^2 = x^2)' forneçe uma sintaxe
     que diga para substituir `<y>^2' por `<x>^2'.

     Exemplos:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]


 -- Função: totaldisrep (<expr>)
     Converte toda subexpressão de <expr> da forma de expressão
     racionais canónicas (CRE) para a forma geral e retorna o resultado.
     Se <expr> é em sí mesma na forma CRE então `totaldisrep' é
     identica a `ratdisrep'.

     `totaldisrep' pode ser usada para fazer um `ratdisrep' em
     expressões tais como equações, listas, matrizes, etc., que tiverem
     algumas subexpressões na forma CRE.


 -- Função: untellrat (<x_1>, ..., <x_n>)
     Remove propriedades `tellrat' de <x_1>, ..., <x_n>.



File: maxima.info,  Node: Constantes,  Next: Logaritmos,  Prev: Polinómios,  Up: Top

13 Constantes
*************

* Menu:

* Definições para Constantes::


File: maxima.info,  Node: Definições para Constantes,  Prev: Constantes,  Up: Constantes

13.1 Definições para Constantes
===============================

 -- Constante: %e
     `%e' representa a base do logaritmo natural, também conhecido como
     constante de Euler.  O valor numérico de `%e' é um número em ponto
     flutuante de precisão dupla 2.718281828459045d0.


 -- Constante: %i
     `%i' representa a unidade imaginária, sqrt(- 1).


 -- Constante: false
     `false' representa a constante Booleana falso.  Maxima implementa
     `false' através do valor `NIL' no Lisp.


 -- Constante: inf
     `inf' representa o infinito positivo real.


 -- Constante: infinity
     `infinity' representa o infinito complexo.


 -- Constante: minf
     `minf' representa o menos infinito (i.e., negativo) real.


 -- Constante: %phi
     `%phi' representa o então chamado número áureo, (1 + sqrt(5))/2.
     O valor numérico de `%phi' é o número em ponto flutuante de de
     dupla precisão 1.618033988749895d0.

     `fibtophi' expressa números de Fibonacci `fib(n)' em termos de
     `%phi'.

     Por padrão, Maxima não conhece as propriedade algébricas de `%phi'.
     Após avaliar `tellrat(%phi^2 - %phi - 1)' e `algebraic: true',
     `ratsimp' pode simplificar algumas expressãoes contendo `%phi'.

     Exemplos:

     `fibtophi' expresses Fibonacci numbers `fib(n)' in terms of `%phi'.

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

     Por padrão, Maxima não conhece as propriedade algébricas de `%phi'.
     Após avaliar `tellrat(%phi^2 - %phi - 1)' e `algebraic: true',
     `ratsimp' pode simplificar algumas expressãoes contendo `%phi'.

          (%i1) e : expand ((%phi^2 - %phi - 1) * (A + 1));
                           2                      2
          (%o1)        %phi  A - %phi A - A + %phi  - %phi - 1
          (%i2) ratsimp (e);
                            2                     2
          (%o2)        (%phi  - %phi - 1) A + %phi  - %phi - 1
          (%i3) tellrat (%phi^2 - %phi - 1);
                                      2
          (%o3)                  [%phi  - %phi - 1]
          (%i4) algebraic : true;
          (%o4)                         true
          (%i5) ratsimp (e);
          (%o5)                           0


 -- Constante: %pi
     `%pi' representa a razão do perímetro de um círculo para seu
     diâmetro.  O valor numérico de `%pi' é o n;umero em ponto
     flutuante de dupla precisão 3.141592653589793d0.


 -- Constante: true
     `true' representa a constante Booleana verdadeiro.  Maxima
     implementa `true' através do valor `T' no Lisp.



File: maxima.info,  Node: Logaritmos,  Next: Trigonometria,  Prev: Constantes,  Up: Top

14 Logaritmos
*************

* Menu:

* Definições para Logaritmos::


File: maxima.info,  Node: Definições para Logaritmos,  Prev: Logaritmos,  Up: Logaritmos

14.1 Definições para Logaritmos
===============================

 -- Variável de opção: %e_to_numlog
     Valor por omissão: `false'

     Quando `true', sendo `r' algum número racional, e `x' alguma
     expressão, `%e^(r*log(x))' será simplificado em `x^r' .  Note-se
     que o comando `radcan' também faz essa transformação, assim como
     algumas transformações mais complicadas.  O comando `logcontract'
     _contrai_ expressões contendo `log'.


 -- Função: li [<s>] (<z>)
     Representa a função polilogaritmo de ordem <s> e argumento <z>,
     definida por meio da série infinita

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     `li [1]' é `- log (1 - z)'.  `li [2]' e `li [3]' são as funções
     dilogaritmo e trilogaritmo, respectivamente.

     Quando a ordem for 1, o polilogaritmo simplifica para `- log (1 -
     z)', o qual por sua vez simplifica para um valor numérico se <z>
     for um número em ponto flutuante real ou complexo ou o sinalizador
     de avaliação `numer' estiver presente.

     Quando a ordem for 2 ou 3, o polilogaritmo simplifica para um
     valor numérico se <z> for um número real em ponto flutuante ou o
     sinalizador de avaliação `numer' estiver presente.

     Exemplos:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]


 -- Função: log (<x>)
     Representa o logaritmo natural (base e) de <x>.

     Maxima não possui uma função interna para logaritmo de base 10 ou
     de outras bases. `log10(x) := log(x) / log(10)' é uma definição
     útil.

     A simplificação e avaliação de logaritmos são governadas por
     vários sinalizadores globais:

     `logexpand' - faz com que `log(a^b)' se transfome em `b*log(a)'.
     Se `logexpand' tiver o valor `all', `log(a*b)' irá também
     simplificar para `log(a)+log(b)'.  Se `logexpand' for igual a
     `super', então `log(a/b)' irá também simplificar para
     `log(a)-log(b)' para números racionais `a/b', `a#1' (`log(1/b)',
     para `b' inteiro, sempre simplifica).  Se `logexpand' for igaul a
     `false', todas essas simplificações irão ser desabilitadas.

     `logsimp' - se tiver valor `false', não será feita nenhuma
     simplificação de `%e' para um expoente contendo `log''s.

     `lognumer' - se tiver valor `true', os argumentos negativos em
     ponto flutuante para `log' irá sempre ser convertidos para seu
     valor absoluto antes que `log' seja calculado. Se `numer' for
     também `true', então argumentos negativos inteiros para `log' irão
     também ser convertidos para os seus valores absolutos.

     `lognegint' - se tiver valor `true', implementa a regra `log(-n)'
     -> `log(n)+%i*%pi' para `n' um inteiro positivo.

     `%e_to_numlog' - quando for igual a `true', `%e^(r*log(x))', sendo
     `r' algum número racional, e `x' alguma expressão, será
     simplificado para `x^r'. Note-se que o comando `radcan' também faz
     essa transformação, e outras transformações mais complicadas desse
     género.

     O comando `logcontract' "contrai" expressões contendo `log'.


 -- Variável de opção: logabs
     Valor por omissão: `false'

     No cálculo de primitivas em que sejam gerados logaritmos, por
     exemplo, `integrate(1/x,x)', a resposta será dada em termos de
     `log(abs(...))' se `logabs' for `true', mas em termos de
     `log(...)' se `logabs' for `false'. Para integrais definidos,
     usa-se `logabs:true', porque nesse caso muitas vezes é necessário
     calcular a primitiva nos extremos.


 -- Variável de opção: logarc
 -- Função: logarc (<expr>)
     Quando a variável global `logarc' for igual a `true', as funções
     trigononométricas inversas, circulares e hiperbólicas, serão
     substituídas por suas funções logarítmicas equivalentes. O valor
     padrão de `logarc' é `false'.

     A função `logarc(<expr>)' realiza essa substituição para uma
     expressão <expr> sem modificar o valor da variável global `logarc'.


 -- Variável de opção: logconcoeffp
     Valor por omissão: `false'

     Controla quais coeficientes são contraídos quando se usa
     `logcontract'. Poderá ser igual ao nome de uma função de um
     argumento. Por exemplo, se quiser gerar raízes quadradas, pode
     fazer `logconcoeffp:'logconfun$ logconfun(m):=featurep(m,integer)
     or ratnump(m)$'. E assim, `logcontract(1/2*log(x));' produzirá
     `log(sqrt(x))'.


 -- Função: logcontract (<expr>)
     Examina recursivamente a expressão <expr>, transformando
     subexpressões da forma `a1*log(b1) + a2*log(b2) + c' em
     `log(ratsimp(b1^a1 * b2^a2)) + c'

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     Se fizer `declare(n,integer);' então `logcontract(2*a*n*log(x));'
     produzirá `a*log(x^(2*n))'. Os coeficientes que _contraem_ dessa
     maneira são os que, tal como 2 e `n' neste exemplo, satisfazem
     `featurep(coeficiente,integer)'. O utilizador pode controlar quais
     coeficientes são contraídos, dando à variável `logconcoeffp' o
     nome de uma função de um argumento. Por exemplo, se quiser gerar
     raízes quadradas, pode fazer `logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$'. E assim,
     `logcontract(1/2*log(x));' produzirá `log(sqrt(x))'.


 -- Variável de opção: logexpand
     Valor por omissão: `true'

     Faz com que `log(a^b)' se transfome em `b*log(a)'. Se `logexpand'
     tiver o valor `all', `log(a*b)' irá também simplificar para
     `log(a)+log(b)'.  Se `logexpand' for igual a `super', então
     `log(a/b)' irá também simplificar para `log(a)-log(b)' para
     números racionais `a/b', `a#1' (`log(1/b)', para `b' inteiro,
     sempre simplifica).  Se `logexpand' for igaul a `false', todas
     essas simplificações irão ser desabilitadas.


 -- Variável de opção: lognegint
     Valor por omissão: `false'

     Se for igual a `true', implementa a regra `log(-n)' ->
     `log(n)+%i*%pi' para `n' um inteiro positivo.


 -- Variável de opção: lognumer
     Valor por omissão: `false'

     Se tiver valor `true', os argumentos negativos em ponto flutuante
     para `log' irá sempre ser convertidos para seu valor absoluto
     antes que `log' seja calculado. Se `numer' for também `true',
     então argumentos negativos inteiros para `log' irão também ser
     convertidos para os seus valores absolutos.


 -- Variável de opção: logsimp
     Valor por omissão: `true'

     Se tiver valor `false', não será feita nenhuma simplificação de
     `%e' para um expoente contendo `log''s.


 -- Função: plog (<x>)
     Representa o ramo principal dos logaritmos naturais no plano
     complexo, com `-%pi' < `carg(<x>)' <= `+%pi'.



File: maxima.info,  Node: Trigonometria,  Next: Funções Especiais,  Prev: Logaritmos,  Up: Top

15 Trigonometria
****************

* Menu:

* Introdução ao Pacote Trigonométrico::
* Definições para Trigonometria::


File: maxima.info,  Node: Introdução ao Pacote Trigonométrico,  Next: Definições para Trigonometria,  Prev: Trigonometria,  Up: Trigonometria

15.1 Introdução ao Pacote Trigonométrico
========================================

Maxima tem muitas funções trigonométricas definidas.  Não todas as
identidades trigonometricas estão programadas, mas isso é possível para
o utilizador adicionar muitas delas usando a compatibilidade de
correspondência de modelos do sistema.  As funções trigonométricas
definidas no Maxima são: `acos', `acosh', `acot', `acoth', `acsc',
`acsch', `asec', `asech', `asin', `asinh', `atan', `atanh', `cos',
`cosh', `cot', `coth', `csc', `csch', `sec', `sech', `sin', `sinh',
`tan', e `tanh'.  Existe uma colecção de comandos especialmente para
manusear funções trigonométricas, veja `trigexpand', `trigreduce', e o
comutador `trigsign'.  Dois pacotes compartilhados extendem as regras
de simplificação construídas no Maxima, `ntrig' e `atrig1'.  Faça
`describe(<comando>)' para detalhes.


File: maxima.info,  Node: Definições para Trigonometria,  Prev: Introdução ao Pacote Trigonométrico,  Up: Trigonometria

15.2 Definições para Trigonometria
==================================

 -- Função: acos (<x>)
     - Arco Cosseno.


 -- Função: acosh (<x>)
     - Arco Cosseno Hiperbólico.


 -- Função: acot (<x>)
     - Arco Cotangente.


 -- Função: acoth (<x>)
     - Arco Cotangente Hiperbólico.


 -- Função: acsc (<x>)
     - Arco Cossecante.


 -- Função: acsch (<x>)
     - Arco Cossecante Hiperbólico.


 -- Função: asec (<x>)
     - Arco Secante.


 -- Função: asech (<x>)
     - Arco Secante Hiperbólico.


 -- Função: asin (<x>)
     - Arco Seno.


 -- Função: asinh (<x>)
     - Arco Seno Hiperbólico.


 -- Função: atan (<x>)
     - Arco Tangente.


 -- Função: atan2 (<y>, <x>)
     - retorna o valor de `atan(<y>/<x>)' no intervalo de `-%pi' a
     `%pi'.


 -- Função: atanh (<x>)
     - Arco tangente Hiperbólico.


 -- Pacote: atrig1
     O pacote `atrig1' contém muitas regras adicionais de
     simplificação para funções trigonométricas inversas.  Junto com
     regras já conhecidas para Maxima, os seguintes ângulos estão
     completamente implementados: `0', `%pi/6', `%pi/4', `%pi/3', e
     `%pi/2'.  Os ângulos correspondentes nos outros três quadrantes
     estão também disponíveis.  Faça `load(atrig1);' para usá-lo.


 -- Função: cos (<x>)
     - Cosseno.


 -- Função: cosh (<x>)
     - Cosseno hiperbólico.


 -- Função: cot (<x>)
     - Cotangente.


 -- Função: coth (<x>)
     - Cotangente Hyperbólica.


 -- Função: csc (<x>)
     - Cossecante.


 -- Função: csch (<x>)
     - Cossecante Hyperbólica.


 -- Variável de opção: halfangles
     Default value: `false'

     Quando `halfangles' for `true', meios-ângulos são simplificados
     imediatamente.


 -- Pacote: ntrig
     O pacote `ntrig' contém um conjunto de regras de simplificação que
     são usadas para simplificar função trigonométrica cujos argumentos
     estão na forma `<f>(<n> %pi/10)' onde <f> é qualquer das funções
     `sin', `cos', `tan', `csc', `sec' e `cot'.


 -- Função: sec (<x>)
     - Secante.


 -- Função: sech (<x>)
     - Secante Hyperbólica.


 -- Função: sin (<x>)
     - Seno.


 -- Função: sinh (<x>)
     - Seno Hyperbólico.


 -- Função: tan (<x>)
     - Tangente.


 -- Função: tanh (<x>)
     - Tangente Hyperbólica.


 -- Função: trigexpand (<expr>)
     Expande funções trigonometricas e hyperbólicas de adições de
     ângulos e de ângulos multiplos que ocorram em <expr>.  Para
     melhores resultados, <expr> deve ser expandida.  Para intensificar
     o controle do utilizador na simplificação, essa função expande
     somente um nível de cada vez, expandindo adições de ângulos ou
     ângulos multiplos.  Para obter expansão completa dentro de senos e
     co-senos imediatamente, escolha o comutador `trigexpand: true'.

     `trigexpand' é governada pelos seguintes sinalizadores globais:

    `trigexpand'
          Se `true' causa expansão de todas as expressões contendo
          senos e co-senos ocorrendo subsequêntemente.

    `halfangles'
          Se `true' faz com que meios-ângulos sejam simplificados
          imediatamente.

    `trigexpandplus'
          Controla a regra "soma" para `trigexpand', expansão de
          adições (e.g. `sin(x + y)') terão lugar somente se
          `trigexpandplus' for `true'.

    `trigexpandtimes'
          Controla a regra "produto" para `trigexpand', expansão de
          produtos (e.g. `sin(2 x)') terão lugar somente se
          `trigexpandtimes' for `true'.

     Exemplos:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)


 -- Variável de opção: trigexpandplus
     Valor por omissão: `true'

     `trigexpandplus' controla a regra da "soma" para `trigexpand'.
     Dessa forma, quando o comando `trigexpand' for usado ou o
     comutador `trigexpand' escolhido para `true', expansão de
     adições (e.g. `sin(x+y))' terão lugar somente se `trigexpandplus'
     for `true'.


 -- Variável de opção: trigexpandtimes
     Valor por omissão: `true'

     `trigexpandtimes' controla a regra "produto" para `trigexpand'.
     Dessa forma, quando o comando `trigexpand' for usado ou o
     comutador `trigexpand' escolhido para `true', expansão de produtos
     (e.g. `sin(2*x)') terão lugar somente se `trigexpandtimes' for
     `true'.


 -- Variável de opção: triginverses
     Valor por omissão: `all'

     `triginverses' controla a simplificação de composições de
     funções trigonométricas e hiperbólicas com suas funções inversas.

     Se `all', ambas e.g. `atan(tan(<x>))' e `tan(atan(<x>))'
     simplificarão para <x>.

     Se `true', a simplificação  de `<arcfun>(<fun>(<x>))' é
     desabilitada.

     Se `false', ambas as simplificações `<arcfun>(<fun>(<x>))' e
     `<fun>(<arcfun>(<x>))' são desabilitadas.


 -- Função: trigreduce (<expr>, <x>)
 -- Função: trigreduce (<expr>)
     Combina produtos e expoentes de senos e cossenso trigonométricos e
     hiperbólicos de <x> dentro daqueles de múltiplos de <x>.  Também
     tenta eliminar essas funções quando elas ocorrerem em
     denominadores.  Se <x> for omitido então todas as variáveis em
     <expr> são usadas.

     Veja também `poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

     As rotinas de simplificação trigonométrica irão usar informações
     declaradas em alguns casos simples.  Declarações sobre variáveis
     são usadas como segue, e.g.

          (%i1) declare(j, integer, e, even, o, odd)$
          (%i2) sin(x + (e + 1/2)*%pi);
          (%o2)                        cos(x)
          (%i3) sin(x + (o + 1/2)*%pi);
          (%o3)                       - cos(x)


 -- Variável de opção: trigsign
     Valor por omissão: `true'

     Quando `trigsign' for `true', permite simplificação de argumentos
     negativos para funções trigonométricas. E.g., `sin(-x)'
     transformar-se-á em `-sin(x)' somente se `trigsign' for `true'.


 -- Função: trigsimp (<expr>)
     Utiliza as identidades sin(x)^2 + cos(x)^2 = 1 and cosh(x)^2 -
     sinh(x)^2 = 1 para simplificar expressões contendo `tan', `sec',
     etc., para `sin', `cos', `sinh', `cosh'.

     `trigreduce', `ratsimp', e `radcan' podem estar habilitadas a
     adicionar simplificações ao resultado.

     `demo ("trgsmp.dem")' mostra alguns exemplos de `trigsimp'.


 -- Função: trigrat (<expr>)
     Fornece uma forma quase-linear simplificada canónica de uma
     expressão trigonométrica; <expr> é uma fração racional de muitos
     `sin', `cos' ou `tan', os argumentos delas são formas lineares em
     algumas variáveis (ou kernels-núcleos) e `%pi/<n>' (<n> inteiro)
     com coeficientes inteiros. O resultado é uma fração simplificada
     com numerador e denominador ambos lineares em `sin' e `cos'.
     Dessa forma `trigrat' lineariza sempre quando isso for passível.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     O seguinte exemplo encontra-se em Davenport, Siret, and Tournier,
     Calcul Formel, Masson (ou em inglês, Addison-Wesley), secção
     1.5.5, teorema de Morley.

          (%i1) c: %pi/3 - a - b;
                                              %pi
          (%o1)                     - b - a + ---
                                               3
          (%i2) bc: sin(a)*sin(3*c)/sin(a+b);
                                sin(a) sin(3 b + 3 a)
          (%o2)                 ---------------------
                                     sin(b + a)
          (%i3) ba: bc, c=a, a=c$
          (%i4) ac2: ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2       2
                sin (a) sin (3 b + 3 a)
          (%o4) -----------------------
                         2
                      sin (b + a)

                                                  %pi
             2 sin(a) sin(3 a) cos(b) sin(b + a - ---) sin(3 b + 3 a)
                                                   3
           - --------------------------------------------------------
                                     %pi
                             sin(a - ---) sin(b + a)
                                      3

                2         2         %pi
             sin (3 a) sin (b + a - ---)
                                     3
           + ---------------------------
                       2     %pi
                    sin (a - ---)
                              3
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)

           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)

           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)

           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)

           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)

           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)

           - 9)/4



File: maxima.info,  Node: Funções Especiais,  Next: Funções Elípticas,  Prev: Trigonometria,  Up: Top

16 Funções Especiais
********************

* Menu:

* Introdução a Funções Especiais::
* Definições para Funções Especiais::


File: maxima.info,  Node: Introdução a Funções Especiais,  Next: Definições para Funções Especiais,  Prev: Funções Especiais,  Up: Funções Especiais

16.1 Introdução a Funções Especiais
===================================

A notação de função especial segue adiante:

     bessel_j (index, expr)         Função de Bessel, primeiro tipo
     bessel_y (index, expr)         Função de Bessel, segundo tipo
     bessel_i (index, expr)         Função de Bessel modificada, primeiro tipo
     bessel_k (index, expr)         Função de Bessel modificada, segundo tipo
     %he[n] (z)                     Polinómio de Hermite (Note bem: `he', não `h'. Veja A&S 22.5.18)
     %p[u,v] (z)                    Função de Legendre
     %q[u,v] (z)                    Função de Legendre, segundo tipo
     hstruve[n] (z)                 Função H de Struve H
     lstruve[n] (z)                 Função de L Struve
     %f[p,q] ([], [], expr)         Função Hipergeométrica Generalizada
     gamma()                        Função Gamma
     gammagreek(a,z)                Função gama incompleta
     gammaincomplete(a,z)           Final da função gama incompleta
     slommel
     %m[u,k] (z)                    Função de Whittaker, primeiro tipo
     %w[u,k] (z)                    Função de Whittaker, segundo tipo
     erfc (z)                       Complemento da função erf (função de erros - integral da distribuição normal)
     ei (z)                         Integral de exponencial (?)
     kelliptic (z)                  integral eliptica completa de primeiro tipo (K)
     %d [n] (z)                     Função cilíndrica parabólica


File: maxima.info,  Node: Definições para Funções Especiais,  Prev: Introdução a Funções Especiais,  Up: Funções Especiais

16.2 Definições para Funções Especiais
======================================

 -- Função: airy_ai (<x>)
     A função de Airy Ai, como definida em Abramowitz e Stegun,
     Handbook of Mathematical Functions, Sessão 10.4.

     A equação de Airy `diff (y(x), x, 2) - x y(x) = 0' tem duas
     soluções linearmente independentes, `y = Ai(x)' e `y = Bi(x)'.  A
     derivada de `diff (airy_ai(x), x)' é `airy_dai(x)'.

     Se o argumento `x' for um número real ou um número complexo
     qualquer deles em ponto flutuante , o valor numérico de `airy_ai'
     é retornado quando possível.

     Veja também `airy_bi', `airy_dai', `airy_dbi'.

 -- Função: airy_dai (<x>)
     A derivada da função de Airy Ai `airy_ai(x)'.

     Veja `airy_ai'.

 -- Função: airy_bi (<x>)
     A função de Airy Bi, como definida em Abramowitz e Stegun,
     Handbook of Mathematical Functions, Sessão 10.4, é a segunda
     solução da equação de Airy `diff (y(x), x, 2) - x y(x) = 0'.

     Se o argumento `x' for um número real ou um número complexo
     qualquer deles em ponto flutuante, o valor numérico de `airy_bi' é
     retornado quando possível.  Em outros casos a expressão não
     avaliada é retornada.

     A derivada de `diff (airy_bi(x), x)' é `airy_dbi(x)'.

     Veja `airy_ai', `airy_dbi'.

 -- Função: airy_dbi (<x>)
     A derivada de função de Airy Bi `airy_bi(x)'.

     Veja `airy_ai' e `airy_bi'.

 -- Função: asympa
     `asympa' é um pacote para análise assintótica. O pacote contém
     funções de simplificação para análise assintótica, incluindo as
     funções "grande O" e "pequeno o" que são largamente usadas em
     análises de complexidade e análise numérica.

     `load ("asympa")' chama esse pacote.


 -- Função: bessel (<z>, <a>)
     A função de Bessel de primeiro tipo.

     Essa função está desactualizada.  Escreva `bessel_j (<z>, <a>)' em
     lugar dessa.


 -- Função: bessel_j (<v>, <z>)
     A função de Bessel do primeiro tipo de ordem v e argumento z.

     `bessel_j' calcula o array `besselarray' tal que `besselarray [i]
     = bessel_j [i + v - int(v)] (z)' para `i' de zero a `int(v)'.

     `bessel_j' é definida como
                          inf
                          ====       k  - v - 2 k  v + 2 k
                          \     (- 1)  2          z
                           >    --------------------------
                          /        k! gamma(v + k + 1)
                          ====
                          k = 0

     todavia séries infinitas não são usadas nos cálculos.


 -- Função: bessel_y (<v>, <z>)
     A função de Bessel do segundo tipo de ordem v e argumento z.

     `bessel_y' calcula o array `besselarray' tal que `besselarray [i]
     = bessel_y [i + v - int(v)] (z)' para `i' de zero a `int(v)'.

     `bessel_y' é definida como
                        cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
                        -------------------------------------------
                                       sin(%pi v)

     quando v não for um inteiro.  Quando v for um inteiro n, o limite
     com v aprocimando-se de n é tomado.


 -- Função: bessel_i (<v>, <z>)
     A função de Bessel modificada de primeiro tipo de ordem v e
     argumento z.

     `bessel_i' calcula o array `besselarray' tal que `besselarray [i]
     = bessel_i [i + v - int(v)] (z)' para `i' de zero a `int(v)'.

     `bessel_i' é definida como
                              inf
                              ====   - v - 2 k  v + 2 k
                              \     2          z
                               >    -------------------
                              /     k! gamma(v + k + 1)
                              ====
                              k = 0

     todavia séries infinitas não são usadas nos cálculos.


 -- Função: bessel_k (<v>, <z>)
     A função de Bessel modificada de segundo tipo de ordem v e
     argumento z.

     `bessel_k' calcula o array `besselarray' tal que `besselarray [i]
     = bessel_k [i + v - int(v)] (z)' para `i' de zero a `int(v)'.

     `bessel_k' é definida como
                     %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
                     -------------------------------------------------
                                            2

     quando v não for inteiro.  Se v for um inteiro n, então o limite
     com v aproximando-se de n é tomado.


 -- Variável de opção: besselexpand
     Valor por omissão: `false'

     Expansões de controle de funções de Bessel quando a ordem for a
     metade de um inteiro ímpar.  Nesse caso, as funções de Bessel
     podem ser expandidas em termos de outras funções elementares.
     Quando `besselexpand' for `true', a função de Bessel é expandida.

          (%i1) besselexpand: false$
          (%i2) bessel_j (3/2, z);
                                              3
          (%o2)                      bessel_j(-, z)
                                              2
          (%i3) besselexpand: true$
          (%i4) bessel_j (3/2, z);
                                    2 z   sin(z)   cos(z)
          (%o4)                sqrt(---) (------ - ------)
                                    %pi      2       z
                                            z

 -- Função: scaled_bessel_i (<v>, <z>)
     A função homotética modificada de Bessel de primeiro tipo de ordem
     v e argumento z.  Isto é, scaled_bessel_i(v,z) =
     exp(-abs(z))*bessel_i(v, z). Essa função é particularmente útil
     para calcular bessel_i para grandes valores de z.  Todavia, maxima
     não conhece outra forma muito mais sobre essa função.  Para
     computação simbólica, é provavelmete preferível trabalhar com a
     expressão `exp(-abs(z))*bessel_i(v, z)'.


 -- Função: scaled_bessel_i0 (<z>)
     Idêntica a `scaled_bessel_i(0,z)'.


 -- Função: scaled_bessel_i1 (<z>)
     Idêntica a `scaled_bessel_i(1,z)'.


 -- Função: beta (<x>, <y>)
     A função beta, definida como `gamma(x) gamma(y)/gamma(x + y)'.


 -- Função: gamma (<x>)
     A função gama.

     Veja também `makegamma'.

     A variável `gammalim' controla a simplificação da função gama.

     A constante de Euler-Mascheroni é `%gamma'.


 -- Variável de opção: gammalim
     Valor por omissão: 1000000

     `gammalim' controla a simplificação da função gama para integral e
     argumentos na forma de números racionais.  Se o valor absoluto do
     argumento não for maior que `gammalim', então a simplificação
     ocorrerá.  Note que `factlim' comuta controle de simplificaçcão do
     resultado de `gamma' de um argumento inteiro também.


 -- Função: intopois (<a>)
     Converte <a> em um código de Poisson.


 -- Função: makefact (<expr>)
     Transforma instâncias de funções binomiais, gama, e beta em <expr>
     para factoriais.

     Veja também `makegamma'.


 -- Função: makegamma (<expr>)
     Transforma instâncias de funções binomiais, factorial, e beta em
     <expr> para funções gama.

     Veja também `makefact'.


 -- Função: numfactor (<expr>)
     Retorna o factor numérico multiplicando a expressão <expr>, que
     pode ser um termo simples.

     `content' retorna o máximo divisor comum (mdc) de todos os termos
     em uma adição.

          (%i1) gamma (7/2);
                                    15 sqrt(%pi)
          (%o1)                     ------------
                                         8
          (%i2) numfactor (%);
                                         15
          (%o2)                          --
                                         8


 -- Função: outofpois (<a>)
     Converte <a> de um código de Poisson para uma representação geral.
     Se <a> não for uma forma de Poisson, `outofpois' realiza a
     conversão, i.e., o valor de retorno é `outofpois (intopois (<a>))'.
     Essa função é desse modo um simplificador canónico para adições e
     potências de termos de seno e co-seno de um tipo particular.


 -- Função: poisdiff (<a>, <b>)
     Deriva <a> com relação a <b>.  <b> deve ocorrer somente nos
     argumentos trigonométricos ou somente nos coeficientes.


 -- Função: poisexpt (<a>, <b>)
     Funcionalmente identica a `intopois (<a>^<b>)'.  <b> deve ser um
     inteiro positico.


 -- Função: poisint (<a>, <b>)
     Integra em um senso restrito similarmente (para `poisdiff').
     Termos não periódicos em <b> são diminuídos se <b> estiver em
     argumentos trigonométricos.


 -- Variável de opção: poislim
     Valor por omissão: 5

     `poislim' determina o domínio dos coeficientes nos argumentos de
     funções trigonométricas.  O valor inicial de 5 corresponde ao
     intervalo [-2^(5-1)+1,2^(5-1)], ou [-15,16], mas isso pode ser
     alterado para [-2^(n-1)+1, 2^(n-1)].


 -- Função: poismap (<series>, <sinfn>, <cosfn>)
     mapeará as funções <sinfn> sobre os termos de seno e <cosfn>
     ssobre os termos de co-seno das séries de Poisson dadas.  <sinfn>
     e <cosfn> são funções de dois argumentos que são um coeficiente e
     uma parte trigonométrica de um termo em séries respectivamente.


 -- Função: poisplus (<a>, <b>)
     É funcionalmente identica a `intopois (a + b)'.


 -- Função: poissimp (<a>)
     Converte <a> em séries de Poisson para <a> em representação geral.


 -- Símbolo especial: poisson
     O símbolo `/P/' segue o rótulo de linha de uma expressão contendo
     séries de Poisson.


 -- Função: poissubst (<a>, <b>, <c>)
     Substitue <a> por <b> em <c>.  <c> é uma série de Poisson.

     (1) Quando <B> é uma variável <u>, <v>, <w>, <x>, <y>, ou <z>,
     então <a> deve ser uma expressão linear nessas variáveis (e.g.,
     `6*u + 4*v').

     (2) Quando <b> for outra que não essas variáveis, então <a> deve
     também ser livre dessas variáveis, e além disso, livre de senos ou
     co-senos.

     `poissubst (<a>, <b>, <c>, <d>, <n>)' é um tipo especial d
     substituição que opera sobre <a> e <b> como no tipo (1) acima, mas
     onde <d> é uma série de Poisson, expande `cos(<d>)' e `sin(<d>)'
     para a ordem <n> como provendo o resultado da substituição `<a> +
     <d>' por <b> em <c>.  A idéia é que <d> é uma expansão em termos
     de um pequeno parâmetro.  Por exemplo, `poissubst (u, v, cos(v),
     %e, 3)' retorna `cos(u)*(1 - %e^2/2) - sin(u)*(%e - %e^3/6)'.


 -- Função: poistimes (<a>, <b>)
     É funcionalmente idêntica a `intopois (<a>*<b>)'.


 -- Função: poistrim ()
     é um nome de função reservado que (se o utilizador tiver definido
     uma função com esse nome) é aplicada durante multiplicação de
     Poisson.  Isso é uma função predicada de 6 argumentos que são os
     coeficientes de <u>, <v>, ..., <z> em um termo.  Termos para os
     quais `poistrim' for `true' (para os coeficientes daquele termo)
     são eliminados durante a multiplicação.


 -- Função: printpois (<a>)
     Mostra uma série de Poisson em um formato legível.  Em comum com
     `outofpois', essa função converterá <a> em um código de Poisson
     primeiro, se necessário.


 -- Função: psi [<n>](<x>)
     A derivada de `log (gamma (<x>))' de ordem `<n>+1'.  Dessa forma,
     `psi[0](<x>)' é a primeira derivada, `psi[1](<x>)' é a segunda
     derivada, etc.

     Maxima não sabe como, em geral, calcular um valor numérico de
     `psi', mas Maxima pode calcular alguns valores exatos para
     argumentos racionais.  Muitas variáveis controlam qual intervalo
     de argumentos racionais `psi' irá retornar um valor exato, se
     possível.  Veja `maxpsiposint', `maxpsinegint', `maxpsifracnum', e
     `maxpsifracdenom'.  Isto é, <x> deve localizar-se entre
     `maxpsinegint' e `maxpsiposint'.  Se o valor absoluto da parte
     facionária de <x> for racional e tiver um numerador menor que
     `maxpsifracnum' e tiver um denominador menor que
     `maxpsifracdenom', `psi' irá retornar um valor exato.

     A função `bfpsi' no pacote `bffac' pode calcular valores numéricos.


 -- Variável de opção: maxpsiposint
     Valor por omissão: 20

     `maxpsiposint' é o maior valor positivo para o qual `psi[n](x)'
     irá tentar calcular um valor exato.


 -- Variável de opção: maxpsinegint
     Valor por omissão: -10

     `maxpsinegint' é o valor mais negativo para o qual `psi[n](x)' irá
     tentar calcular um valor exato.  Isto é, se <x> for menor que
     `maxnegint', `psi[n](<x>)' não irá retornar resposta simplificada,
     mesmo se isso for possível.


 -- Variável de opção: maxpsifracnum
     Valor por omissão: 4

     Tomemos <x> como sendo um número racional menor que a unidade e da
     forma `p/q'.  Se `p' for menor que `maxpsifracnum', então
     `psi[<n>](<x>)' não irá tentar retornar um valor simplificado.


 -- Função: specint (exp(- s*<t>) * <expr>, <t>)
     Calcula a transformada de Laplace de <expr> com ralação à variável
     <t>.  O integrando <expr> pode conter funções especiais.

     Se `specint' não puder calcular a integral, o valore de retorno
     pode conter vários símbolos do Lisp, incluindo
     `other-defint-to-follow-negtest', `other-lt-exponential-to-follow',
     `product-of-y-with-nofract-indices', etc.; isso é um erro.

     `demo(hypgeo)' mostra muitos exemplos de transformadas de Laplace
     calculados por `specint'.

     Exemplos:

          (%i1) assume (p > 0, a > 0);
          (%o1)                    [p > 0, a > 0]
          (%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                                     sqrt(%pi)
          (%o2)                     ------------
                                           a 3/2
                                    2 (p + -)
                                           4
          (%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2)) * exp(-p*t), t);
                                             - a/p
                                   sqrt(a) %e
          (%o3)                    ---------------
                                          2
                                         p


 -- Variável de opção: maxpsifracdenom
     Valor por omissão: 4

     Tomemos <x> como sendo um número racional menor que a unidade e da
     forma `p/q'.  Se `q' for maior que `maxpsifracdeonm', então
     `psi[<n>](<x>)' não irá tentar retornar um valor simplificado.



File: maxima.info,  Node: Funções Elípticas,  Next: Limites,  Prev: Funções Especiais,  Up: Top

17 Funções Elípticas
********************

* Menu:

* Introdução a Funções Elípticas e Integrais::
* Definições para Funções Elípticas::
* Definições para Integrais Elípticas::


File: maxima.info,  Node: Introdução a Funções Elípticas e Integrais,  Next: Definições para Funções Elípticas,  Up: Top

17.1 Introdução a Funções Elípticas e Integrais
===============================================

Maxima inclui suporte a funções elípticas Jacobianas e a integrais
elípticas completas e incompletas.  Isso inclui manipulação simbólica
dessas funções e avaliação numérica também.  Definições dessas
funções e muitas de suas propriedades podem ser encontradas em
Abramowitz e Stegun, Capítulos 16-17.  Tanto quanto possível, usamos as
definições e relações dadas aí.

   Em particular, todas as funções elípticas e integrais elípticas usam
o parâmetro m em lugar de módulo k ou o ângulo modular \alpha.  Isso é
uma área onde discordamos de Abramowitz e Stegun que usam o ângulo
modular para as funções elípticas.  As seguintes relações são
verdadeiras: m = k^2 e k = \sin(\alpha)

   As funções elípticas e integrais elípticas estão primariamente
tencionando suportar computação simbólica.  Portanto, a maiora das
derivadas de funções e integrais são conhecidas.  Todavia, se valores
em ponto flutuante forem dados, um resultado em ponto flutuante é
retornado.

   Suporte para a maioria de outras propriedades das funções elípticas e
integrais elípticas além das derivadas não foram ainda escritas.

   Alguns exemplos de funções elípticas:

     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

   Alguns exemplos de integrais elípticas:

     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

   Suporte a funções elípticas e integrais elípticas foi escrito por
Raymond Toy.  Foi colocado sob os termos da Licençã Pública Geral (GPL)
que governa a distribuição do Maxima.


File: maxima.info,  Node: Definições para Funções Elípticas,  Next: Definições para Integrais Elípticas,  Prev: Introdução a Funções Elípticas e Integrais,  Up: Top

17.2 Definições para Funções Elípticas
======================================

 -- Função: jacobi_sn (<u>, <m>)
     A Função elíptica Jacobiana sn(u,m).

 -- Função: jacobi_cn (<u>, <m>)
     A função elíptica Jacobiana cn(u,m).

 -- Função: jacobi_dn (<u>, <m>)
     A função elíptica Jacobiana dn(u,m).

 -- Função: jacobi_ns (<u>, <m>)
     A função elíptica Jacobiana ns(u,m) = 1/sn(u,m).

 -- Função: jacobi_sc (<u>, <m>)
     A função elíptica Jacobiana sc(u,m) = sn(u,m)/cn(u,m).

 -- Função: jacobi_sd (<u>, <m>)
     A função elíptica Jacobiana sd(u,m) = sn(u,m)/dn(u,m).

 -- Função: jacobi_nc (<u>, <m>)
     A função elíptica Jacobiana nc(u,m) = 1/cn(u,m).

 -- Função: jacobi_cs (<u>, <m>)
     A função elíptica Jacobiana cs(u,m) = cn(u,m)/sn(u,m).

 -- Função: jacobi_cd (<u>, <m>)
     A função elíptica Jacobiana cd(u,m) = cn(u,m)/dn(u,m).

 -- Função: jacobi_nd (<u>, <m>)
     A função elíptica Jacobiana nc(u,m) = 1/cn(u,m).

 -- Função: jacobi_ds (<u>, <m>)
     A função elíptica Jacobiana ds(u,m) = dn(u,m)/sn(u,m).

 -- Função: jacobi_dc (<u>, <m>)
     A função elíptica Jacobiana dc(u,m) = dn(u,m)/cn(u,m).

 -- Função: inverse_jacobi_sn (<u>, <m>)
     A inversa da função elíptica Jacobiana sn(u,m).

 -- Função: inverse_jacobi_cn (<u>, <m>)
     A inversa da função elíptica Jacobiana cn(u,m).

 -- Função: inverse_jacobi_dn (<u>, <m>)
     A inversa da função elíptica Jacobiana dn(u,m).

 -- Função: inverse_jacobi_ns (<u>, <m>)
     A inversa da função elíptica Jacobiana ns(u,m).

 -- Função: inverse_jacobi_sc (<u>, <m>)
     A inversa da função elíptica Jacobiana sc(u,m).

 -- Função: inverse_jacobi_sd (<u>, <m>)
     A inversa da função elíptica Jacobiana sd(u,m).

 -- Função: inverse_jacobi_nc (<u>, <m>)
     A inversa da função elíptica Jacobiana nc(u,m).

 -- Função: inverse_jacobi_cs (<u>, <m>)
     A inversa da função elíptica Jacobiana cs(u,m).

 -- Função: inverse_jacobi_cd (<u>, <m>)
     A inversa da função elíptica Jacobiana cd(u,m).

 -- Função: inverse_jacobi_nd (<u>, <m>)
     A inversa da função elíptica Jacobiana nc(u,m).

 -- Função: inverse_jacobi_ds (<u>, <m>)
     A inversa da função elíptica Jacobiana ds(u,m).

 -- Função: inverse_jacobi_dc (<u>, <m>)
     A inversa da função elíptica Jacobiana dc(u,m).


File: maxima.info,  Node: Definições para Integrais Elípticas,  Prev: Definições para Funções Elípticas,  Up: Top

17.3 Definições para Integrais Elípticas
========================================

 -- Função: elliptic_f (<phi>, <m>)
     A integral elíptica incompleta de primeiro tipo, definida como

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Veja também _elliptic_e_ e _elliptic_kc_.


 -- Função: elliptic_e (<phi>, <m>)
     A integral elíptica incompleta de segundo tipo, definida como

     elliptic_e(u, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi) Veja
     também _elliptic_e_ e _elliptic_ec_.


 -- Função: elliptic_eu (<u>, <m>)
     A integral elíptica incompleta de segundo tipo, definida como
     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     onde tau = sn(u,m)

     Isso é relacionado a elliptic_e através de elliptic_eu(u, m) =
     elliptic_e(asin(sn(u,m)),m) Veja também _elliptic_e_.

 -- Função: elliptic_pi (<n>, <phi>, <m>)
     A integral elíptica incompleta de terceiro tipo, definida como

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Somente a derivada em relação a phi é conhecida pelo Maxima.

 -- Função: elliptic_kc (<m>)
     A integral elíptica completa de primeiro tipo, definida como

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Para certos valores de m, o valor da integral é conhecido em
     termos de funções Gama.  Use `makegamma' para avaliar esse valor.

 -- Função: elliptic_ec (<m>)
     A integral elíptica completa de segundo tipo, definida como

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Para certos valores de m, o valor da integral é conhecido em
     termos de funções Gama.  Use `makegamma' para avaliar esse valor.


File: maxima.info,  Node: Limites,  Next: Diferenciação,  Prev: Funções Elípticas,  Up: Top

18 Limites
**********

* Menu:

* Definições para Limites::


File: maxima.info,  Node: Definições para Limites,  Prev: Limites,  Up: Limites

18.1 Definições para Limites
============================

 -- Variável de Opção: lhospitallim
     Valor por omissão: 4

     `lhospitallim' é o máximo número de vezes que a regra L'Hospital é
     usada em `limit'.  Isso evita ciclos infinitos em casos como
     `limit (cot(x)/csc(x), x, 0)'.


 -- Função: limit (<expr>, <x>, <val>, <dir>)
 -- Função: limit (<expr>, <x>, <val>)
 -- Função: limit (<expr>)
     Calcula o limite de <expr> com a variável real <x> aproximando-se
     do valor <val> pela direção <dir>.  <dir> pode ter o valor `plus'
     para um limite pela direita, `minus' para um limite pela esquerda,
     ou pode ser omitido (implicando em um limite em ambos os lados é
     para ser computado).

     `limit' usa os seguintes símbolos especiais: `inf' (infinito
     positivo) e `minf' (infinito negativo).  Em saídas essa função
     pode também usar `und' (undefined - não definido), `ind'
     (indefinido mas associado) e `infinity' (infinito complexo).

     `lhospitallim' é o máximo número de vezes que a regra L'Hospital é
     usada em `limit'.  Isso evita ciclos infinitos em casos como
     `limit (cot(x)/csc(x), x, 0)'.

     `tlimswitch' quando `true' fará o pacote `limit' usar série de
     Taylor quando possível.

     `limsubst' evita que `limit' tente substituições sobre formas
     desconhecidas.  Isso é para evitar erros como `limit (f(n)/f(n+1),
     n, inf)' dando igual a 1.  Escolhendo `limsubst' para `true'
     permitirá tais substituições.

     `limit' com um argumento é muitas vezes chamado em ocasiões para
     simplificar expressões de constantes, por exemplo, `limit (inf-1)'.

     `example (limit)' mostra alguns exemplos.

     Para saber sobre o método utilizado veja Wang, P., "Evaluation of
     Definite Integrals by Symbolic Manipulation", tese de Ph.D., MAC
     TR-92, Outubro de 1971.


 -- Variável de Opção: limsubst
     valor padrão: `false' - evita que `limit' tente substituições sobre
     formas desconhecidas.  Isso é para evitar erros como `limit
     (f(n)/f(n+1), n, inf)' dando igual a 1.  Escolhendo `limsubst'
     para `true' permitirá tais substituições.


 -- Função: tlimit (<expr>, <x>, <val>, <dir>)
 -- Função: tlimit (<expr>, <x>, <val>)
 -- Função: tlimit (<expr>)
     Retorna `limit' com `tlimswitch' escolhido para `true'.


 -- Variável de Opção: tlimswitch
     Valor por omissão: `false'

     Quando `tlimswitch' for `true', fará o pacote `limit' usar série
     de Taylor quando possível.



File: maxima.info,  Node: Diferenciação,  Next: Integração,  Prev: Limites,  Up: Top

19 Diferenciação
****************

* Menu:

* Definições para Diferenciação::


File: maxima.info,  Node: Definições para Diferenciação,  Prev: Diferenciação,  Up: Diferenciação

19.1 Definições para Diferenciação
==================================

 -- Função: antid (<expr>, <x>, <u(x)>)
     Retorna uma lista de dois elementos, tais que uma antiderivada de
     <expr> com relação a <x> pode ser constuída a partir da lista.  A
     expressão <expr> pode conter uma função desconhecida <u> e suas
     derivadas.

     Tome <L>, uma lista de dois elementos, como sendo o valor de
     retorno de `antid'.  Então `<L>[1] + 'integrate (<L>[2], <x>)' é
     uma antiderivada de <expr> com relação a <x>.

     Quando `antid' obtém sucesso inteiramente, o segundo elemento do
     valor de retorno é zero.  De outra forma, o segundo elemento é não
     zero, e o primeiro elemento não zero ou zero.  Se `antid' não pode
     fazer nenhum progresso, o primeiro elemento é zero e o segundo não
     zero.

     `load ("antid")' chama essa função.  O pacote `antid' também
     define as funções `nonzeroandfreeof' e `linear'.

     `antid' está relacionada a `antidiff' como segue.  Tome <L>, uma
     lista de dois elementos, que é o valor de retorno de `antid'.
     Então o valor de retorno de `antidiff' é igual a `<L>[1] +
     'integrate (<L>[2], <x>)' onde <x> é a variável de integração.

     Exemplos:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- Função: antidiff (<expr>, <x>, <u>(<x>))
     Retorna uma antiderivada de <expr> com relação a <x>.  A expressão
     <expr> pode conter uma função desconhecida <u> e suas derivadas.

     Quando `antidiff' obtém sucesso inteiramente, a expressão
     resultante é livre do sinal de integral (isto é, livre do
     substantivo `integrate').  De outra forma, `antidiff' retorna uma
     expressão que é parcialmente ou inteiramente dentro de um sinal de
     um sinal de integral.  Se `antidiff' não pode fazer qualquer
     progresso, o valor de retorno é inteiramente dentro de um sinal de
     integral.

     `load ("antid")' chama essa função.  O pacote `antid' também
     define as funções `nonzeroandfreeof' e `linear'.

     `antidiff' é relacionada a `antid' como segue.  Tome <L>, uma
     lista de dois elementos, como sendo o valor de retorno de `antid'.
     Então o valor de retorno de `antidiff' é igual a `<L>[1] +
     'integrate (<L>[2], <x>)' onde <x> é a variável de integração.

     Exemplos:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- propriedade: atomgrad
     `atomgrad' é a propriedade do gradiente atômico de uma expressão.
     Essa propriedade é atribuída por `gradef'.


 -- Função: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- Função: atvalue (<expr>, <x_1> = <a_1>, <c>)
     Atribui o valor <c> a <expr> no ponto `<x> = <a>'.  Tipicamente
     valores de extremidade são estabelecidos por esse mecanismo.

     <expr> é a função de avaliação, `<f>(<x_1>, ..., <x_m>)', ou uma
     derivada, `diff (<f>(<x_1>, ..., <x_m>), <x_1>, <n_1>, ..., <x_n>,
     <n_m>)' na qual os argumentos da função explicitamente aparecem.
     <n_i> é a ordem de diferenciação com relação a <x_i>.

     O ponto no qual o `atvalue' é estabelecido é dado pela lista de
     equações `[<x_1> = <a_1>, ..., <x_m> = <a_m>]'.  Se existe uma
     variável simples <x_1>, uma única equação pode ser dada sem ser
     contida em uma lista.

     `printprops ([<f_1>, <f_2>, ...], atvalue)' mostra os `atvalues'
     das funções `<f_1>, <f_2>, ...' como especificado por chamadas a
     `atvalue'.  `printprops (<f>, atvalue)' mostra os `atvalues' de
     uma função <f>.  `printprops (all, atvalue)' mostra os `atvalue's
     de todas as funções para as quais `atvalue's são definidos.

     Os simbolos `@1', `@2', ... representam as variáveis <x_1>, <x_2>,
     ... quando `atvalue's são mostrados.

     `atvalue' avalia seus argumentos.  `atvalue' retorna <c>, o
     `atvalue'.

     Exemplos:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Função: cartan -
     O cálculo exterior de formas diferenciais é uma ferramenta básica
     de geometria diferencial desenvolvida por Elie Cartan e tem
     importantes aplicações na teoria das equações diferenciais
     parciais.  O pacote `cartan' implementa as funções `ext_diff' e
     `lie_diff', juntamente com os operadores `~' (produto da cunha) e
     `|' (contração de uma forma com um vector.)  Digite `demo
     (tensor)' para ver uma breve descrição desses comandos juntamente
     com exemplos.

     `cartan' foi implementado por F.B. Estabrook e H.D. Wahlquist.


 -- Função: del (<x>)
     `del (<x>)' representa a diferencial da variável x.

     `diff' retorna uma expressão contendo `del' se uma variável
     independente não for especificada.  Nesse caso, o valor de retorno
     é a então chamada "diferencial total".

     Exemplos:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)


 -- Função: delta (<t>)
     A função Delta de Dirac.

     Correntemente somente `laplace' sabe sobre a função `delta'.

     Exemplo:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e


 -- Variável: dependencies
     Valor por omissão: `[]'

     `dependencies' é a lista de átomos que possuem dependências
     funcionais, atribuídas por `depends' ou `gradef'.  A lista
     `dependencies' é cumulativa: cada chamada a `depends' ou a
     `gradef' anexa ítens adicionais.

     Veja `depends' e `gradef'.


 -- Função: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)
     Declara dependêcias funcionais entre variáveis para o propósito de
     calcular derivadas.  Na ausência de dependêcias declaradas, `diff
     (f, x)' retorna zero.  Se `depends (f, x)' for declarada, `diff
     (f, x)' retorna uma derivada simbólica (isto é, um substantivo
     `diff').

     Cada argumento <f_1>, <x_1>, etc., pode ser o nome de uma variável
     ou array, ou uma lista de nomes.  Todo elemento de <f_i> (talvez
     apenas um elemento simples) é declarado para depender de todo
     elemento de <x_i> (talvez apenas um elemento simples).  Se algum
     <f_i> for o nome de um array ou contém o nome de um array, todos
     os elementos do array dependem de <x_i>.

     `diff' reconhece dependências indirectas estabelecidas por
     `depends' e aplica a regra da cadeia nesses casos.

     `remove (<f>, dependency)' remove todas as dependências declaradas
     para <f>.

     `depends' retorna uma lista de dependências estabelecidas.  As
     dependências são anexadas à variável global `dependencies'.
     `depends' avalia seus argumentos.

     `diff' é o único comando Maxima que reconhece dependências
     estabelecidas por `depends'.  Outras funções (`integrate',
     `laplace', etc.)  somente reconhecem dependências explicitamente
     representadas por seus argumentos.  Por exemplo, `integrate' não
     reconhece a dependência de `f' sobre `x' a menos que
     explicitamente representada como `integrate (f(x), x)'.

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt


 -- Variável de opção: derivabbrev
     Valor por omissão: `false'

     Quando `derivabbrev' for `true', derivadas simbólicas (isto é,
     substantivos `diff') são mostradas como subscritos.  De outra
     forma, derivadas são mostradas na notação de Leibniz `dy/dx'.


 -- Função: derivdegree (<expr>, <y>, <x>)
     Retorna o maior grau de uma derivada da variável dependente <y>
     com relação à variável independente <x> ocorrendo em <expr>.

     Exemplo:
          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2


 -- Função: derivlist (<var_1>, ..., <var_k>)
     Causa somente diferenciações com relação às variáveis indicadas,
     dentro do comando `ev'.


 -- Variável de opção: derivsubst
     Valor por omissão: `false'

     Quando `derivsubst' for `true', uma substiruíção não sintática
     tais como `subst (x, 'diff (y, t), 'diff (y, t, 2))' retorna
     `'diff (x, t)'.


 -- Função: diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)
 -- Função: diff (<expr>, <x>, <n>)
 -- Função: diff (<expr>, <x>)
 -- Função: diff (<expr>)
     Retorna uma derivada ou diferencial de <expr> com relação a alguma
     ou todas as variáveis em <expr>.

     `diff (<expr>, <x>, <n>)' retorna a <n>'ésima derivada de <expr>
     com relação a <x>.

     `diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)' retorna a
     derivada parcial mista de <expr> com relação a <x_1>, ..., <x_m>.
     Isso é equivalente a `diff (... (diff (<expr>, <x_m>, <n_m>) ...),
     <x_1>, <n_1>)'.

     `diff (<expr>, <x>)' retorna a primeira derivada de <expr> com
     relação a uma variável <x>.

     `diff (<expr>)' retorna a diferencial total de <expr>, isto é, a
     soma das derivadas de <expr> com relação a cada uma de suas
     variáveis vezes a diferencial `del' de cada variável.  Nenhuma
     simplificação adicional de `del' é oferecida.

     A forma substantiva de `diff' é requerida em alguns contextos, tal
     como declarando uma equação diferencial.  Nesses casos, `diff'
     pode ser colocado apóstrofo (com `'diff') para retornar a forma
     substantiva em lugar da realização da diferenciação.

     Quando `derivabbrev' for `true', derivadas são mostradas como
     subscritos.  De outra forma, derivadas são mostradas na notação de
     Leibniz, `dy/dx'.

     Exemplos:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     Para o pacote tensor, as seguintes modificações foram incorporadas:

     (1) As derivadas de quaisquer objectos indexados em <expr> terão as
     variáveis <x_i> anexadas como argumentos adicionais.  Então todos
     os índices de derivada serão ordenados.

     (2) As variáveis <x_i> podem ser inteiros de 1 até o valor de uma
     variável `dimension' [valor padrão: 4].  Isso fará com que a
     diferenciação seja concluída com relação aos <x_i>'ésimos membros
     da lista `coordinates' que pode ser escolhida para uma lista de
     nomes de coordenadas, e.g., `[x, y, z, t]'. Se `coordinates' for
     associada a uma variável atômica, então aquela variável subscrita
     por <x_i> será usada para uma variável de diferenciação.  Isso
     permite um array de nomes de coordenadas ou nomes subscritos como
     `X[1]', `X[2]', ... sejam usados.  Se `coordinates' não foram
     atribuídas um valor, então as variáveis seram tratadas como em (1)
     acima.


 -- Símbolo especial: diff
     Quando `diff' está presente como um `evflag' em chamadas para `ev',
     Todas as diferenciações indicadas em `expr' são realizdas.


 -- Função: dscalar (<f>)
     Aplica o d'Alembertiano escalar para a função escalar <f>.

     `load ("ctensor")' chama essa função.


 -- Função: express (<expr>)
     Expande o substantivo do operador diferencial em expressões em
     termos de derivadas parciais.  `express' reconhece os operadores
     `grad', `div', `curl', `laplacian'.  `express' também expande o
     produto do X `~'.

     Derivadas simbólicas (isto é, substantivos `diff') no valor de
     retorno de `express' podem ser avaliadas incluíndo `diff' na
     chamada à função `ev' ou na linha de comando.  Nesse contexto,
     `diff' age como uma `evfun'.

     `load ("vect")' chama essa função.

     Exemplos:

          (%i1) load ("vect")$
          (%i2) grad (x^2 + y^2 + z^2);
                                        2    2    2
          (%o2)                  grad (z  + y  + x )
          (%i3) express (%);
                 d    2    2    2   d    2    2    2   d    2    2    2
          (%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
                 dx                 dy                 dz
          (%i4) ev (%, diff);
          (%o4)                    [2 x, 2 y, 2 z]
          (%i5) div ([x^2, y^2, z^2]);
                                        2   2   2
          (%o5)                   div [x , y , z ]
          (%i6) express (%);
                             d    2    d    2    d    2
          (%o6)              -- (z ) + -- (y ) + -- (x )
                             dz        dy        dx
          (%i7) ev (%, diff);
          (%o7)                    2 z + 2 y + 2 x
          (%i8) curl ([x^2, y^2, z^2]);
                                         2   2   2
          (%o8)                   curl [x , y , z ]
          (%i9) express (%);
                 d    2    d    2   d    2    d    2   d    2    d    2
          (%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
                 dy        dz       dz        dx       dx        dy
          (%i10) ev (%, diff);
          (%o10)                      [0, 0, 0]
          (%i11) laplacian (x^2 * y^2 * z^2);
                                            2  2  2
          (%o11)                laplacian (x  y  z )
          (%i12) express (%);
                   2                2                2
                  d     2  2  2    d     2  2  2    d     2  2  2
          (%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
                    2                2                2
                  dz               dy               dx
          (%i13) ev (%, diff);
                                2  2      2  2      2  2
          (%o13)             2 y  z  + 2 x  z  + 2 x  y
          (%i14) [a, b, c] ~ [x, y, z];
          (%o14)                [a, b, c] ~ [x, y, z]
          (%i15) express (%);
          (%o15)          [b z - c y, c x - a z, a y - b x]


 -- Função: gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)
 -- Função: gradef (<a>, <x>, <expr>)
     Define as derivadas parciais (i.e., os componentes do gradiente)
     da função <f> ou variável <a>.

     `gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)' define
     `d<f>/d<x_i>' como <g_i>, onde <g_i> é uma expressão; <g_i> pode
     ser uma chamada de função, mas não o nome de uma função.  O número
     de derivadas parciais <m> pode ser menor que o número de
     argumentos <n>, nesses casos derivadas são definidas com
     relação a <x_1> até <x_m> somente.

     `gradef (<a>, <x>, <expr>)' define uma derivada de variável <a>
     com relação a <x> como <expr>.  Isso também estabelece a
     dependência de <a> sobre <x> (via `depends (<a>, <x>)').

     O primeiro argumento `<f>(<x_1>, ..., <x_n>)' ou <a> é acompanhado
     de apóstrofo, mas os argumentos restantes <g_1>, ..., <g_m> são
     avaliados.  `gradef' retorna a função ou variável para as quais as
     derivadas parciais são definidas.

     `gradef' pode redefinir as derivadas de funções internas do Maxima.
     Por exemplo, `gradef (sin(x), sqrt (1 - sin(x)^2))' redefine uma
     derivada de `sin'.

     `gradef' não pode definir derivadas parciais para um função
     subscrita.

     `printprops ([<f_1>, ..., <f_n>], gradef)' mostra as derivadas
     parciais das funções <f_1>, ..., <f_n>, como definidas por
     `gradef'.

     `printprops ([<a_n>, ..., <a_n>], atomgrad)' mostra as derivadas
     parciais das variáveis <a_n>, ..., <a_n>, como definidas por
     `gradef'.

     `gradefs' é a lista de funções para as quais derivadas parciais
     foram definidas por `gradef'.  `gradefs' não inclui quaisquer
     variáveis para quais derivadas parciais foram definidas por
     `gradef'.

     Gradientes são necessários quando, por exemplo, uma função não é
     conhecida explicitamente mas suas derivadas primeiras são e isso é
     desejado para obter derivadas de ordem superior.


 -- Variável de sistema: gradefs
     Valor por omissão: `[]'

     `gradefs' é a lista de funções para as quais derivadas parciais
     foram definidas por `gradef'.  `gradefs' não inclui quaisquer
     variáveis para as quais derivadas parciais foram deinidas por
     `gradef'.


 -- Função: laplace (<expr>, <t>, <s>)
     Tenta calcular a transformada de Laplace de <expr> com relação a
     uma variável <t> e parâmetro de transformação <s>.  Se `laplace'
     não pode achar uma solução, um substantivo `'laplace' é retornado.

     `laplace' reconhece em <expr> as funções `delta', `exp', `log',
     `sin', `cos', `sinh', `cosh', e `erf', também `derivative',
     `integrate', `sum', e `ilt'.  Se algumas outras funções estiverem
     presente, `laplace' pode não ser habilitada a calcular a
     tranformada.

     <expr> pode também ser uma equação linear, diferencial de
     coeficiente contante no qual caso o `atvalue' da variável
     dependente é usado.  O requerido `atvalue' pode ser fornecido ou
     antes ou depois da transformada ser calculada.  Uma vez que as
     condições iniciais devem ser especificadas em zero, se um teve
     condições de limite impostas em qualquer outro lugar ele pode
     impor essas sobre a solução geral e eliminar as constantes
     resolvendo a solução geral para essas e substituindo seus valores
     de volta.

     `laplace' reconhece integrais de convolução da forma `integrate
     (f(x) * g(t - x), x, 0, t)'; outros tipos de convoluções não são
     reconhecidos.

     Relações funcionais devem ser explicitamente representadas em
     <expr>; relações implícitas, estabelecidas por `depends', não são
     reconhecidas.  Isto é, se <f> depende de <x> e <y>, `f (x, y)'
     deve aparecer em <expr>.

     Veja também `ilt', a transformada inversa de Laplace.

     Exemplos:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0



File: maxima.info,  Node: Integração,  Next: Equações,  Prev: Diferenciação,  Up: Top

20 Integração
*************

* Menu:

* Introdução a Integração::
* Definições para Integração::
* Introdução a QUADPACK::
* Definições para QUADPACK::


File: maxima.info,  Node: Introdução a Integração,  Next: Definições para Integração,  Prev: Integração,  Up: Integração

20.1 Introdução a Integração
============================

Maxima tem muitas rotinas para realizar integração.  A função
`integrate' faz uso de muitas dessas.  Exite também o pacote `antid',
que manuseia uma função não especificada (e suas derivadas,
certamente).  Para usos numericos, existe um conjunto de integradores
adaptativos de QUADPACK, a saber `quad_qag', `quad_qags', etc., os
quais são descritos sob o tópico `QUADPACK'.  Funções hipergeométricas
estão sendo trabalhadas, veja `specint' para detalhes.  Geralmente
falando, Maxima somente calcula integrais que sejam integráveis em
termos de "funções elementares" (funções racionais, trigonometricas,
logarítmicas, exponenciais, radicais, etc.) e umas poucas extensões
(função de erro, dilogaritmo). Nã consegue calcular integrais em termos
de funções desconhecidas tais como `g(x)' e `h(x)'.


File: maxima.info,  Node: Definições para Integração,  Next: Introdução a QUADPACK,  Prev: Introdução a Integração,  Up: Integração

20.2 Definições para Integração
===============================

 -- Função: changevar (<expr>, <f(x,y)>, <y>, <x>)
     Faz a mudança de variável dada por `<f(x,y)> = 0' em todos os
     integrais que existam em <expr> com integração em relação a <x>.
     A nova variável é <y>.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     Uma expressão contendo uma forma substantiva, tais como as
     instâncias de `'integrate' acima, pode ser avaliada por `ev' com o
     sinalizador `nouns'.  Por exemplo, a expressão retornada por
     `changevar' acima pode ser avaliada por `ev (%o3, nouns)'.

     `changevar' pode também ser usada para alterações nos índices de
     uma soma ou de um produto. No entanto, é de salientar que quando
     seja feita uma alteração a uma soma ou produto, essa mudança
     deverá ser apenas uma deslocação do índice, nomeadamente, `i = j+
     ...', e não uma função de grau superior.  Por exemplo,

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2


 -- Função: dblint (<f>, <r>, <s>, <a>, <b>)
     Esta é uma rotina de integral duplo que foi escrita na linguagem de
     alto nível do Maxima sendo logo traduzida e compilada para
     linguagem de máquina. Use `load (dblint)' para poder usar este
     pacote. Esta função usa o método da regra de Simpson em ambas as
     direções x e y para calcular

          /b /s(x)
          |  |
          |  |    f(x,y) dy dx
          |  |
          /a /r(x)

     A função <f> deve ser uma função traduzida ou compilada de duas
     variáveis, e <r> e <s> devem cada uma ser uma função traduzida ou
     compilada de uma variável, enquanto <a> e <b> devem ser números em
     ponto flutuante.  A rotina tem duas variáveis globais que
     determinam o número de divisões dos intervalos x e y: `dblint_x' e
     `dblint_y', ambas as quais são inicialmente 10, e podem ser
     alteradas independentemente para outros valores inteiros (existem
     `2*dblint_x+1' pontos calculados na direção x , e `2*dblint_y+1'
     na direção y).  A rotina subdivide o eixo X e então para cada
     valor de X primeiro calcula `<r>(x)' e `<s>(x)'; então o eixo Y
     entre `<r>(x)' e `<s>(x)' é subdividido e o integral ao longo do
     eixo Y é executado usando a regra de Simpson; então o integral ao
     longo do eixo X é concluído usando a regra de Simpson com os
     valores da função sendo os integrais em Y.  Esse procedimento pode
     ser numericamente instável por várias razões, mas razoávelmente
     rápido: evite usar este progrma sobre funções altamente
     oscilatórias e funções com singularidades (pólos ou pontos de
     ramificação na região).  Os integrais em Y dependem de quanto
     fragmentados `<r>(x)' e `<s>(x)' sejam; assim, se a distância
     `<s>(x) - <r>(x)' variar rapidamente com X, nesse ponto podrão
     surgir erros substanciais provenientes de truncação com saltos de
     diferentes tamanhos nos vários integrais Y. Pode incrementar-se
     `dblint_x' e `dblint_y' numa tentativa para melhorar a
     convergência da região, com um aumento no tempo de computação.  Os
     valores da função não são guardados, portanto se a função
     desperdiçr muito tempo, terá de esperar pela re-computação cada
     vez que mudar qualquer coisa (pedimos desculpa por esse facto). É
     necessário que as funções <f>, <r>, e <s> sejam ainda traduzidas
     ou compiladas previamente chamando `dblint'.  Isso resultará em
     ordens de magnitude de melhoramentos de velocidade sobre o código
     interpretado em muitos casos!

     `demo (dblint)' executa uma demonstração de `dblint' aplicado a um
     problema exemplo.


 -- Função: defint (<expr>, <x>, <a>, <b>)
     Tenta calcular um integral definido.  `defint' é chamada por
     `integrate' quando limites de integração são especificados, i.e.,
     quando `integrate' é chamado como `integrate (<expr>, <x>, <a>,
     <b>)'.  Dessa forma do ponto de vista do utilizador, isso é
     suficiente para chamar `integrate'.

     `defint' retorna uma expressão simbólica, e executa um dos dois:
     ou calcula o integral ou a forma substantiva do integral.  Veja
     `quad_qag' e funções rellacionadas para aproximação numérica de
     integrais definidos.


 -- Função: erf (<x>)
     Representa a função de erro, cuja derivada é:
     `2*exp(-x^2)/sqrt(%pi)'.


 -- Variável de opção: erfflag
     Valor por omissão: `true'

     Quando `erfflag' é `false', previne `risch' da introdução da
     função `erf' na resposta se não houver nenhum no integrando para
     começar.


 -- Função: ilt (<expr>, <t>, <s>)
     Calcula a transformação inversa de Laplace de <expr> em relação a
     <t> e parâmetro <s>.  <expr> deve ser uma razão de polinómios cujo
     denominador tem somente factores lineares e quadráticos.  Usando a
     funções `laplace' e `ilt' juntas com as funções `solve' ou
     `linsolve' o utilizador pode resolver uma diferencial simples ou
     uma equação integral de convolução ou um conjunto delas.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a


 -- Função: integrate (<expr>, <x>)
 -- Função: integrate (<expr>, <x>, <a>, <b>)
     Tenta símbolicamente calcular o integral de <expr> em relação a
     <x>.  `integrate (<expr>, <x>)' é um integral indefinido, enquanto
     `integrate (<expr>, <x>, <a>, <b>)' é um integral definido, com
     limites de integração <a> e <b>.  Os limites não poderam conter
     <x>, embora `integrate' não imponha essa restrição.  <a> não
     precisa ser menor que <b>.  Se <b> é igual a <a>, `integrate'
     retorna zero.

     Veja `quad_qag' e funções relacionadas para aproximação numérica
     de integrais definidos.  Veja `residue' para computação de
     resíduos (integração complexa).  Veja `antid' para uma forma
     alternativa de calcular integrais indefinidos.

     O integral (uma expressão livre de `integrate') é calculado se
     `integrate' for bem sucedido.  De outra forma o valor de retorno é
     a forma substantiva do integral (o operador com apóstrofo
     `'integrate') ou uma expressão contendo uma ou mais formas
     substantivas.  A forma substantiva de `integrate' é apresentada
     com um símbolo de integração.

     Em algumas circunstâncias isso é útil para construir uma forma
     substantiva manualmente, colocando em `integrate' um apóstrofo,
     e.g., `'integrate (<expr>, <x>)'.  Por exemplo, o integral pode
     depender de alguns parâmetos que não estão ainda calculados.  A
     forma substantiva pode ser aplicada a seus argumentos por `ev
     (<i>, nouns)' onde <i> é a forma substantiva de interesse.

     `integrate' calcula integrais definidos separadamente dos
     indefinidos, e utiliza uma gama de heurísticas para simplificar
     cada caso.  Casos especiais de integrais definidos incluem limites
     de integração iguais a zero ou infinito (`inf' ou `minf'),
     funções trigonométricas com limites de integração iguais a zero e
     `%pi' ou `2 %pi', funções racionais, integrais relacionados com as
     definições das funções `beta' e `psi', e alguns integrais
     logarítmicos e trigonométricos.  O processamento de funções
     racionais pode incluir cálculo de resíduos.  Se um caso especial
     aplicável não for encontrado, será feita uma tentativa para
     calcular o integral indefinido e avaliá-lo nos limites de
     integração.  Isso pode incluir o cálculo de um limite nos casos em
     que um dos limites do integral for para infinito ou menos
     infinito; veja também `ldefint'.

     Casos especiais de integrais indefinidos incluem funções
     trigonométricas, exponenciais e funções logarítmicas, e funções
     racionais.  `integrate' pode também fazer uso de uma pequena
     tabela de integais elementares.

     `integrate' pode realizar uma mudança de variável se o integrando
     tiver a forma `f(g(x)) * diff(g(x), x)'.  `integrate' tenta achar
     uma subexpressão `g(x)' de forma que a derivada de `g(x)' divida o
     integrando.  Essa busca pode fazer uso de derivadas definidas pela
     função `gradef'.  Veja também `changevar' e `antid'.

     Se nenhum dos procedimentos heurísticos conseguir calcular o
     integral indefinido, o algoritmo de Risch é executado. O
     sinalizador `risch' pode ser utilizado como um parâmetro para
     `ev', ou na linha de comando, nomeadamente, `ev (integrate (<expr>,
     <x>), risch)' ou `integrate (<expr>, <x>), risch'.  Se `risch'
     estiver presente, `integrate' chamará a função `risch' sem tentar
     heurísticas primeiro. Veja também `risch'.

     `integrate' trabalha somente com relações funcionais representadas
     explicitamente com a notação `f(x)'.  `integrate' não respeita
     dependências implicitas estabelecidas pela função `depends'.
     `integrate' pode necessitar conhecer alguma propriedade de um
     parâmetro no integrando.  `integrate' irá primeiro consultar a
     base de dados do `assume', e , se a variável de interesse não está
     lá, `integrate' perguntará ao utilizador.  Dependendo da pergunta,
     respostas adequadas são `yes;' ou `no;', ou `pos;', `zero;', ou
     `neg;'.

     `integrate' não é, por padrão, declarada ser linear.  Veja
     `declare' e `linear'.

     `integrate' tenta integração por partes somente em uns poucos
     casos especiais.

     Exemplos:

        * Integrais definidos e indefinidos elementares.

               (%i1) integrate (sin(x)^3, x);
                                          3
                                       cos (x)
               (%o1)                   ------- - cos(x)
                                          3
               (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                                2    2
               (%o2)                    - sqrt(b  - x )
               (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                              %pi
                                          3 %e      3
               (%o3)                      ------- - -
                                             5      5
               (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                           sqrt(%pi)
               (%o4)                       ---------
                                               2

        * Uso de `assume' e dúvida interativa.

               (%i1) assume (a > 1)$
               (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
                   2 a + 2
               Is  -------  an integer?
                      5

               no;
               Is  2 a - 3  positive, negative, or zero?

               neg;
                                                  3
               (%o2)                  beta(a + 1, - - a)
                                                  2

        * Mudança de variável.  Existem duas mudanças de variável nesse
          exemplo: uma usando a derivada estabelecida por `gradef', e
          uma usando a derivação `diff(r(x))' de uma função não
          especificada `r(x)'.

               (%i3) gradef (q(x), sin(x**2));
               (%o3)                         q(x)
               (%i4) diff (log (q (r (x))), x);
                                     d               2
                                    (-- (r(x))) sin(r (x))
                                     dx
               (%o4)                ----------------------
                                           q(r(x))
               (%i5) integrate (%, x);
               (%o5)                     log(q(r(x)))

        * O resultado contém a forma substantiva `'integrate'.  Neste
          exemplo, Maxima pode extrair um factor do denominador de uma
          função racional, mas não pode factorizar o restante ou de
          outra forma achar o seu integral.  `grind' mostra a forma
          substantiva `'integrate' no resultado.  Veja também
          `integrate_use_rootsof' para mais informaçes sobre integrais
          de funções racionais.

               (%i1) expand ((x-4) * (x^3+2*x+1));
                                   4      3      2
               (%o1)              x  - 4 x  + 2 x  - 7 x - 4
               (%i2) integrate (1/%, x);
                                             /  2
                                             [ x  + 4 x + 18
                                             I ------------- dx
                                             ]  3
                                log(x - 4)   / x  + 2 x + 1
               (%o2)            ---------- - ------------------
                                    73               73
               (%i3) grind (%);
               log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$

        * Definindo uma função em termos de um integral.  O corpo de
          uma função não é avaliado quando a função é definida.  Dessa
          forma o corpo de `f_1' nesse exemplo contém a forma
          substantiva de `integrate'.  O operador de doi apóstrofos
          seguidos `''' faz com que o integral seja avaliado, e o
          resultado se transforme-se no corpo de `f_2'.

               (%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                                    3
               (%o1)           f_1(a) := integrate(x , x, 1, a)
               (%i2) ev (f_1 (7), nouns);
               (%o2)                          600
               (%i3) /* Note parentheses around integrate(...) here */
                     f_2 (a) := ''(integrate (x^3, x, 1, a));
                                                  4
                                                 a    1
               (%o3)                   f_2(a) := -- - -
                                                 4    4
               (%i4) f_2 (7);
               (%o4)                          600


 -- Variável de sistema: integration_constant_counter
     Valor por omissão: 0

     `integration_constant_counter' é um contador que é actualizado a
     cada vez que uma constante de integração (nomeada pelo Maxima, por
     exemplo, `integrationconstant1') é introduzida numa expressão
     obtida após a integração indefinida de uma equação.


 -- Variável de opção: integrate_use_rootsof
     Valor por omissão: `false'

     Quando `integrate_use_rootsof' é `true' e o denominador de uma
     função racional não pode ser factorizado, `integrate' retorna o
     integral em uma forma que é uma soma sobre as raízes (não
     conhecidas ainda) do denominador.

     Por exemplo, com `integrate_use_rootsof' escolhido para `false',
     `integrate' retorna um integral não resolvido de uma função
     racional na forma substantiva:

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Agora vamos escolher o sinalizador para ser true e a parte não
     resolvida do integral será escrito como uma soma sobre as raízes
     do denominador da função racional:

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                3    2
                %r4 in rootsof(x  - x  + 1)
          (%o4) ----------------------------------------------------------
                         7

                                                                       2 x + 1
                                                   2            5 atan(-------)
                                              log(x  + x + 1)          sqrt(3)
                                            - --------------- + ---------------
                                                    14             7 sqrt(3)

     Alternativamente o utilizador pode calcular as raízes do
     denominador separadamente, e então expressar o integrando em
     termos dessas raízes, e.g., `1/((x - a)*(x - b)*(x - c))' ou
     `1/((x^2 - (a+b)*x + a*b)*(x - c))' se o denominador for um
     polinómio cúbico.  Algumas vezes isso ajudará Maxima a obter
     resultados mais úteis.


 -- Função: ldefint (<expr>, <x>, <a>, <b>)
     Tenta calcular o integral definido de <expr> pelo uso de `limit'
     para avaliar o integral indefinido <expr> em relação a <x> no
     limite superior <b> e no limite inferior <a>.  Se isso falha para
     calcular o integral definido, `ldefint' retorna uma expressão
     contendo limites como formas substantivas.

     `ldefint' não é chamada por `integrate', então executando `ldefint
     (<expr>, <x>, <a>, <b>)' pode retornar um resultado diferente de
     `integrate (<expr>, <x>, <a>, <b>)'.  `ldefint' sempre usa o mesmo
     método para avaliar o integral definido, enquanto `integrate' pode
     utilizar várias heurísticas e pode reconhecer alguns casos
     especiais.


 -- Função: potential (<givengradient>)
     O cálculo faz uso da variável global `potentialzeroloc[0]' que
     deve ser `nonlist' ou da forma

          [indeterminatej=expressãoj, indeterminatek=expressãok, ...]

     O formador sendo equivalente para a expressão nonlist para todos
     os lados direitos-manuseados mais tarde.  Os lados direitos
     indicados são usados como o limite inferior de integração.  O
     sucesso das integrações pode depender de seus valores e de sua
     ordem.  `potentialzeroloc' é inicialmente escolhido para 0.


 -- Função: residue (<expr>, <z>, <z_0>)
     Calcula o resíduo no plano complexo da expressão <expr> quando a
     variável <z> assumes o valor <z_0>.  O resíduo é o coeficiente de
     `(<z> - <z_0>)^(-1)' nas séries de Laurent para <expr>.

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6


 -- Função: risch (<expr>, <x>)
     Integra <expr> em relação a <x> usando um caso transcendental do
     algoritmo de Risch.  (O caso algébrico do algoritmo de Risch foi
     implementado.)  Isso actualmente manuseia os casos de exponenciais
     aninhadas e logaritmos que a parte principal de `integrate' não
     pode fazer.  `integrate' irá aplicar automaticamente `risch' se
     dados esses casos.

     `erfflag', se `false', previne `risch' da introdução da função
     `erf' na resposta se não for achado nenhum no integrando para
     começar.

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)


 -- Função: tldefint (<expr>, <x>, <a>, <b>)
     Equivalente a `ldefint' com `tlimswitch' escolhido para `true'.



File: maxima.info,  Node: Introdução a QUADPACK,  Next: Definições para QUADPACK,  Prev: Definições para Integração,  Up: Integração

20.3 Introdução a QUADPACK
==========================

QUADPACK é uma colecção de funções para aálculo numérico de integrais
definidos unidimensionais.  O pacote QUADPACK resultou da junção de um
projeto de R. Piessens (1), E. de Doncker (2), C. Ueberhuber (3), e D.
Kahaner (4).

   A biblioteca QUADPACK inclída no Maxima é uma tradução automática
(feita através do programa `f2cl') do código fonte em de QUADPACK como
aparece na SLATEC Common Mathematical Library, Versão 4.1 (5).  A
biblioteca Fortran SLATEC é datada de Julho de 1993, mas as funções
QUADPACK foram escritas alguns anos antes.  Existe outra versão de
QUADPACK em Netlib (6); não está claro no que aquela versão difere da
versão existente em SLATEC.

   As funções QUADPACK incluídas no Maxima são toda automáticas, no
sentido de que essas funções tentam calcular um resultado para uma
precisão específica, requerendo um número não especificado de
avaliações de função.  A tradução do Lisp do Maxima da iblioteca
QUADPACK também inclui algumas funçe~s não automáticas, mas elas não
são expostas a nível de Maxima.

   Informação adicionalsobre a bilioteca QUADPACK pode ser encontrada
no livro do QUADPACK (7).

20.3.1 Overview
---------------

`quad_qag'
     Integração de uma função genérica sobre um intervalo finito.
     `quad_qag' implementa um integrador adaptativo globalmente simples
     usando a estratégia de Aind (Piessens, 1973).  O chamador pode
     escolher entre 6 pares de formulas da quadratura de Gauss-Kronrod
     para a componente de avaliação da regra.  As regras de alto grau
     são adequadas para integrandos fortemente oscilantes.

`quad_qags'
     Integração de uma função genérica sob um intervalo finito.
     `quad_qags' implementa subdivisão de intervalos globalmente
     adaptativos com extrapolação (de Doncker, 1978) por meio do
     algoritmo de Epsilon (Wynn, 1956).

`quad_qagi'
     Integração de uma função genérica  sobre um intervalo finito ou
     semi-finito.  O intervalo é mapeado sobre um intervalo finito e
     então a mesma estratégia de `quad_qags' é aplicada.

`quad_qawo'
     Integração de cos(omega x) f(x) ou sin(omega x) f(x) sobre um
     intervalo finito, onde omega é uma constante.  A componente de
     avaliação da regra é baseada na técnica modificada de
     Clenshaw-Curtis.  `quad_qawo' aplica subdivisão adaptativa com
     extrapolação, similar a `quad_qags'.

`quad_qawf'
     Calcula uma transformação de co-seno de Fourier ou de um seno de
     Fourier sobre um intervalo semi-finito.  O mesmo aproxima como
     `quad_qawo' aplicado sobre intervalos finitos sucessivos, e
     aceleração de convergência por meio d algorítimo de Epsilon (Wynn,
     1956) aplicado a séries de contribuições de integrais.

`quad_qaws'
     Integraçào de w(x) f(x) sobre um intervalo finito [a, b], onde w é
     uma função da forma (x - a)^alpha (b - x)^beta v(x) e v(x) é 1 ou
     log(x - a) ou log(b - x) ou log(x - a) log(b - x), e alpha > -1 e
     beta > -1.  Auma estratégia de subdivisão adaptativa é aplicada,
     com integração modificada de Clenshaw-Curtis sobre os
     subintervalos que possuem a ou b.

`quad_qawc'
     Calcula o valor principal de Cauchy de f(x)/(x - c) sobre um
     intervalo finito (a, b) e um c especificado.  A estratégia é
     globalmente adaptativa, e a integração modificada de
     Clenshaw-Curtis é usada sobre subamplitudes que possuírem o ponto
     x = c.

   ---------- Footnotes ----------

   (1) Applied Mathematics and Programming Division, K.U. Leuven

   (2) Applied Mathematics and Programming Division, K.U. Leuven

   (3) Institut fur Mathematik, T.U. Wien

   (4) National Bureau of Standards, Washington, D.C., U.S.A

   (5) http://www.netlib.org/slatec

   (6) http://www.netlib.org/quadpack

   (7) R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, e D.K.
Kahaner.  QUADPACK: A Subroutine Package for Automatic Integration.
Berlin: Springer-Verlag, 1983, ISBN 0387125531.


File: maxima.info,  Node: Definições para QUADPACK,  Prev: Introdução a QUADPACK,  Up: Integração

20.4 Definições para QUADPACK
=============================

 -- Função: quad_qag (<f(x)>, <x>, <a>, <b>, <chave>, <epsrel>,
          <limite>)
 -- Função: quad_qag (<f>, <x>, <a>, <b>, <chave>, <epsrel>, <limite>)
     Integração de uma função genérica sobre um intervalo finito.
     `quad_qag' implementa um integrador adaptativo globalmente simples
     usando a estratégia de Aind (Piessens, 1973).  O chamador pode
     escolher entre 6 pares de fórmulas da quadratura de Gauss-Kronrod
     para a componente de avaliação da regra.  As regras de alto nível
     são adequadas para integrandos fortemente oscilatórios.

     `quad_qag' calcula o integral

     integrate (f(x), x, a, b)

     A função a ser integrada é <f(x)>, com variável dependente <x>, e
     a função é para ser integrada entre os limites <a> e <b>.  <chave>
     é o integrador a ser usado e pode ser um inteiro entre 1 e 6,
     inclusive.  O valor de <chave> selecciona a ordem da regra de
     integração de Gauss-Kronrod.  Regra de alta ordem são adequadas
     para integrandos fortemente oscilatórios.

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     A integração numérica é concluída adaptativamente pela subdivisão a
     região de integração até que a precisão desejada for completada.

     Os argumentos opcionais <epsrel> e <limite> são o erro relativo
     desejado e o número máximo de subintervalos respectivamente.
     <epsrel> padrão em 1e-8 e <limite> é 200.

     `quad_qag' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

    `0'
          se nenhum problema foi encontrado;

    `1'
          se foram utilizados muitos subintervalos;

    `2'
          se for detectato um erro de arredondamento excessivo;

    `3'
          se o integrando se comportar muito mal;

    `6'
          se a entrada não for válida.


     Exemplos:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9

 -- Função: quad_qags (<f(x)>, <x>, <a>, <b>, <epsrel>, <limite>)
 -- Função: quad_qags (<f>, <x>, <a>, <b>, <epsrel>, <limite>)
     Integração de uma função geral sobre um intervalo finito.
     `quad_qags' implementa subdivisão de intervalo globalmente
     adaptativa com extrapolação (de Doncker, 1978) através do
     algoritmo de (Wynn, 1956).

     `quad_qags' calcula o integral

     integrate (f(x), x, a, b)

     A função a ser integrada é <f(x)>, com variável dependente <x>, e
     a função é para ser integrada entre os limites <a> e <b>.

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     Os argumentos opcionais <epsrel> e <limite> são o erro relativo
     desejado e o número máximo de subintervalos, respectivamente.
     <epsrel> padrão em 1e-8 e <limite> é 200.

     `quad_qags' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

    `0'
          nenhum problema foi encontrado;

    `1'
          foram utilizados muitos subintervalos;

    `2'
          foi detectato um erro de arredondamento excessivo;

    `3'
          o integrando comporta-se muito mal;

    `4'
          não houve convergência

    `5'
          o integral provavelmente é divergente, o converge lentamente

    `6'
          a entrada não foi válida.

     Exemplos:

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0 ,1);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

     Note que `quad_qags' é mais preciso e eficiente que `quad_qag'
     para esse integrando.


 -- Função: quad_qagi (<f(x)>, <x>, <a>, <inftype>, <epsrel>, <limite>)
 -- Função: quad_qagi (<f>, <x>, <a>, <inftype>, <epsrel>, <limite>)
     Integração de uma função genérica sobre um intervalo finito ou
     semi-finito.  O intervalo é mapeado sobre um intervalo finito e
     então a mesma estratégia que em `quad_qags' é aplicada.

     `quad_qagi' avalia um dos seguintes integrais

     integrate (f(x), x, minf, inf)

     integrate (f(x), x, minf, a)

     integrate (f(x), x, a, minf, inf)

     usando a rotina Quadpack QAGI.  A função a ser integrada é <f(x)>,
     com variável dependente <x>, e a função é para ser integrada sobre
     um intervalo infinito.

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     O parâmetro <inftype> determina o intervalo de integração como
     segue:

    `inf'
          O intervalo vai de <a> ao infinito positivo.

    `minf'
          O intervalo vai do infinito negativo até <a>.

    `both'
          O intervalo corresponde a toda reta real.

     Os argumentos opcionais <epsrel> e <limite> são o erro relativo
     desejado e o número maximo de subintervalos, respectivamente.
     <epsrel> padrão para 1e-8 e <limite> é 200.

     `quad_qagi' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

    `0'
          nenhum problema foi encontrado;

    `1'
          foram utilizados muitos subintervalos;

    `2'
          foi detectato um erro de arredondamento excessivo;

    `3'
          o integrando comporta-se muito mal;

    `4'
          não houve convergência

    `5'
          o integral provavelmente é divergente, o converge lentamente

    `6'
          a entrada não foi válida.


     Exemplos:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32


 -- Função: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, <epsrel>, <limite>)
 -- Função: quad_qawc (<f>, <x>, <c>, <a>, <b>, <epsrel>, <limite>)
     Calcula o valor principal de Cauchy de f(x)/(x - c) over a finite
     interval.  A estratégia é globalmente adaptativa, e a
     integração de Clenshaw-Curtis modificada é usada sobre as
     subamplitudes que possuírem o ponto x = c.

     `quad_qawc' calcula o valor principal de Cauchy de

     integrate (f(x)/(x - c), x, a, b)

     usando a rotina Quadpack QAWC.  A função a ser integrada é
     `<f(x)>/(<x> - <c>)', com variável dependente <x>, e a função é
     para ser integrada sobre o intervalo que vai de <a> até <b>.

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     Os argumentos opcionais <epsrel> e <limite> são o erro relativo
     desejado e o máximo número de subintervalos, respectivamente.
     <epsrel> padrão para 1e-8 e <limite> é 200.

     `quad_qawc' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valoor de retorno) pode ter
     os valores:

    `0'
          nenhum problema foi encontrado;

    `1'
          foram utilizados muitos subintervalos;

    `2'
          foi detectato um erro de arredondamento excessivo;

    `3'
          o integrando comporta-se muito mal;

    `6'
          a entrada não foi válida.


     Exemplos:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1), x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                   3 alpha                       3 alpha
                   -------                       -------
                      2            alpha/2          2          alpha/2
                2 4        atan(4 4       )   2 4        atan(4       )   alpha
              - --------------------------- - -------------------------)/2
                          alpha                        alpha
                       2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917


 -- Função: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, <epsabs>,
          <limit>, <maxp1>, <limlst>)
 -- Função: quad_qawf (<f>, <x>, <a>, <omega>, <trig>, <epsabs>,
          <limit>, <maxp1>, <limlst>)
     Calcula uma transformação de co-seno de Fourier ou de um seno de
     Fourier sobre um intervalo semi-finito.  usando a função QAWF do
     pacote Quadpack.  A mesma aproxima como em `quad_qawo' quando
     aplicada sobre intervalos finitos sucessivos, e aceleração de
     convergência por meio d algorítimo de Epsilon (Wynn, 1956)
     aplicado a séries de contribuições de integrais.

     `quad_qawf' calcula o integral

     integrate (f(x)*w(x), x, a, inf)

     A função peso w é seleccionada por <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     Os argumentos opcionais são:

    <epsabs>
          Erro absoluto de aproximação desejado.  Padrão é 1d-10.

    <limit>
          Tamanho de array interno de trabalho.  (<limit> - <limlst>)/2
          é o maximo número de subintervalos para usar.  O Padrão é 200.

    <maxp1>
          O número máximo dos momentos de Chebyshev.  Deve ser maior
          que 0.  O padrão é 100.

    <limlst>
          Limite superior sobre número de ciclos.  Deve ser maior ou
          igual a 3.  O padrão é 10.

     <epsabs> e <limit> são o erro relativo desejado e o número maximo
     de subintervalos, respectivamente.  <epsrel> padrão para 1e-8 e
     <limit> é 200.

     `quad_qawf' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

    `0'
          nenhum problema foi encontrado;

    `1'
          foram utilizados muitos subintervalos;

    `2'
          foi detectato um erro de arredondamento excessivo;

    `3'
          o integrando comporta-se muito mal;

    `6'
          a entrada não foi válida.


     Exemplos:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714


 -- Função: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>,
          <epsabs>, <limite>, <maxp1>, <limlst>)
 -- Função: quad_qawo (<f>, <x>, <a>, <b>, <omega>, <trig>, <epsabs>,
          <limite>, <maxp1>, <limlst>)
     Integração de cos(omega x) f(x) ou sin(omega x) f(x) sobre um
     intervalo finito, onde omega é uma constante.  A componente de
     avaliação da regra é baseada na técnica modificada de
     Clenshaw-Curtis.  `quad_qawo' aplica subdivisão adaptativa com
     extrapolação, similar a `quad_qags'.

     `quad_qawo' calcula o integral usando a rotina Quadpack QAWO:

     integrate (f(x)*w(x), x, a, b)

     A função peso w é seleccionada por <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     Os argumentos opcionais são:

    <epsabs>
          Erro absoluto desejado de aproximação.  O Padrão é 1d-10.

    <limite>
          Tamanho do array interno de trabalho.  (<limite> -
          <limlst>)/2 é o número máximo de subintervalos a serem
          usados.  Default é 200.

    <maxp1>
          Número máximo dos momentos de Chebyshev.  Deve ser maior que
          0.  O padrão é 100.

    <limlst>
          Limite superior sobre o número de ciclos.  Deve ser maior que
          ou igual a 3.  O padrão é 10.

     <epsabs> e <limite> são o erro relativo desejado e o número máximo
     de subintervalos, respectivamente.  <epsrel> o padrão é 1e-8 e
     <limite> é 200.

     `quad_qawo' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

    `0'
          nenhum problema foi encontrado;

    `1'
          foram utilizados muitos subintervalos;

    `2'
          foi detectato um erro de arredondamento excessivo;

    `3'
          o integrando comporta-se muito mal;

    `6'
          a entrada não foi válida.


     Exemplos:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x), x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716


 -- Função: quad_qaws (<f(x)>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          <epsabs>, <limite>)
 -- Função: quad_qaws (<f>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          <epsabs>, <limite>)
     Integração de w(x) f(x) sobre um intervalo finito, onde w(x) é uma
     certa função algébrica ou logarítmica.  Uma estratégia de
     subdivisão globalmente adaptativa é aplicada, com integração
     modificada de Clenshaw-Curtis sobre os subintervalos que possuírem
     os pontos finais dos intervalos de integração.

     `quad_qaws' calcula o integral usando a rotina Quadpack QAWS:

     integrate (f(x)*w(x), x, a, b)

     A função peso w é seleccionada por <wfun>:

    `1'
          w(x) = (x - a)^alpha (b - x)^beta

    `2'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a)

    `3'
          w(x) = (x - a)^alpha (b - x)^beta log(b - x)

    `4'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)

     O integrando pode ser especificado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     O argumentos opcionais são:

    <epsabs>
          Erro absoluto desejado de aproximação.  O padrão é 1d-10.

    <limite>
          Tamanho do array interno de trabalho.  (<limite> -
          <limlst>)/2 é o número máximo de subintervalos para usar.  O
          padrão é 200.

     <epsabs> e <limit> são o erro relativo desejado e o número máximo
     de subintervalos, respectivamente.  <epsrel> o padrão é 1e-8 e
     <limite> é 200.

     `quad_qaws' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

    `0'
          nenhum problema foi encontrado;

    `1'
          foram utilizados muitos subintervalos;

    `2'
          foi detectato um erro de arredondamento excessivo;

    `3'
          o integrando comporta-se muito mal;

    `6'
          a entrada não foi válida.


     Exemplos:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829



File: maxima.info,  Node: Equações,  Next: Equações Diferenciais,  Prev: Integração,  Up: Top

21 Equações
***********

* Menu:

* Definições para Equações::


File: maxima.info,  Node: Definições para Equações,  Prev: Equações,  Up: Equações

21.1 Definições para Equações
=============================

 -- Variável: %rnum_list
     Valor por omissão: `[]'

     `%rnum_list' é a lista de variáveis introduzidas em soluções por
     `algsys'.  `%r' variáveis São adicionadas a `%rnum_list' na ordem
     em que forem criadas.  Isso é conveniente para fazer
     substituições dentro da solução mais tarde.  É recomendado usar
     essa lista em lugar de fazer `concat ('%r, j)'.


 -- Variável: algexact
     Valor por omissão: `false'

     `algexact' afecta o comportamento de `algsys' como segue:

     Se `algexact' é `true', `algsys' sempre chama `solve' e então usa
     `realroots' sobre falhas de `solve'.

     Se `algexact' é `false', `solve' é chamada somente se o eliminante
     não for de uma variável, ou se for uma quadrática ou uma
     biquadrada.

     Dessa forma `algexact: true' não garante soluções exactas, apenas
     que `algsys' tentará primeiro pegar soluções exactas, e somente
     retorna aproximações quando tudo mais falha.


 -- Função: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Função: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Resolve polinómios simultâneos <expr_1>, ..., <expr_m> ou
     equações polinômiais <eqn_1>, ..., <eqn_m> para as variáveis
     <x_1>, ..., <x_n>.  Uma expressão <expr> é equivalente a uma
     equação `<expr> = 0'.  Pode existir mais equações que variáveis ou
     vice-versa.

     `algsys' retorna uma lista de soluções, com cada solução dada com
     uma lista de valores de estado das equações das variáveis <x_1>,
     ..., <x_n> que satisfazem o sistema de equações.  Se `algsys' não
     pode achar uma solução, uma lista vazia `[]' é retornada.

     Os símbolos `%r1', `%r2', ..., são introduzidos tantos quantos
     forem necessários para representar parâmetros arbitrários na
     solução; essas variáveis são também anexadas à lista `%rnum_list'.

     O método usado é o seguinte:

     (1) Primeiro as equações são factorizaadas e quebradas em
     subsistemas.

     (2) Para cada subsistema <S_i>, uma equação <E> e uma variável <x>
     são seleccionados.  A variável é escolhida para ter o menor grau
     não zero.  Então a resultante de <E> e <E_j> em relação a <x> é
     calculada para cada um das equações restantes <E_j> nos
     subsistemas <S_i>.  Isso retorna um novo subsistema <S_i'> em umas
     poucas variáveis, como <x> tenha sido eliminada.  O processo agora
     retorna ao passo (1).

     (3) Eventualmente, um subsistema consistindo de uma equação
     simples é obtido.  Se a equação é de várias variáveis e
     aproximações na forma de números em ponto flutuante nã tenham sido
     introduzidas, então `solve' é chamada para achar uma solução
     exacta.

     Em alguns casos, `solve' não está habilitada a achar uma
     solução, ou se isso é feito a solução pode ser uma expressão
     expressão muito larga.

     Se a equação é de uma única variável e é ou linear, ou quadrática,
     ou biquadrada, então novamente `solve' é chamada se aproximações
     não tiverem sido introduzidas.  Se aproximações tiverem sido
     introduzidas ou a equação não é de uma única variável e nem tão
     pouco linear, quadratica, ou biquadrada, então o comutador
     `realonly' é `true', A função `realroots' é chamada para achar o
     valor real das soluções.  Se `realonly' é `false', então
     `allroots' é chamada a qual procura por soluções reais e complexas.

     Se `algsys' produz uma solução que tem poucos digitos
     significativos que o requerido, o utilizador pode escolher o valor
     de `algepsilon' para um valor maior.

     Se `algexact' é escolhido para `true', `solve' será sempre chamada.

     (4) Finalmente, as soluções obtidas no passo (3) são substituídas
     dentro dos níveis prévios e o processo de solução retorna para (1).

     Quando `algsys' encontrar uma equação de várias variáveis que
     contém aproximações em ponto flutuante (usualmente devido a suas
     falhas em achar soluções exactas por um estágio mais fácil), então
     não tentará aplicar métodos exatos para tais equações e em lugar
     disso imprime a mensagem: "`algsys' cannot solve - system too
     complicated."

     Interações com `radcan' podem produzir expressões largas ou
     complicadas.  Naquele caso, pode ser possível isolar partes do
     resultado com `pickapart' ou `reveal'.

     Ocasionalmente, `radcan' pode introduzir uma unidade imaginária
     `%i' dentro de uma solução que é actualmente avaliada como real.

     Exemplos:

     ++
          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3


 -- Função: allroots (<expr>)
 -- Função: allroots (<eqn>)
     Calcula aproximações numéricas de raízes reais e complexas do
     polinómio <expr> ou equação polinômial <eqn> de uma variável.

     O sinalizador `polyfactor' quando `true' faz com que `allroots'
     factore o polinómio sobre os números reais se o polinómio for
     real, ou sobre os números complexos, se o polinómio for complexo.

     `allroots' pode retornar resultados imprecisos no caso de
     múltiplas raízes.  Se o polinómio for real, `allroots (%i*<p>)')
     pode retornar aproximações mais precisas que `allroots (<p>)',
     como `allroots' invoca um algoritmo diferente naquele caso.

     `allroots' rejeita expressoões que não sejam polinómios.  Isso
     requer que o numerador após a classificação (`rat''ing) poderá ser
     um polinómio, e isso requer que o denominador seja quando muito um
     número complexo.  Com esse tipo resultado `allroots' irá sempre
     produzir uma expressão equivalente (mas factorizada), se
     `polyfactor' for `true'.

     Para polinómios complexos um algoritmo por Jenkins e Traub é usado
     (Algorithm 419, Comm.  ACM, vol.  15, (1972), p.  97).  Para
     polinómios reais o algoritmo usado é devido a Jenkins (Algorithm
     493, ACM TOMS, vol.  1, (1975), p.178).

     Exemplos:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)


 -- Variável: backsubst
     Valor por omissão: `true'

     Quando `backsubst' é `false', evita substituições em expressões
     anteriores após as equações terem sido triangularizadas.  Isso pode
     ser de grande ajuda em problemas muito grandes onde
     substituição em expressões anteriores pode vir a causar a
     geração de expressões extremamente largas.


 -- Variável: breakup
     Valor por omissão: `true'

     Quando `breakup' é `true', `solve' expressa soluções de equações
     cúbicas e quárticas em termos de subexpressões comuns, que são
     atribuídas a rótulos de expressões intermédias (`%t1', `%t2',
     etc.).  De outra forma, subexpressões comuns não são identificadas.

     `breakup: true' tem efeito somente quando `programmode' é `false'.

     Exemplos:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]


 -- Função: dimension (<eqn>)
 -- Função: dimension (<eqn_1>, ..., <eqn_n>)
     `dimen' é um pacote de análise dimensional.  `load ("dimen")'
     chama esse pacote.  `demo ("dimen")' mostra uma cura
     demostração.


 -- Variável: dispflag
     Valor por omissão: `true'

     Se escolhida para `false' dentro de um `block' inibirá a
     visualização da saída gerada pelas funções solve chamadas de
     dentro de `block'.  Terminando `block' com um sinal de dolar, $,
     escolhe `dispflag' para `false'.


 -- Função: funcsolve (<eqn>, <g>(<t>))
     Retorna `[<g>(<t>) = ...]'  ou `[]', dependendo de existir ou não
     uma função racional `<g>(<t>)' satisfazendo <eqn>, que deve ser de
     primeira ordem, polinómio linear em (para esse caso) `<g>(<t>)' e
     `<g>(<t>+1)'

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Equações dependentes eliminadas:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Atenção: essa é uma implementação muito rudimentar - muitas
     verificações de segurança e obviamente generalizações estão
     ausêntes.


 -- Variável: globalsolve
     Valor por omissão: `false'

     When `globalsolve' for `true', variáveis para as quais as
     equações são resolvidas são atribuidas aos valores da solução
     encontrados por `linsolve', e por `solve' quando resolvendo duas
     ou mais equações lineares.  Quando `globalsolve' for `false',
     soluções encontradas por `linsolve' e por `solve' quando
     resolvendo duas ou mais equações lineares são espressas como
     equações, e as variáveis para as quais a equação foi resolvida não
     são atribuidas.

     Quando resolvendo qualquer coisa outra que não duas equações
     lineares ou mais, `solve' ignora `globalsolve'.  Outras funções
     que resolvem equações (e.g., `algsys') sempre ignoram
     `globalsolve'.

     Exemplos:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y


 -- Função: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     `inteqn' é um pacote para resolver equações integrais.  `load
     ("inteqn")' carrega esse pacote.

     <ie> é a equação integral; <unk> é a função desconhecida; <tech> é
     a técnica a ser tentada nesses dados acima (<tech> = `first'
     significa: tente a primeira técnica que achar uma solução; <tech>
     = `all' significa: tente todas a técnicas aplicáveis); <n> é o
     número máximo de termos a serem usados de `taylor', `neumann',
     `firstkindseries', ou `fredseries' (isso é também o número máximo
     de ciclos de recurssão para o método de diferenciação); <guess> é
     o inicial suposto para `neumann' ou `firstkindseries'.

     Valores padrão do segundo até o quinto parâmetro são:

     <unk>: `<p>(<x>)', onde <p> é a primeira função encontrada em um
     integrando que é desconhecida para Maxima e <x> é a variável que
     ocorre como um argumento para a primeira ocorrência de <p> achada
     fora de uma integral no caso de equações `secondkind' , ou é
     somente outra variável ao lado da variável de integração em
     equações `firstkind'.  Se uma tentativa de procurar por <x> falha,
     o utilizador será perguntado para suprir a variável independente.

     tech: `first'

     n: 1

     guess: `none' o que fará com que `neumann' e `firstkindseries' use
     `<f>(<x>)' como uma suposição inicial.


 -- Variável de opção: ieqnprint
     Valor por omissão: `true'

     `ieqnprint' governa o comportamento do resultado retornado pelo
     comando `ieqn'.  Quando `ieqnprint' é `false', as listas
     retornadas pela função `ieqn' são da forma

     [<solução>, <tecnica usada>, <nterms>, <sinalizador>]

     onde <sinalizador> é retirado se a solução for exacta.

     De outra forma, isso é a palavra `approximate' ou `incomplete'
     correspondendo à forma inexacta ou forma aberta de solução,
     respectivamente.  Se um método de série foi usado, <nterms>
     fornece o número de termos usados (que poderá ser menor que os n
     dados para `ieqn' se ocorrer um erro evita a geração de termos
     adicionais).


 -- Função: lhs (<expr>)
     Retorna o lado esquerdo (isto é, o primeiro argumento) da
     expressão <expr>, quando o operador de <expr> for um dos
     operadores relacionais `< <= = # equal notequal >= >', um dos
     operadores de atribuição `:= ::= : ::', ou um operadro infixo
     definido pelo utilizador, como declarado por meio de `infix'.

     Quando <expr> for um átomo ou seu operador for alguma coisa que
     não esses listados acima, `lhs' retorna <expr>.

     Veja também `rhs'.

     Exemplos:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa


 -- Função: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     Resolve a lista de equações lineares simultâneas para a lista de
     variáveis.  As expressões devem ser cada uma polinómios nas
     variáveis e podem ser equações.

     Quando `globalsolve' é `true' então variáveis que foram resolvidas
     serão escolhidas para a solução do conjunto de equações
     simultâneas.

     Quando `backsubst' é `false', `linsolve' não realiza
     substituição em equações anteriores após as equações terem sido
     triangularizadas.  Isso pode ser necessário em problemas muito
     grandes onde substituição em equações anteriores poderá causar a
     geração de expressões extremamente largas.

     Quando `linsolve_params' for `true', `linsolve' também gera
     símbolos `%r' usados para representar parâmetros arbitrários
     descritos no manual sob `algsys'.  De outra forma, `linsolve'
     resolve um menor-determinado sistema de equações com algumas
     variáveis expressas em termos de outras.

     Quando `programmode' for `false', `linsolve' mostra a solução com
     expressões intermédias com rótulos (`%t'), e retorna a lista de
     rótulos.

          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]


 -- Variável: linsolvewarn
     Valor por omissão: `true'

     Quando `linsolvewarn' é `true', `linsolve' imprime uma mensagem
     "Dependent equações eliminated".


 -- Variável: linsolve_params
     Valor por omissão: `true'

     Quando `linsolve_params' é `true', `linsolve' também gera os
     símbolos `%r' usados para representar parâmetros arbitrários
     descritos no manual sob `algsys'.  De outra forma, `linsolve'
     resolve um menor-determinado sistema de equações com algumas
     variáveis expressas em termos e outras.


 -- Variável: multiplicities
     Valor por omissão: `not_set_yet'

     `multiplicities' é escolhida para uma lista de multiplicidades das
     soluções individuais retornadas por `solve' ou `realroots'.


 -- Função: nroots (<p>, <low>, <high>)
     Retorna o número de raízes reais do polinómio real de uma única
     variável <p> no intervalo semi-aberto `(<low>, <high>]'.  Uma
     extremidade do intervalo podem ser `minf' ou `inf'.  infinito e
     mais infinito.

     `nroots' usa o método das sequuências de Sturm.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4


 -- Função: nthroot (<p>, <n>)
     Onde p é um polinómio com coeficientes inteiros e n é um inteiro
     positivo retorna q, um polinómio sobre os inteiros, tal que q^n=p
     ou imprime uma mensagem de erro indicando que p não é uma potência
     n-ésima perfeita.  Essa rotina é mais rápida que `factor' ou mesmo
     `sqfr'.


 -- Variável: programmode
     Valor por omissão: `true'

     Quando `programmode' é `true', `solve', `realroots', `allroots', e
     `linsolve' retornam soluções como elementos em uma lista.  (Exceto
     quando `backsubst' é escolhido para `false', nesse caso
     `programmode: false' é assumido.)

     Quando `programmode' é `false', `solve', etc.  cria rótulos de
     expressões intermédias `%t1', `t2', etc., e atribui as soluções
     para eles.


 -- Variável: realonly
     Valor por omissão: `false'

     Quando `realonly' é `true', `algsys' retorna somente aquelas
     soluções que estão livres de `%i'.


 -- Função: realroots (<expr>, <bound>)
 -- Função: realroots (<eqn>, <bound>)
 -- Função: realroots (<expr>)
 -- Função: realroots (<eqn>)
     Calcula aproximações racionais das raízes reais da expressão
     polinomial <expr> ou da equação polinomial <eqn> de uma variável,
     dentro de uma tolerância de <bound>.  coeficientes de <expr> ou de
     <eqn> devem ser números literais; constantes símbolo tais como
     `%pi' são rejeitadas.

     `realroots' atribui as multiplicidades das raízes que encontrar
     para a variável global `multiplicities'.

     `realroots' constrói uma sequência de Sturm para delimitar cada
     raíz, e então palica a bisecção para redefinir as aproximações.
     Todos os coeficientes são convertidos para os equivalentes
     racionais antes da busca por raízes, e cálculos são realizados por
     meio de aritmética racional exacta.  Mesmo se alguns coeficientes
     forem números em ponto flutuante, os resultados são racionais (a
     menos que forçados a números em ponto flutuante por `float' ou por
     `numer' flags).

     Quando <bound> for menor que 1, todas as raízes inteiras são
     encontradas exactamente.  Quando <bound> não for especificado,
     será assumido como sendo igual à variável globa `rootsepsilon'.

     Quando a varável global `programmode' for `true', `realroots'
     retorna uma lista da forma `[x = <x_1>, x = <x_2>, ...]'.  Quando
     `programmode' for `false', `realroots' cria rótulos de expressões
     intermédias `%t1', `%t2', ..., atribui os resultados a eles, e
     retorna a lista de rótulos.

     Exemplos:

          (%i1) realroots (-1 - x + x^5, 5e-6);
                                         612003
          (%o1)                     [x = ------]
                                         524288
          (%i2) ev (%[1], float);
          (%o2)                 x = 1.167303085327148
          (%i3) ev (-1 - x + x^5, %);
          (%o3)                - 7.396496210176905E-6

          (%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
          (%o1)                 [x = 1, x = 2, x = 3]
          (%i2) multiplicities;
          (%o2)                       [5, 3, 1]


 -- Função: rhs (<expr>)
     Retorna o lado direito (isto é, o segundo argumento) da expressão
     <expr>, quando o operador de <expr> for um dos operadores
     relacionais `< <= = # equal notequal >= >', um dos operadores de
     atribuição `:= ::= : ::', ou um operador binário infixo definido
     pelo utilizador, como declarado por meio de `infix'.

     Quando <expr> for um étomo ou seu operadro for alguma coisa que
     não esses listados acima, `rhs' retorna 0.

     Veja também `lhs'.

     Exemplos:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb


 -- Variável de opção: rootsconmode
     Valor por omissão: `true'

     `rootsconmode' governa o comportamento do comando `rootscontract'.
     Veja `rootscontract' para detalhes.


 -- Função: rootscontract (<expr>)
     Converte produtos de raízes em raízes de produtos.  Por exemplo,
     `rootscontract (sqrt(x)*y^(3/2))' retorna `sqrt(x*y^3)'.

     Quando `radexpand' é `true' e `domain' é `real', `rootscontract'
     converte `abs' em `sqrt', e.g., `rootscontract (abs(x)*sqrt(y))'
     retorna `sqrt(x^2*y)'.

     Existe uma opção `rootsconmode' afectando `rootscontract' como
     segue:

          Problem            Value of        Result of applying
                            rootsconmode        rootscontract

          x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
          x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
          x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
          x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
          x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)

     Quando `rootsconmode' é `false', `rootscontract' contrai somente
     como relação a expoentes de número racional cujos denominadores
     são os mesmos.  A chave para os exemplos `rootsconmode: true' é
     simplesmente que 2 divides 4 mas não divide 3.  `rootsconmode:
     all' envolve pegar o menor múltiplo comum dos denominadores dos
     expoentes.

     `rootscontract' usa `ratsimp' em uma maneira similar a
     `logcontract'.

     Exemplos:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
          (%o13)                          0


 -- Variável de opção: rootsepsilon
     Valor por omissão: 1.0e-7

     `rootsepsilon' é a tolerância que estabelece o intervalo de
     conficência para as raízes achadas pela função `realroots'.


 -- Função: solve (<expr>, <x>)
 -- Função: solve (<expr>)
 -- Função: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Resolve a equação algébrica <expr> para a variável <x> e retorna
     uma lista de equações solução em <x>.  Se <expr> não é uma
     equação, a equação `<expr> = 0' é assumida em seu lugar.  <x> pode
     ser uma função (e.g. `f(x)'), ou outra expressão não atômica
     excepto uma adição ou um produto.  <x> pode ser omitido se <expr>
     contém somente uma variável.  <expr> pode ser uma expressão
     racional, e pode conter funções trigonométricas, exponenciais, etc.

     O seguinte método é usado:

     Tome <E> sendo a expressão e <X> sendo a variável.  Se <E> é
     linear em <X> então isso é trivialmente resolvido para <X>.  De
     outra forma se <E> é da forma `A*X^N + B' então o resultado é
     `(-B/A)^1/N)' vezes as `N''ésimas raízes da unidade.

     Se <E> não é linear em <X> então o máximo divisor comum (mdc) dos
     expoentes de <X> em <E> (digamos <N>) é dividido dentro dos
     expoentes e a multiplicidade das raízes é multiplicada por <N>.
     Então `solve' é chamada novamente sobre o resultado.  Se <E> for
     dada em factores então `solve' é chamada sobre cada um dos
     factores.  Finalmente `solve' usará as fórmulas quadráticas,
     cúbicas, ou quárticas onde necessário.

     No caso onde <E> for um polinómio em alguma função de variável a
     ser resolvida, digamos `F(X)', então isso é primeiro resolvida
     para `F(X)' (chama o resultado <C>), então a equação `F(X)=C' pode
     ser resolvida para <X> fornecendo o inverso da função <F> que é
     conhecida.

     `breakup' se `false' fará com que `solve' expresse as soluções de
     equações cúbicas ou quárticas como expressões simples ao invés de
     como feito em cima de várias subexpressões comuns que é o padrão.

     `multiplicities' - será escolhido para uma lista de
     multiplicidades de soluções individuais retornadas por `solve',
     `realroots', ou `allroots'.  Tente `apropos (solve)' para os
     comutadores que afectam `solve'.  `describe' pode então ser usada
     sobre o nome do comutador individual se seu proprósito não é claro.

     `solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])' resolve um
     sistema de equações polinomiais (lineares ou não-lineares)
     simultâneas por chamada a `linsolve' ou `algsys' e retorna uma
     lista de listas solução nas variáveis.  No caso de `linsolve' essa
     lista conterá uma lista simples de soluções.  Isso pega duas
     listas como argumentos.  A primeira lista representa as equações a
     serem resolvidas; a segunda lista é a lista de desconhecidos a ser
     determinada.  Se o número total de variáveis nas equações é igual
     ao número de equações, a segunda lista-argumento pode ser omitida.
     Para sistemas lineares se as dadas equações não são compatíveis,
     a mensagem `inconsistent' será mostrada (veja o comutador
     `solve_inconsistent_error' ); se não existe solução única, então
     `singular' será mostrado.

     Exemplos:

          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some soluções will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0


 -- Variável de opção: solvedecomposes
     Valor por omissão: `true'

     Quando `solvedecomposes' é `true', `solve' chama `polydecomp' se
     perguntado para resolver polinómios.


 -- Variável de opção: solveexplicit
     Valor por omissão: `false'

     Quando `solveexplicit' é `true', inibe `solve' de retornar
     soluções implícitas, isto é, soluções da forma `F(x) = 0' onde `F'
     é alguma função.


 -- Variável de opção: solvefactors
     Valor por omissão: `true'

     Quando `solvefactors' é `false', `solve' não tenta factorizar a
     expressão. A escolha do `false' poderá ser útil em alguns casos
     onde a factorização não é necessária.


 -- Variável de opção: solvenullwarn
     Valor por omissão: `true'

     Quando `solvenullwarn' é `true', `solve' imprime uma mensagem de
     alerta se chamada com ou uma lista equação ou uma variável lista
     nula.  Por exemplo, `solve ([], [])' imprimirá duas mensagens de
     alerta e retorna `[]'.


 -- Variável de opção: solveradcan
     Valor por omissão: `false'

     Quando `solveradcan' é `true', `solve' chama `radcan' que faz
     `solve' lento mas permitirá certamente que problemas contendo
     exponeniais e logaritmos sejam resolvidos.


 -- Variável de opção: solvetrigwarn
     Valor por omissão: `true'

     Quando `solvetrigwarn' é `true', `solve' pode imprimir uma
     mensagem dizendo que está usando funções trigonométricas inversas
     para resolver a equação, e desse modo perdendo soluções.


 -- Variável de opção: solve_inconsistent_error
     Valor por omissão: `true'

     Quando `solve_inconsistent_error' é `true', `solve' e `linsolve'
     resultam em erro se as equações a serem resolvidas são
     inconsistentes.

     Se `false', `solve' e `linsolve' retornam uma lista vazia `[]' se
     as equações forem inconsistentes.

     Exemplo:

          (%i1) solve_inconsistent_error: true$
          (%i2) solve ([a + b = 1, a + b = 2], [a, b]);
          Inconsistent equações:  (2)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i3) solve_inconsistent_error: false$
          (%i4) solve ([a + b = 1, a + b = 2], [a, b]);
          (%o4)                          []



File: maxima.info,  Node: Equações Diferenciais,  Next: Numérico,  Prev: Equações,  Up: Top

22 Equações Diferenciais
************************

* Menu:

* Introdução às Equações Diferenciais::
* Definições para Equações Diferenciais::



Local Variables:
coding: iso-8859-1
End:
