This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Este é o Manual do Maxima no formato Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Introdução ao Maxima,  Prev: (dir),  Up: (dir)

Manual do Maxima
****************

Maxima é um Sistema de Computação Algébrica, implementado em Lisp.

   Maxima é derivado do sistema Macsyma, desenvolvido no MIT nos anos de
1968 a 1982 como parte do Projecto MAC.  O MIT transferiu uma cópia do
código fonte do Macsyma para o Departamento de Energia em 1982; essa
versão é agora conhecida como Macsyma DOE.  Uma cópia do Macsyma DOE
foi mantida pelo Professor William F. Schelter da Universidade do
Texas, desde 1982 até a sua morte em 2001.  Em 1998, Schelter obteve
autorização do Departamento de Energia para liberar o código fonte do
Macsyma DOE sob a Licença Pública GNU, e em 2000 iniciou o projeto
Maxima no SourceForge para manter e desenvolver o Macsyma DOE, agora
chamado Maxima.

   Notas de tradução:

   Esta versão portuguesa, para Portugal, é mantida por Jaime Villate, e
está baseada na tradução Brasileira de Jorge Barros de Abreu.  Se
quiser contribuir, por favor entre em contacto com villate ARROBA fe
PONTO up PONTO pt.

* Menu:

Infraestrutura do Maxima

* Introdução ao Maxima::        Exemplo de sessões do Maxima.
* Detecção e Relato de Erros::  Como encontrar erros e informar os responsáveis.
* Ajuda::                       Obtenção de ajuda dentro de uma sessão do Maxima.
* Linha de Comandos::           Sintaxe da linha de comandos do Maxima.
* Operadores::                  Operadores usados em expressões do Maxima.
* Expressões::                Expressões no Maxima.
* Simplificação::         Simplificação de expressões.
* Criação de Gráficos:: Gráficos em 2D e 3D.
* Entrada e Saída::           Entrada e saída de ficheiros.
* Ponto Flutuante::  Rotinas numéricas de baixo nível.
* Contextos::                   Conjunto de regras assumidas.

Suporte a áreas específicas da matemática

* Polinómios::                Formas padrão para polinómios, e funções de polinómios.
* Constantes::                  Constantes numéricas.
* Logaritmos::    Manipulação de expressões com logaritmos.
* Trigonometria::               Manipulação de expressões e funções trigonométricas.
* Funções Especiais::     Funções especiais.
* Funções Elípticas::   Funções e integrais Elípticas.
* Limites::                     Limites de expressões.
* Diferenciação::         Cálculo diferencial.
* Integração::            Cálculo integral.
* Equações::              Definição e resolução de equações.
* Equações Diferenciais:: Definição e resolução de equações diferenciais.
* Numérico::                  Integração numérica, transformadas de Fourier, etc.
* Arrays ::                     Criação e manipulação de arranjos.
* Matrizes e Álgebra Linear:: Operações com Matrizes.
* Funções Afins::
* itensor::                     Manipulação de índices de tensores.
* ctensor::                     Manipulação de componentes de Tensores.
* Pacote atensor::              Manipulação algébrica de tensores.
* Séries::                    Séries de potências e de Taylor.
* Teoria dos Números::        Teoria dos números.
* Simetrias::
* Grupos::                      Álgebra abstracta.

Facilidades avançadas e programação

* Ambiente em Tempo de Execução:: Customização do ambiente Maxima.
* Opções Diversas::       Opções com efeito global sobre o Maxima.
* Regras e Modelos::            Coincidência de expressões definidas pelo utilizador e regras de simplificação.
* Listas::                      Manipulação de listas.
* Conjuntos::                   Manipulação de conjuntos.
* Definição de Função:: Definição de funções.
* Fluxo de Programa::           Definição de programas no Maxima.
* Depuração::                   Depuração de programas no Maxima.

Pacotes Adicionais

* augmented_lagrangian::        Pacote augmented_lagrangian.
* bode::                        Gráficos de ganho e fase de Bode.
* descriptive::                 Estatística descritiva.
* diag::                        Matrizes de Jordan.
* distrib::                     Distribuições de probabilidade.
* dynamics::                    Gráficos para sistemas dinâmicos e fractais.
* eval_string::                 Expressões do Maxima como cadeias de texto.
* f90::                         Tradutor do Maxima para o Fortran.
* ggf::                         Função geradora para sequências.
* impdiff::                     Derivadas implícitas.
* implicit_plot::               Gráficos de funções implítas.
* interpol::                    Pacote de interpolação.
* lbfgs::                       L-BFGS pacote de minimização não limitada.
* lindstedt::                   Pacote Lindstedt.
* linearalgebra::               Funções de álgebra linear.
* lsquares::                    Método dos mínimos quadrados.
* makeOrders::                  Expoentes de polinómios.
* mnewton::                     Método de Newton.
* numericalio::                 Leitura e escritura de ficheiros.
* opsubst::                     Comandos para substituições.
* orthopoly::                   Polinómios ortogonais.
* plotdf::                      Gráficos de campos de direcções.
* romberg::                     Método de Romberg para integração numérica.
* simplex::                     Programação linear.
* simplification::              Funções e regras de simplificação.
* solve_rec::                   Relações de recorrência lineares.
* stats::                       Pacote de inferências estatísticas.
* stirling::                    Fórmula de Stirling.
* stringproc::                  Processamento de cadeias de texto.
* unit::                        Pacote de unidades e dimensões.
* zeilberger::                  Funções para somatórios hipergeométricos.


Índice

* Índice de Funções e Variáveis:: Índice

 --- Listagem Detalhada de Nodos ---

Introdução

* Introdução ao Maxima::

Ajuda

* Lisp e Maxima::
* Descartando::
* Documentação::
* Definições para Ajuda::

Linha de Comandos

* Introdução a Linha de Comandos::
* Definições para Linha de Comandos::

Operadores

* N-Argumentos::
* Operador não fixado::
* Operador Pósfixado::
* Operador Préfixado::
* Operadores Aritméticos::
* Operadores Relacionais::
* Operadores Geral::

Expressões

* Introdução a Expressões::
* Complexo::
* Desigualdade::
* Sintaxe::
* Definições para Expressões::

Simplificação

* Definições para Simplificação::

Criação de Gráficos

* Definições para Criação de Gráficos::

Entrada e Saída

* Comentários::
* Ficheiros::
* Definições para Entrada e Saída::

Ponto Flutuante

* Definições para ponto Flutuante::

Contextos

* Definições para Contextos::

Polinómios

* Introdução a Polinómios::
* Definições para Polinómios::

Constantes

* Definições para Constantes::

Logaritmos

* Definições para Logaritmos::

Trigonometria

* Introdução ao Pacote Trigonométrico::
* Definições para Trigonometria::

Funções Especiais

* Introdução a Funções Especiais::
* Definições para Funções Especiais::

Funções Elípticas

* Introdução a Funções Elípticas e Integrais::
* Definições para Funções Elípticas::
* Definições para Integrais Elípticas::

Limites

* Definições para Limites::

Diferenciação

* Definições para Diferenciação::

Integração

* Introdução a Integração::
* Definições para Integração::

Equações

* Definições para Equações::

Equações Diferenciais

* Introdução às Equações Diferenciais::
* Definições para Equações Diferenciais::

Numérico

* Introdução a Numérico::
* Pacotes de Fourier::
* Definições para Numérico::
* Definições para Séries de Fourier::

Arrays

* Definições para Arrays::

Matrizes e Álgebra Linear

* Introdução a Matrizes e Álgebra Linear::
* Ponto::
* Vetores::
* auto::
* Definições para Matrizes e Álgebra Linear::

Funções Afins

* Definições para Funções Afins::

itensor

* Introdução a itensor::
* Definições para itensor::

ctensor

* Introdução a ctensor::
* Definições para ctensor::

Pacote atensor

* Introdução ao Pacote atensor::
* Definições para o Pacote atensor::

Séries

* Introdução a Séries::
* Definições para Séries::

Teoria dos Números

* Definições para Teoria dos Números::

Simetrias

* Definições para Simetrias::

Grupos

* Definições para Grupos::

Ambiente em Tempo de Execução

* Introdução a Ambiente em Tempo de Execução::
* Interrupções::
* Definições para Ambiente em Tempo de Execução::

Opções Diversas

* Introdução a Opções Diversas::
* Compartilhado::
* Definições para Opções Diversas::

Regras e Modelos

* Introdução a Regras e Modelos::
* Definições para Regras e Modelos::

Listas

* Introdução a Listas::
* Definições para Listas::

Conjuntos

* Introdução a Conjuntos::
* Definições para Conjuntos::

Definição de Função

* Introdução a Definição de Função::
* Função::
* Macros::
* Definições para Definição de Função::

Fluxo de Programa

* Introdução a Fluxo de Programa::
* Definições para Fluxo de Programa::

Depuração

* Definições para Depuração::

augmented_lagrangian

* Definições para augmented_lagrangian::

bode

* Definições para bode::

descriptive

* Introdução ao pacote descriptive::
* Definições para manipulação da dados::
* Definições para estatística descritiva::
* Definições específicas para estatística descritiva de várias variáveis::
* Definições para gráficos estatísticos::

diag

* Definições para diag::

distrib

* Introdução a distrib::
* Definições para distribuições contínuas::
* Definições para distribuições discretas::

dynamics

* Introdução a dynamics::
* Definições para dynamics::

eval_string

* Definições para eval_string::

f90

* Definições para f90::

ggf

* Definições para ggf::

impdiff

* Definições para impdiff::

implicit_plot

* Definições para implicit_plot::

interpol

* Introdução a interpol::
* Definições para interpol::

lbfgs

* Introdução a lbfgs::
* Definições para lbfgs::

lindstedt

* Definições para lindstedt::

linearalgebra

* Introdução a linearalgebra::
* Definições para linearalgebra::

lsquares

* Definições para lsquares::

makeOrders

* Definições para makeOrders::

mnewton

* Definições para mnewton::

numericalio

* Introdução a numericalio::
* Definições para numericalio::

opsubst

* Definições para opsubst::

orthopoly

* Introdução a polinómios ortogonais::
* Definições para polinómios ortogonais::

plotdf

* Introdução a plotdf::
* Definições para plotdf::

romberg

* Definições para romberg::

simplex

* Introdução a simplex::
* Definições para simplex::

simplification

* Introdução a simplification::
* Definições para simplification::

solve_rec

* Introdução a solve_rec::
* Definições para solve_rec::

stats

* Introdução a stats::
* Definições para inference_result::
* Definições para stats::
* Definições para distribuições especiais::

stirling

* Definições para stirling::

stringproc

* Introdução a manipulação de sequências de caracteres::
* Definições para entrada e saída::
* Definições para caracteres::
* Definições para sequências de caracteres::

unit

* Introdução a Units::
* Definições para Units::

zeilberger

* Introdução a zeilberger::
* Definições para zeilberger::


File: maxima.info,  Node: Introdução ao Maxima,  Next: Detecção e Relato de Erros,  Prev: Top,  Up: Top

1 Introdução ao Maxima
**********************

Inicie o Maxima com o comando "maxima".  Maxima mostrará a
informação de versão e uma linha de comando.  Termine cada comando
Maxima com um ponto e vírgula.  Termine uma sessão com o comando
"quit();".  Aqui está um exemplo de sessão:

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

   Maxima pode fazer pesquisas nas páginas info do manual. Use o comando
`describe' para mostrar todos os comandos e variáveis contendo uma dada
sequência de caracteres, e opcionalmente a sua documentação.  O ponto
de interrogação `?' é uma abreviatura para `describe':

     (%i1) ? integ

      0: (maxima.info)Introduction to Elliptic Functions and Integrals.
      1: Definitions for Elliptic Integrals.
      2: Integration.
      3: Introduction to Integration.
      4: Definitions for Integration.
      5: askinteger :Definitions for Simplification.
      6: integerp :Definitions for Miscellaneous Options.
      7: integrate :Definitions for Integration.
      8: integrate_use_rootsof :Definitions for Integration.
      9: integration_constant_counter :Definitions for Integration.
     Enter space-separated numbers, `all' or `none': 6 5

     Info from file /usr/local/info/maxima.info:
      - Function: integerp (<expr>)
          Returns `true' if <expr> is an integer, otherwise `false'.


      - Function: askinteger (expr, integer)
      - Function: askinteger (expr)
      - Function: askinteger (expr, even)
      - Function: askinteger (expr, odd)
          `askinteger (expr, integer)' attempts to determine from the
          `assume' database whether `expr' is an integer.  `askinteger' will
          ask the user if it cannot tell otherwise, and attempt to install
          the information in the database if possible.  `askinteger (expr)'
          is equivalent to `askinteger (expr, integer)'.

          `askinteger (expr, even)' and `askinteger (expr, odd)' likewise
          attempt to determine if `expr' is an even integer or odd integer,
          respectively.

     (%o1)                         false

   Para usar um resultado em cálculos posteriores, pode atribuir esse
valor a uma variável ou referir-se a esse mesmo valor através de seu
rótulo gerado automaticamente.  Adicionalmente, `%' refere-se ao mais
recente resultado calculado:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (u, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor (%o2);
                                         5
     (%o3)                      6 (y + x)

   Maxima tem conhecimento sobre números complexos e constantes
numéricas:

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1

   Maxima pode fazer contas de cálculo diferencial e integrail:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

   Maxima pode resolver sistemas lineares e equações cúbicas:

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

   Maxima pode resolver sistemas de equações não lineares. Repare que
se não quiser um resultado impresso, poderá terminar o seu comando com
`$' em lugar de encerrar com `;'.

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

   Maxima pode gerar gráficos de uma ou mais funções:

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2
     (%i4) kill(labels);
     (%o0)                         done
     (%i1) plot2d (sin(x)/x, [x, -20, 20]);
     (%o1)
     (%i2) plot2d ([atan(x), erf(x), tanh(x)], [x, -5, 5]);
     (%o2)
     (%i3) plot3d (sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2), [x, -12, 12], [y, -12, 12]);
     (%o3)


File: maxima.info,  Node: Detecção e Relato de Erros,  Next: Ajuda,  Prev: Introdução ao Maxima,  Up: Top

2 Detecção e Relato de Erros
****************************

* Menu:

* Definições para Detecção e Relato de Erros::


File: maxima.info,  Node: Definições para Detecção e Relato de Erros,  Up: Detecção e Relato de Erros

2.1 Definições para Detecção e Relato de Erros
==============================================

 -- Função: run_testsuite ()
 -- Função: run_testsuite (<boolean>)
 -- Função: run_testsuite (<boolean>, <boolean>)
 -- Função: run_testsuite (<boolean>, <boolean>, <list>)
     Executa o conjunto de testes do Maxima.  Testes que produzem a
     resposta desejada são considerados "passes," e testes que não
     produzem a resposta desejada, são marcados como erros conhecidos.

     `run_testsuite ()' mostra somente testes que não são aprovados.

     `run_testsuite (true)' mostra somente testes que são marcados como
     erros conhecidos, bem como as falhas.

     `run_testsuite (true, true)' mostra todos os testes.

     Se o terceiro argumento opcional for dado, um subconjunto de
     testes é executado.  O subconjunto de testes para executar é dado
     como uma lista de nomes dos testes.  O conjunto completo de testes
     é especificado por `testsuite_files'.

     `run_testsuite' altera a variável de ambiente Maxima.  Tipicamente
     um script de teste executa `kill' para estabelecer uma variável de
     ambiente (uma a saber sem funções definidas pelo utilizador e
     variáveis) e então define funções e variáveis apropriadamente para
     o teste.

     `run_testsuite' retorna `done'.

 -- Variável de opção: testsuite_files
     `testsuite_files' é o conjunto de testes a ser executado por
     `run_testsuite'.  Isso é uma lista de nomes de ficheiros contendo
     os testes a executar.  Se alguns dos testes em um ficheiro falha
     de forma conhecida, então em lugar de listar o nome do ficheiro,
     uma lista contendo o nome do ficheiro e o número dos testes que
     falharam é usada.

     por exemplo, a linha adinate é uma parte do conjunto de testes
     padrão:

           ["rtest13s", ["rtest14", 57, 63]]

     Essa linha especifica a suite de testes que consiste dos ficheiros
     "rtest13s" e "rtest14", mas "rtest14" contém dois testes que
     falham de forma conhecida: 57 e 63.

 -- Função: bug_report ()
     Imprime os números de versão do Maxima e do Lisp, e chama o link
     para a página web de informação de erros do projeto Maxima.  A
     informação da versão é a mesma reportada por `build_info'.

     Quando um erro é informado, é muito útil copiar a versão do Maxima
     e do Lisp dentro da informação do erro.

     `bug_report' retorna uma sequência de caracteres vazia `""'.

 -- Função: build_info ()
     Imprime um sumário de parâmetros da compilação do Maxima.

     `build_info' retorna uma sequência de caracteres vazia `""'.


File: maxima.info,  Node: Ajuda,  Next: Linha de Comandos,  Prev: Detecção e Relato de Erros,  Up: Top

3 Ajuda
*******

* Menu:

* Lisp e Maxima::
* Descartando::
* Documentação::
* Definições para Ajuda::


File: maxima.info,  Node: Lisp e Maxima,  Next: Descartando,  Prev: Ajuda,  Up: Ajuda

3.1 Lisp e Maxima
=================

Maxima é escrito na liguagem de programação Lisp, e é fácil acessar
funções Lisp e variáveis a partir do Maxima e vice-versa.  Símbolos
Lisp e Maxima são distinguidos através de uma convenção de nome.  Um
símbolo Lisp que começa com um sinal de dólar `$' corresponde a um
símbolo Maxima sem o sinal de dólar.  Um símbolo Maxima que começa com
um ponto de interrogação `?' corresponde a um símbolo Lisp sem o ponto
de interrogação.  Por exemplo, o símbolo Maxima `foo' corresponde ao
símbolo Lisp `$foo', enquanto o símbolo Maxima `?foo' corresponde ao
símbolo Lisp `foo', Note que `?foo' é escrito sem um espaço entre `?' e
`foo'; de outra forma pode ser uma chamada errônea para `describe
("foo")'.

   Hífen `-', asterisco `*', ou outro caractere especial em símbolos
Lisp deve ser precedido por uma barra invertida `\' onde ele aparecer
no código Maxima.  Por exemplo, o identificador Lisp `*foo-bar*' é
escrito `?\*foo\-bar\*' no Maxima.

   Código Lisp pode ser executado dentro de uma sessão Maxima.  Uma
linha simples de Lisp (contendo uma ou mais formas) pode ser executada
através do comando especial `:lisp'. Por exemplo,

     (%i1) :lisp (foo $x $y)

chama a função Lisp `foo' com variáveis Maxima `x' e `y' como
argumentos.  A constução `:lisp' pode aparecer na linha de comando
interativa ou em um ficheiro processado por `batch' ou `demo', mas não
em um ficheiro processado por `load', `batchload', `translate_file', ou
`compile_file'.

   A função `to_lisp()' abre uma sessão interativa Lisp.  Digitando
`(to-maxima)' fecha a sessão Lisp e retorna para o Maxima.

   Funções Lisp e variáveis que são para serem visíveis no Maxima como
funções e variáveis com nomes comuns (sem pontuação especial) devem ter
nomes Lisp começando com o sinal de dólar `$'.

   Maxima é sensível à caixa, distingue entre letras em caixa alta
(maiúsculas) e letras em caixa baixa (minúsculas) em identificadores,
enquanto Lisp não é sensível à caixa.  Existem algumas regras
governando a tradução de nomes entre o Lisp e o Maxima.

  1. Um identificador Lisp não contido entre barras verticais
     corresponde a um identificador Maxima em caixa baixa.  Se o
     identificador Lisp estiver em caixa alta, caixa baixa, ou caixa
     mista, é ignorado.  E.g., Lisp `$foo', `$FOO', e `$Foo' todos
     correspondem a Maxima `foo'.

  2. Um identificador Lisp que está todo em caixa alta ou todo em caixa
     baixa e contido em barras verticais corresponde a um identificador
     Maxima com caixa invertida.  Isto é, caixa alta é alterada para
     caixa baixa e caixa baixa para caixa alta.  E.g., Lisp `|$FOO|' e
     `|$foo|' corresponde a Maxima `foo' e `FOO', respectivamente.

  3. Um identificador Lisp que é misto de caixa alta e caixa baixa e
     contido entre barras verticais corresponde a um identificador
     Maxima com o mesma caixa.  E.g., Lisp `|$Foo|' corresponde a
     Maxima `Foo'.

   A macro Lisp `#$' permite o uso de expressões Maxima em código Lisp.
`#$<expr>$' expande para uma expressão Lisp equivalente à expressão
Maxima <expr>.

     (msetq $foo #$[x, y]$)

Isso tem o mesmo efeito que digitar

     (%i1) foo: [x, y];

A função Lisp `displa' imprime uma expressão em formato Maxima.

     (%i1) :lisp #$[x, y, z]$
     ((MLIST SIMP) $X $Y $Z)
     (%i1) :lisp (displa '((MLIST SIMP) $X $Y $Z))
     [x, y, z]
     NIL

   Funções definidas em Maxima não são funções comuns em Lisp.  A
função Lisp `mfuncall' chama uma função Maxima.  Por exemplo:

     (%i1) foo(x,y) := x*y$
     (%i2) :lisp (mfuncall '$foo 'a 'b)
     ((MTIMES SIMP) A B)

   Algumas funções Lisp possuem o mesmo nome que no pacote Maxima, a
saber as seguintes.

   `complement', `continue', `//', `float', `functionp', `array', `exp',
`listen', `signum', `atan', `asin', `acos', `asinh', `acosh', `atanh',
`tanh', `cosh', `sinh', `tan', `break', e `gcd'.


File: maxima.info,  Node: Descartando,  Next: Documentação,  Prev: Lisp e Maxima,  Up: Ajuda

3.2 Descartando
===============

Computação simbólica tende a criar um bom volume de ficheiros
temporários, e o efectivo manuseio disso pode ser crucial para sucesso
completo de alguns programas.

   Sob GCL, nos sistemas UNIX onde a chamada de sistema mprotect (
controle de acessso autorizado a uma região de memória) está disponível
(incluindo SUN OS 4.0 e algumas variantes de BSD) uma organização de
ficheiros temporários estratificada está disponível.  Isso limita a
organização para páginas que tenham sido recentemente escritas.  Veja a
documentação da GCL sob ALLOCATE e GBC.  No ambiente Lisp fazendo (setq
si::*notify-gbc* t) irá ajudá-lo a determinar quais áreas podem
precisar de mais espaço.


File: maxima.info,  Node: Documentação,  Next: Definições para Ajuda,  Prev: Descartando,  Up: Ajuda

3.3 Documentação
================

O manual on-line de utilizador do Maxima pode ser visto em diferentes
formas.  A partir da linha de comando interativa do Maxima, o manual de
utilizador é visto em texto plano através do comando `?' (i.e., a
função `describe' ).  O manual de utilizador é visto como hipertexto
`info' através do programa visualizador `info' e como uma web page
através de qualquer navegador web comum.

   `example' mostra exemplos de muitas funções do Maxima.  Por exemplo,

     (%i1) example (integrate);

   retorna

     (%i2) test(f):=block([u],u:integrate(f,x),ratsimp(f-diff(u,x)))
     (%o2) test(f) := block([u], u : integrate(f, x),

                                              ratsimp(f - diff(u, x)))
     (%i3) test(sin(x))
     (%o3)                           0
     (%i4) test(1/(x+1))
     (%o4)                           0
     (%i5) test(1/(x^2+1))
     (%o5)                           0

   e saída adicional.


File: maxima.info,  Node: Definições para Ajuda,  Prev: Documentação,  Up: Ajuda

3.4 Definições para Ajuda
=========================

 -- Função: demo (<nomeficheiro>)
     Avalia expressões Maxima em <nomeficheiro> e mostra os resultados.
     `demo' faz uma pausa após avaliar cada expressão e continua após a
     conclusão com um enter das entradas de utilizador.  (Se executando
     em Xmaxima, `demo' pode precisar ver um ponto e vírgula `;'
     seguido por um enter.)

     `demo' procura na lista de directórios `file_search_demo' para
     achar `nomeficheiro'.  Se o ficheiro tiver o sufixo `dem', o
     sufixo pode ser omitido.  Veja também `file_search'.

     `demo' avalia seus argumento.  `demo' retorna o nome do ficheiro
     de demonstração.

     Exemplo:

          (%i1) demo ("disol");

          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load(disol)

          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))

          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)

          _
          (%i5) demo ("rncomb");

          batching /home/wfs/maxima/share/simplification/rncomb.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i6)                     load(rncomb)

          _
                                       z         x
          (%i7)               exp1 : ----- + ---------
                                     y + x   2 (y + x)
                                    z         x
          (%o7)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i8)                     combine(exp1)
                                    z         x
          (%o8)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i9)                     rncombine(%)
                                       2 z + x
          (%o9)                       ---------
                                      2 (y + x)

          _
                                       d   c   b   a
          (%i10)                exp2 : - + - + - + -
                                       3   3   2   2
                                    d   c   b   a
          (%o10)                    - + - + - + -
                                    3   3   2   2

          _
          (%i11)                    combine(exp2)
                                2 d + 2 c + 3 (b + a)
          (%o11)                ---------------------
                                          6

          _
          (%i12)                   rncombine(exp2)
                                2 d + 2 c + 3 b + 3 a
          (%o12)                ---------------------
                                          6

          _
          (%i13)


 -- Função: describe (<string>)
 -- Função: describe (<string>, exact)
 -- Função: describe (<string>, inexact)
     `describe(<string>)' é equivalente a `describe(<string>, exact)'.

     `describe(<string>, exact)' encontra um item com título igual
     (case-insensitive) a <string>, se existir tal item.

     `describe(<string>, inexact)' encontra todos os itens documentados
     que contiverem <string> em seus títulos.  Se existe mais de um de
     tal item, Maxima solicita ao utilizador seleccionar um item ou
     ítens para mostrar.

     Na linha de comando interativa, `? foo' (com um espaço entre `?' e
     `foo') é equivalente a `describe("foo", exact)'.  e `?? foo' é
     equivalente a `describe("foo", inexact)'.

     `describe("", inexact)' retorna uma lista de todos os tópicos
     documentados no manual on-line.

     `describe' não avalia seu argumento.  `describe' retorna `true' se
     alguma documentação for encontrada, de outra forma retorna `false'.

     Veja também _Documentação_.

     Exemplo:

          (%i1) ?? integ
           0: (maxima.info)Introduction to Elliptic Functions and Integrals.
           1: Definitions for Elliptic Integrals.
           2: Integration.
           3: Introduction to Integration.
           4: Definitions for Integration.
           5: askinteger :Definitions for Simplification.
           6: integerp :Definitions for Miscellaneous Options.
           7: integrate :Definitions for Integration.
           8: integrate_use_rootsof :Definitions for Integration.
           9: integration_constant_counter :Definitions for Integration.
          Enter space-separated numbers, `all' or `none': 7 8

          Info from file /use/local/maxima/doc/info/maxima.info:
           - Function: integrate (expr, var)
           - Function: integrate (expr, var, a, b)
               Attempts to symbolically compute the integral of `expr' with
               respect to `var'.  `integrate (expr, var)' is an indefinite
               integral, while `integrate (expr, var, a, b)' is a definite
               integral, [...]

     Nesse , ítens 7 e 8 foram seleccionados.  Todos ou nenhum dos
     ítens poderia ter sido seleccionado através da inserção de `all'
     ou `none', que podem ser abreviado para `a' ou para `n',
     respectivamente.


 -- Função: example (<tópico>)
 -- Função: example ()
     `example (<topic>)' mostra alguns exemplos de <tópico>, que é um
     símbolo (não uma sequência de caracteres).  A maioria dos tópicos
     são nomes de função.  `example ()' retorna a lista de todos os
     tópicos reconhecidos.

     O nome do ficheiro contendo os exemplos é dado pela variável
     global `manual_demo', cujo valor padrão é `"manual.demo"'.

     `example' não avalia seu argumento.  `example' retorna `done' a
     menos que ocorra um erro ou não exista o argumento fornecido pelo
     utilizador, nesse caso `example' retorna uma lista de todos os
     tópicos reconhecidos.

     Exemplos:

          (%i1) example (append);
          (%i2) append([x+y,0,-3.2],[2.5E+20,x])
          (%o2)             [y + x, 0, - 3.2, 2.5E+20, x]
          (%o2)                         done
          (%i3) example (coeff);
          (%i4) coeff(b+tan(x)+2*a*tan(x) = 3+5*tan(x),tan(x))
          (%o4)                      2 a + 1 = 5
          (%i5) coeff(1+x*%e^x+y,x,0)
          (%o5)                         y + 1
          (%o5)                         done



File: maxima.info,  Node: Linha de Comandos,  Next: Operadores,  Prev: Ajuda,  Up: Top

4 Linha de Comandos
*******************

* Menu:

* Introdução a Linha de Comandos::
* Definições para Linha de Comandos::


File: maxima.info,  Node: Introdução a Linha de Comandos,  Next: Definições para Linha de Comandos,  Prev: Linha de Comandos,  Up: Linha de Comandos

4.1 Introdução a Linha de Comandos
==================================

 -- Operador: '
     O operador apóstrofo `'' evita avaliação.

     Aplicado a um símbolo, o apóstrofo evita avaliação do símbolo.

     Aplicado a uma chamada de função, o apóstrofo evita avaliação da
     chamada de função, embora os argumentos da função sejam ainda
     avaliados (se a avaliação não for de outra forma evitada).  O
     resultado é a forma substantiva da chamada de função.

     Aplicada a uma espressão com parêntesis, o apóstrofo evita
     avaliação de todos os símbolos e chamadas de função na expressão.
     E.g., `'(f(x))' significa não avalie a expressão `f(x)'.  `'f(x)'
     (com apóstrofo aplicado a `f' em lugar de `f(x)') retorna a forma
     substantiva de `f' aplicada a `[x]'.

     O apóstrofo nao evita simplificação.

     Quando o sinalizador global `noundisp' for `true', substantivos
     são mostrados com um apóstrofo.  Esse comutador é sempre `true'
     quando mostrando definições de funções.

     Veja também operador apóstrofo-apóstrofo `''' e `nouns'.

     Exemplos:

     Aplicado a um símbolo, o apóstrofo evita avaliação do símbolo.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Aplicado a uma chamada de função, o apóstrofo evita avaliação da
     chamada de função.  O resultado é a forma substantiva da chamada
     de função.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Aplicado a uma expressão com parêntesis, o apóstrofo evita
     avaliação de todos os símbolos e chamadas de função na expressão.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     O apóstrofo não evita simplificação.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1


 -- Operador: "
     O operador apóstrofo-apóstrofo `''' (dois apóstrofost) modifica
     avaliação em expressões de entrada.

     Aplicado a uma expressão geral <expr>, apóstrofo-apóstrofo faz com
     que o valor de <expr> seja substituído por <expr> na expressão de
     entrada.

     Aplicado ao operadro de uma expressão, apóstrofo-apóstrofo
     modifica o operadro de um susbstantivo para um verbo (se esse
     operador não for já um verbo).

     O operador apóstrofo-apóstrofo é aplicado através do passador de
     entrada; o apóstrofo-apóstrofo não é armazenado como parte de uma
     expressão de entrada passada.  O operador apóstrofo-apóstrofo é
     sempre aplicado tão rapidamente quanto for passado, e não pode
     receber um terceiro apóstrofo.  Dessa forma faz com que ocorra
     avaliação quando essa avaliação for de outra forma suprimida, da
     mesma forma que em definições de função, definições de expressãoes
     lambda, e expressões que recebem um apóstrofo simples `''.

     Apóstrofo-apóstrofo é reconhecido por `batch' e `load'.

     Veja também o operador apóstrofo `'' e `nouns'.

     Exemplos:

     Aplicado a uma expressão geral <expr>, apóstrofo-apóstrofo fazem
     com que o valor de <expr> seja substituido por <expr> na expressão
     de entrada.

          (%i1) expand ((a + b)^3);
                               3        2      2      3
          (%o1)               b  + 3 a b  + 3 a  b + a
          (%i2) [_, ''_];
                                   3    3        2      2      3
          (%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i3) [%i1, ''%i1];
                                   3    3        2      2      3
          (%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
          (%o4)                   [cc, dd, 17, 29]
          (%i5) foo_1 (x) := aa - bb * x;
          (%o5)                 foo_1(x) := aa - bb x
          (%i6) foo_1 (10);
          (%o6)                      cc - 10 dd
          (%i7) ''%;
          (%o7)                         - 273
          (%i8) ''(foo_1 (10));
          (%o8)                         - 273
          (%i9) foo_2 (x) := ''aa - ''bb * x;
          (%o9)                 foo_2(x) := cc - dd x
          (%i10) foo_2 (10);
          (%o10)                        - 273
          (%i11) [x0 : x1, x1 : x2, x2 : x3];
          (%o11)                    [x1, x2, x3]
          (%i12) x0;
          (%o12)                         x1
          (%i13) ''x0;
          (%o13)                         x2
          (%i14) '' ''x0;
          (%o14)                         x3

     Aplicado ao operador de uma expressão, apóstrofo-apóstrofo muda o
     operadro de um substantivo para um verbo (se esse operadro não for
     já um verbo).

          (%i1) sin (1);
          (%o1)                        sin(1)
          (%i2) ''sin (1);
          (%o2)                    0.8414709848079
          (%i3) declare (foo, noun);
          (%o3)                         done
          (%i4) foo (x) := x - 1729;
          (%o4)                 ''foo(x) := x - 1729
          (%i5) foo (100);
          (%o5)                       foo(100)
          (%i6) ''foo (100);
          (%o6)                        - 1629

     O operador apóstrofo-apóstrofo é aplicado por meio de um passador
     de entrada; operador-apóstrofo não é armazenado como parte da
     expressão de entrada.

          (%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
          (%o1)                 [bb, dd, 1234, 5678]
          (%i2) aa + cc;
          (%o2)                        dd + bb
          (%i3) display (_, op (_), args (_));
                                     _ = cc + aa

                                   op(cc + aa) = +

                              args(cc + aa) = [cc, aa]

          (%o3)                         done
          (%i4) ''(aa + cc);
          (%o4)                         6912
          (%i5) display (_, op (_), args (_));
                                     _ = dd + bb

                                   op(dd + bb) = +

                              args(dd + bb) = [dd, bb]

          (%o5)                         done

     Apóstrofo apóstrofo faz com que ocorra avaliação quando a
     avaliação tiver sido de outra forma suprimida, da mesma forma que
     em definições de função, da mesma forma que em definições de
     função lambda expressions, E expressões que recebem o apóstrofo
     simples `''.

          (%i1) foo_1a (x) := ''(integrate (log (x), x));
          (%o1)               foo_1a(x) := x log(x) - x
          (%i2) foo_1b (x) := integrate (log (x), x);
          (%o2)           foo_1b(x) := integrate(log(x), x)
          (%i3) dispfun (foo_1a, foo_1b);
          (%t3)               foo_1a(x) := x log(x) - x

          (%t4)           foo_1b(x) := integrate(log(x), x)

          (%o4)                      [%t3, %t4]
          (%i4) integrate (log (x), x);
          (%o4)                     x log(x) - x
          (%i5) foo_2a (x) := ''%;
          (%o5)               foo_2a(x) := x log(x) - x
          (%i6) foo_2b (x) := %;
          (%o6)                    foo_2b(x) := %
          (%i7) dispfun (foo_2a, foo_2b);
          (%t7)               foo_2a(x) := x log(x) - x

          (%t8)                    foo_2b(x) := %

          (%o8)                      [%t7, %t8]
          (%i8) F : lambda ([u], diff (sin (u), u));
          (%o8)             lambda([u], diff(sin(u), u))
          (%i9) G : lambda ([u], ''(diff (sin (u), u)));
          (%o9)                  lambda([u], cos(u))
          (%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
          (%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                              k                  k
          (%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
          (%o11)             b  + a  + b  + a  + b  + a
                              3    3    2    2    1    1



File: maxima.info,  Node: Definições para Linha de Comandos,  Prev: Introdução a Linha de Comandos,  Up: Linha de Comandos

4.2 Definições para Linha de Comandos
=====================================

 -- Função: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     provê um nome alternativo para uma função (de utilizador ou de
     sistema), variável, array, etc.  Qualquer número de argumentos
     pode ser usado.


 -- Variável de opção: debugmode
     Valor por omissão: `false'

     Quando um erro do Maxima ocorre, Maxima iniciará o depurador se
     `debugmode' for `true'.  O utilizador pode informar comandos para
     examinar o histórico de chamadas, marcar pontos de parada,
     percorrer uma linha por vez o código do Maxima, e assim por
     diante.  Veja `debugging' para uma lista de opções do depurador.

     Habilitando `debugmode' por meio da alteração de seu valor para
     `true', não serão capturados erros do Lisp.


 -- Função: ev (<expr>, <arg_1>, ..., <arg_n>)
     Avalia a expressão <expr> no ambiente especificado pelos
     argumentos <arg_1>, ..., <arg_n>.  Os argumentos são comutadores
     (sinalizadores Booleanos), atribuições, equações, e funções.  `ev'
     retorna o resultado (outra expressão) da avaliação.

     A avaliação é realizada em passos, como segue.

       1. Primeiro o ambiente é preparado examinando os argumentos que
          podem ser quaisquer ou todos os seguintes.

             * `simp' faz com que <expr> seja simplificado
               independentemente da posição do comutador `simp' que
               inibe simplificação se `false'.

             * `noeval' suprime a fase de avaliação de `ev' (veja passo
               (4) adiante).  Isso é útil juntamente com outros
               comutadores e faz com que <expr> seja simplificado
               novamente sem ser reavaliado.

             * `nouns' causa a avaliação de formas substantivas
               (tipicamente funções não avaliadas tais como
               `'integrate' ou `'diff') em <expr>.

             * `expand' causa expansão.

             * `expand (<m>, <n>)' causa expansão, alterando os valores
               de `maxposex' e `maxnegex' para <m> e <n>
               respectivamente.

             * `detout' faz com que qualquer matriz inversa calculada
               em <expr> tenha seu determinante mantido fora da inversa
               ao invés de dividindo a cada elemento.

             * `diff' faz com que todas as diferenciações indicadas em
               <expr> sejam executadas.

             * `derivlist (<x>, <y>, <z>, ...)' causa somente
               diferenciações referentes às variáveis indicadas.

             * `float' faz com que números racionais não inteiros sejam
               convertidos para ponto flutuante.

             * `numer' faz com que algumas funções matemáticas
               (incluindo a exponenciação) com argumentos sejam
               valiadas em ponto flutuante.  Isso faz com que variávels
               em <expr> que tenham sido dados numervals (valores
               numéricos) sejam substituídas por seus valores.  Isso
               também modifica o comutador `float' para activado.

             * `pred' faz com que predicados (expressões que podem ser
               avaliados em `true' ou `false') sejam avaliadas.

             * `eval' faz com que uma avaliação posterior de <expr>
               ocorra.  (Veja passo (5) adiante.)  `eval' pode ocorrer
               múltiplas vezes.  Para cada instância de `eval', a
               expressão é avaliada novamente.

             * `A' onde `A' é um átomo declarado seja um sinalizador de
               avaliação (veja `evflag') faz com que `A' seja associado
               a `true' durante a avaliação de <expr>.

             * `V: expresão' (ou alternativamente `V=expressão') faz
               com que `V' seja associado ao valor de `expressão'
               durante a avaliação de <expr>.  Note que se `V' é uma
               opção do Maxima, então `expression' é usada para seu
               valor durante a avaliação de <expr>.  Se mais que um
               argumento para `ev' é desse tipo então a associação
               termina em paralelo.  Se `V' é uma expressão não atômica
               então a substituição, ao invés de uma associação, é
               executada.

             * `F' onde `F', um nome de função, tenha sido declarado
               para ser uma função de avaliação (veja `evfun') faz com
               que `F' seja aplicado a <expr>.

             * Qualquer outro nome de função (e.g., `sum') causa a
               avaliação de ocorrências desses nomes em <expr> mesmo
               que eles tenham sido verbos.

             * De forma adicional uma função ocorrendo em <expr>
               (digamos `F(x)') pode ser definida localmente para o
               propósito dessa avaliação de <expr> dando `F(x) :=
               expressão' como um argumento para `ev'.

             * Se um átomo não mensionado acima ou uma variável
               subscrita ou expressão subscrita for dada como um
               argumento, isso é avaliado e se o resultado for uma
               equação ou uma atribuição então a associação indicada ou
               substituição é executada.  Se o resultado for uma lista
               então os membros da lista serão tratados  como se eles
               fossem argumentos adicionais dados para `ev'.  Isso
               permite que uma lista de equações seja dada (e.g. `[X=1,
               Y=A**2]') ou que seja dado uma lista de nomes de
               equações (e.g., `[%t1, %t2]' onde `%t1' e `%t2' são
               equações) tais como aquelas listas retornadas por
               `solve'.

          Os argumentos de `ev' podem ser dados em qualquer ordem com
          exceção de substituições de equações que são manuseadas em
          sequência, da esquerda para a direita, e funções de avaliação
          que são compostas, e.g., `ev (<expr>, ratsimp, realpart)' são
          manuseadas como `realpart (ratsimp (<expr>))'.

          Os comutadores `simp', `numer', `float', e `pred' podem
          também ser alterados localmente em um bloco, ou globalmente
          no Maxima dessa forma eles irã permanecer em efeito até serem
          resetados ao término da execução do bloco.

          Se <expr> for uma expressão racional canónica (CRE), então a
          expressão retornada por `ev' é também uma CRE, contanto que
          os comutadores `numer' e `float' não sejam ambos `true'.

       2. Durante o passo (1), é feito uma lista  de variáveis não
          subscritas aparecendo do lado esquerdo das equações nos
          argumentos ou nos valores de alguns argumentos se o valor for
          uma equação.  As variáveis (variáveis subscritas que não
          possuem funções array associadas bem como variáveis não
          subscritas) na expressão <expr> são substituídas por seus
          valores globais, excepto para esse aparecendo nessa lista.
          Usualmente, <expr> é apenas um rótulo ou `%' (como em `%i2'
          no exemplo adiante), então esse passo simplesmente repete a
          expressão nomeada pelo rótulo, de modo que `ev' possa
          trabalhar sobre isso.

       3. Se quaisquer substituições tiveem sido indicadas pelos
          argumentos, elas serão realizadas agora.

       4. A expressão resultante é então reavaliada (a menos que um dos
          argumentos seja `noeval') e simplificada conforme os
          argumentos.  Note que qualquer chamada de função em <expr>
          será completada depois das variáveis nela serem avalidas e
          que `ev(F(x))' dessa forma possa comportar-se como `F(ev(x))'.

       5. Para cada instância de `eval' nos argumentos, os passos (3) e
          (4) são repetidos.

     Exemplos

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, sin, expand, diff, x=2, y=1);
                                    2
          (%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682

     Uma sintaxe alternativa de alto nível tem sido provida por `ev',
     por meio da qual se pode apenas digitar seus argumentos, sem o
     `ev()'.  Isto é, se pode escrever simplesmente

          <expr>, <arg_1>, ..., <arg_n>

     Isso não é permitido como parte de outra expressão, e.g., em
     funções, blocos, etc.

     Observe o processo de associação paralela no seguinte exemplo.

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solution

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true


 -- Propriedade: evflag
     Quando um símbolo <x> tem a propriedade `evflag', as expressões
     `ev(<expr>, <x>)' e `<expr>, <x>' (na linha de comando interativa)
     são equivalentes a `ev(<expr>, <x> = true)'.  Isto é, <x> está
     associada a `true' enquanto <expr> for avaliada.

     A expressão `declare(<x>, evflag)' fornece a propriedade `evflag'
     para a variável <x>.

     Os sinalizadores que possuem a propriedade `evflag' por padrão são
     os seguintes: `algebraic', `cauchysum', `demoivre', `dotscrules',
     `%emode', `%enumer', `exponentialize', `exptisolate', `factorflag',
     `float', `halfangles', `infeval', `isolate_wrt_times', `keepfloat',
     `letrat', `listarith', `logabs', `logarc', `logexpand',
     `lognegint', `lognumer', `m1pbranch', `numer_pbranch',
     `programmode', `radexpand', `ratalgdenom', `ratfac', `ratmx',
     `ratsimpexpons', `simp', `simpsum', `sumexpand', e `trigexpand'.

     Exemplos:

          (%i1) sin (1/2);
                                           1
          (%o1)                        sin(-)
                                           2
          (%i2) sin (1/2), float;
          (%o2)                   0.479425538604203
          (%i3) sin (1/2), float=true;
          (%o3)                   0.479425538604203
          (%i4) simp : false;
          (%o4)                         false
          (%i5) 1 + 1;
          (%o5)                         1 + 1
          (%i6) 1 + 1, simp;
          (%o6)                           2
          (%i7) simp : true;
          (%o7)                         true
          (%i8) sum (1/k^2, k, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o8)                        >    --
                                      /      2
                                      ====  k
                                      k = 1
          (%i9) sum (1/k^2, k, 1, inf), simpsum;
                                           2
                                        %pi
          (%o9)                         ----
                                         6
          (%i10) declare (aa, evflag);
          (%o10)                        done
          (%i11) if aa = true then SIM else NÃO;
          (%o11)                         NÃO
          (%i12) if aa = true then SIM else NÃO, aa;
          (%o12)                         SIM


 -- Propriedade: evfun
     Quando uma função <F> tem a propriedade `evfun', as expressões
     `ev(<expr>, <F>)' e `<expr>, <F>' (na linha de comando interativa)
     são equivalentes a `<F>(ev(<expr>))'.

     Se duas ou mais funções <F>, <G>, etc., que possuem a propriedade
     `evfun' forem especificadas, as funções serão aplicadas na ordem
     em que forem especificadas.

     A expressão `declare(<F>, evfun)' fornece a propriedade `evfun'
     para a função <F>.

     As funções que possuem a propriedade `evfun' por padrão são as
     seguintes: `bfloat', `factor', `fullratsimp', `logcontract',
     `polarform', `radcan', `ratexpand', `ratsimp', `rectform',
     `rootscontract', `trigexpand', e `trigreduce'.

     Exemplos:

          (%i1) x^3 - 1;
                                        3
          (%o1)                        x  - 1
          (%i2) x^3 - 1, factor;
                                          2
          (%o2)                 (x - 1) (x  + x + 1)
          (%i3) factor (x^3 - 1);
                                          2
          (%o3)                 (x - 1) (x  + x + 1)
          (%i4) cos(4 * x) / sin(x)^4;
                                      cos(4 x)
          (%o4)                       --------
                                         4
                                      sin (x)
          (%i5) cos(4 * x) / sin(x)^4, trigexpand;
                           4           2       2         4
                        sin (x) - 6 cos (x) sin (x) + cos (x)
          (%o5)         -------------------------------------
                                          4
                                       sin (x)
          (%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                                     2         4
                                6 cos (x)   cos (x)
          (%o6)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                                     2         4
                                6 cos (x)   cos (x)
          (%o7)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i8) declare ([F, G], evfun);
          (%o8)                         done
          (%i9) (aa : bb, bb : cc, cc : dd);
          (%o9)                          dd
          (%i10) aa;
          (%o10)                         bb
          (%i11) aa, F;
          (%o11)                        F(cc)
          (%i12) F (aa);
          (%o12)                        F(bb)
          (%i13) F (ev (aa));
          (%o13)                        F(cc)
          (%i14) aa, F, G;
          (%o14)                      G(F(cc))
          (%i15) G (F (ev (aa)));
          (%o15)                      G(F(cc))


 -- Variável de opção: infeval
     Habilita o modo "avaliação infinita".  `ev' repetidamente avalia
     uma expressão até que ela permaneça invariante.  Para prevenir uma
     variável, digamos `X', seja demoradamente avaliada nesso modo,
     simplesmente inclua `X='X' como um argumento para `ev'.
     Certamente expressões tais como `ev (X, X=X+1, infeval)' irão
     gerar um ciclo infinito.


 -- Função: kill (<a_1>, ..., <a_n>)
 -- Função: kill (labels)
 -- Função: kill (inlabels, outlabels, linelabels)
 -- Função: kill (<n>)
 -- Função: kill ([<m>, <n>])
 -- Função: kill (values, functions, arrays, ...)
 -- Função: kill (all)
 -- Função: kill (allbut (<a_1>, ..., <a_n>))
     Remove todas as associações (valor, funções, array, ou regra) dos
     argumentos <a_1>, ..., <a_n>.  Um argumento <a_k> pode ser um
     símbolo ou um elemento de array simples.  Quando <a_k> for um
     elemento de array simples, `kill' remove a associação daquele
     elemento sem afectar qualquer outro elemento do array.

     Muitos argumentos especiais são reconhecidos.  Diferentes famílias
     de argumentos podem ser combinadas, e.g., `kill (inlabels,
     functions, allbut (foo, bar))'

     todos os rótulos de entrada, de saída, e de expressões intermédias
     criados até então.  `kill (inlabels)' libera somente rótudos de
     entrada que começam com o valor corrente de `inchar'.  De forma
     semelhante, `kill (outlabels)' libera somente rótulos de saída que
     começam com o valor corrente de `outchar', e `kill (linelabels)'
     libera somente rótulos de expressões intermédias que começam com o
     valor corrente de `linechar'.

     `kill (<n>)', onde <n> é um inteiro, libera os <n> mais recentes
     rótulos de entrada e saída.

     `kill ([<m>, <n>])' libera rótulos de entrada e saída de <m> até
     <n>.

     `kill (<infolist>)', onde <infolist> é um item em `infolists'
     (tais como `values', `functions', ou `arrays') libera todos os
     ítens em <infolist>.  Veja também `infolists'.

     `kill (all)' liberar todos os ítens em todas as infolists.  `kill
     (all)' não retorna variáveis globais para seus valores padrões;
     Veja `reset' sobre esse ponto.

     `kill (allbut (<a_1>, ..., <a_n>))' remove a associação de todos
     os itens sobre todas as infolistas excepto para <a_1>, ..., <a_n>.
     `kill (allbut (<infolist>))' libera todos os ítens excepto para si
     próprio em <infolist>, onde <infolist> é `values', `functions',
     `arrays', etc.

     A memória usada por uma propriedade de associação não será
     liberada até que todos os símbolos sejam liberados disso.  Em
     particular, para liberar a memória usada pelo valor de um símbolo,
     deve-se liberar o rótulo de saída que mosta o valor associado, bem
     como liberando o próprio símbolo.

     `kill' coloca um apóstro em seus argumentos (não os avalia).  O
     operador apóstrofo-apóstrofo, `''', faz com que ocorra avaliação.

     `kill (<símbolo>)' libera todas as propriedades de <símbolo>.  Em
     oposição, `remvalue', `remfunction', `remarray', e `remrule'
     liberam uma propriedade específica.

     `kill' sempre retorna `done', igualmente se um argumento não tem
     associações.


 -- Função: labels (<símbolo>)
 -- Variável de sistema: labels
     Retorna a lista de rótulos de entradas, de saída, de expressões
     intermédias que começam com <símbolo>.  Tipicamente <símbolo> é o
     valor de `inchar', `outchar', ou `linechar'.  O caracter rótulo
     pode ser dado com ou sem o sinal de porcentagem, então, por
     exemplo, `i' e `%i' retornam o mesmo resultado.

     Se nenhum rótulo começa com <símbolo>, `labels' retorna uma lista
     vazia.

     A função `labels' não avalia seu argumento.  O operador
     apóstrofo-apóstrofo `''' faz com que ocorra avaliação.  Por
     exemplo, `labels (''inchar)' retorna os rótulos de entrada que
     começam com o caractere corrente do rótulo de entrada.

     A variável `labels' é uma lista de rótulos de entrada, saída, e de
     expressões intermédias, incluindo todos os rótulos anteriores se
     `inchar', `outchar', ou `linechar' que tiverem sido redefinidos.

     Por padrão, Maxima mostra o resultado de cada expressão de entrada
     do utilizador, dando ao resultado um rótulo de saída.  A exibição
     da saída é suprimida pelo encerramento da entrada com `$' (sinal
     de dolar) em lugar de `;' (ponto e vírgula).  Um rótulo de saída é
     construido e associado ao resultado, mas não é mostrado, e o
     rótulo pode ser referenciado da mesma forma que rótulos de saída
     mostrados.  Veja também `%', `%%', e `%th'.

     Rótulos de expressões intermédias podem ser gerados por algumas
     funções.  O sinalizador `programmode' controla se `solve' e
     algumas outras funções geram rótulos de expressões intermédias em
     lugar de retornar uma lista de expressões.  Algumas outras
     funções, tais como `ldisplay', sempre geram rótulos de expressões
     intermédias.

     Veja também `inchar', `outchar', `linechar', e `infolists'.


 -- Variável de sistema: linenum
     Retorna o número da linha do par corrente de expressões de entrada
     e saída.


 -- Variável de sistema: myoptions
     Valor por omissão: `[]'

     `myoptions' é a lista de todas as opções alguma vez alteradas pelo
     utilizador, tenha ou não ele retornado a alteração para o seu
     valor padrão.


 -- Variável de opção: nolabels
     Valor por omissão: `false'

     Quando `nolabels' for `true', rótulos de entrada e saída (`%i' e
     `%o', respectivamente) são mostrados, mas os rótulos não são
     associados aos resultados, e os rótulos não são anexados ao final
     da lista `labels'.  Uma vez que rótulos não são associados aos
     resultados, a reciclagem pode recuperar a memória tomada pelos
     resultados.

     De outra forma rótulos de entrada e saída são associados aos
     resultados, e os rótulos são anexados ao final da lista `labels'.

     Veja também `batch', `batchload', e `labels'.


 -- Variável de opção: optionset
     Valor por omissão: `false'

     Quando `optionset' for `true', Maxima mostrará uma mensagem sempre
     que uma opção do Maxima for alterada.  Isso é útil se o utilizador
     está incerto sobre a ortografia de alguma opção e quer ter certeza
     que a variável por ele atribuído um valor foi realmente uma
     variável de opção.


 -- Função: playback ()
 -- Função: playback (<n>)
 -- Função: playback ([<m>, <n>])
 -- Função: playback ([<m>])
 -- Função: playback (input)
 -- Função: playback (slow)
 -- Função: playback (time)
 -- Função: playback (grind)
     Mostra expressões de entrada, de saída, e expressões intermédias,
     sem refazer os cálculos.  `playback' somente mostra as expressões
     associadas a rótulos; qualquer outra saída (tais como textos
     impressos por `print' ou `describe', ou messagens de erro) não é
     mostrada.  Veja também `labels'.

     `playback' não avalia seus argumentos.  O operador
     apóstrofo-apóstrofo, `''', sobrepõe-se às aspas.  `playback'
     sempre retorna `done'.

     `playback ()' (sem argumentos) mostra todas as entradas, saídas e
     expressões intermédias geradas até então.  Uma expressão de saída
     é mostrada mesmo se for suprimida pelo terminador `$' quando ela
     tiver sido originalmente calculada.

     `playback (<n>)' mostra as mais recentes <n> expressões.  Cada
     entrada, saída e expressão intermédia conta como um.

     `playback ([<m>, <n>])' mostra entradas, saídas e expressões
     intermédias com os números de <m> até <n>, inclusive.

     `playback ([<m>])' é equivalente a `playback ([<m>, <m>])'; isso
     usualmente imprime um par de expressões de entrada e saída.

     `playback (input)' mostra todas as expressões de entrada geradas
     até então.

     `playback (slow)' insere pausas entre expressões e espera que o
     utilizador pressione `enter'.  Esse comportamento é similar a
     `demo'.  `playback (slow)' é útil juntamente com `save' ou
     `stringout' quando criamos um ficheiro secundário de armazenagem
     com a finalidade de capturar expressões úteis.

     `playback (time)' mostra o tempo de computação de cada expressão.

     `playback (grind)' mostra expressões de entrada no mesmo formato
     da função `grind'.  Expressões de saída não são afectadas pela
     opção `grind'.  Veja `grind'.

     Argumentos podem ser combinados, e.g., `playback ([5, 10], grind,
     time, slow)'.


 -- Função: printprops (<a>, <i>)
 -- Função: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Função: printprops (all, <i>)
     Mostra a propriedade como o indicador <i> associada com o átomo
     <a>.  <a> pode também ser uma lista de átomos ou o átomo `all'
     nesse caso todos os átomos com a propriedade dada serão usados.
     Por exemplo, `printprops ([f, g], atvalue)'.  `printprops' é para
     propriedades que não podem  ser mostradas de outra forma, i.e. para
     `atvalue', `atomgrad', `gradef', e `matchdeclare'.


 -- Variável de opção: prompt
     Valor por omissão: `_'

     `prompt' é o símbolo de linha de comando da função `demo', modo
     `playback (slow)', e da interrupção de ciclos do Maxima (como
     invocado por `break').


 -- Função: quit ()
     Encerra a sessão do Maxima.  Note que a função pode ser invocada
     como `quit();' ou `quit()$', não por sí mesma `quit'.

     Para parar um cálculo muito longo, digite `control-C'.  A ação
     padrão é retornar à linha de comando do Maxima.  Se
     `*debugger-hook*' é `nil', `control-C' abre o depurador Lisp.
     Veja também `debugging'.


 -- Função: remfunction (<f_1>, ..., <f_n>)
 -- Função: remfunction (all)
     Desassocia as definições de função dos síbolos <f_1>, ..., <f_n>.
     Os argumentos podem ser os nomes de funções comuns (criadas por
     meio de `:=' ou `define') ou funções macro (criadas por meio de
     `::=').

     `remfunction (all)' desassocia todas as definições de funcção.

     `remfunction' coloca um ap'ostrofo em seus argumentos (não os
     avalia).

     `remfunction' retorna uma lista de símbolos para a qual a
     definição de função foi desassociada.  `false' é retornado em
     lugar de qualquer símbolo para o qual não exista definição de
     função.


 -- Função: reset ()
     Retorna muitas variáveis globais e opções, e algumas outras
     variáveis, para seus valores padrões.

     `reset' processa as variáveis na lista Lisp
     `*variable-initial-values*'.  A macro Lisp `defmvar' coloca
     variáveis nessa lista (entre outras ações).  Muitas, mas não
     todas, variáveis globais e opções são definidas por `defmvar',  e
     algumas variáveis definidas por `defmvar' não são variáveis
     globais ou variáveis de opção.


 -- Variável de opção: showtime
     Valor por omissão: `false'

     Quando `showtime' for `true', o tempo de computação e o tempo
     decorrido são impressos na tela com cada expressão de saída.

     O tempo de cálculo é sempre gravado, então `time' e `playback'
     podem mostrar o tempo de cálculo mesmo quando `showtime' for
     `false'.

     Veja também `timer'.


 -- Função: sstatus (<recurso>, <pacote>)
     Altera o status de <recurso> em <pacote>.  Após `sstatus
     (<recurso>, <pacote>)' ser executado, `status (<recurso>,
     <pacote>)' retorna `true'.  Isso pode ser útil para quem escreve
     pacotes, para manter um registro de quais recursos os pacotes usam.


 -- Função: to_lisp ()
     Insere o sistema Lisp dentro do Maxima.  `(to-maxima)' retorna
     para o Maxima.


 -- Variável de sistema: values
     Valor inicial: `[]'

     `values' é uma lista de todas as varáveis de utilizador associadas
     (não opções Maxima ou comutadores).  A lista compreende símbolos
     associados por `:' , `::', ou `:='.



File: maxima.info,  Node: Operadores,  Next: Expressões,  Prev: Linha de Comandos,  Up: Top

5 Operadores
************

* Menu:

* N-Argumentos::
* Operador não fixado::
* Operador Pósfixado::
* Operador Préfixado::
* Operadores Aritméticos::
* Operadores Relacionais::
* Operadores Geral::


File: maxima.info,  Node: N-Argumentos,  Next: Operador não fixado,  Prev: Operadores,  Up: Operadores

5.1 N-Argumentos
================

Um operador `nary' é usado para denotar uma função com qualquer número
de argumentos, cada um dos quais é separado por uma ocorrência do
operador, e.g. A+B ou A+B+C.  A função `nary("x")'  é uma função de
extensão sintática para declarar x como sendo um operador `nary'.
Funções podem ser declaradas para serem `nary'.  Se `declare(j,nary);'
é concluída, diz ao simplicador para simplificar, e.g.
`j(j(a,b),j(c,d))' para `j(a, b, c, d)'.

   Veja também `syntax'.


File: maxima.info,  Node: Operador não fixado,  Next: Operador Pósfixado,  Prev: N-Argumentos,  Up: Operadores

5.2 Operador não fixado
=======================

Operadores `nofix' são usados para denotar funções sem argumentos.  A
mera presença de tal operador em um comando fará com que a função
correspondente seja avaliada.  Por exemplo, quando se digita "exit;"
para sair de uma parada do Maxima, "exit" tem comportamento similar a um
operador `nofix'.  A função `nofix("x")' é uma função de extensão
sintática que declara x como sendo um operador `nofix'.

   Veja também `syntax'.


File: maxima.info,  Node: Operador Pósfixado,  Next: Operador Préfixado,  Prev: Operador não fixado,  Up: Operadores

5.3 Operador Pósfixado
======================

Operadores `postfix' como a variedade `prefix' denotam funções de um
argumento simples, mas nesse caso  o argumento sucede imediatamente uma
ocorrência do operador na sequência de caracteres de entrada, e.g. 3! .
Uma função `postfix("x")' é uma função de extensão sintática que
declara x como sendo um operador `postfix'.

   Veja também `syntax'.


File: maxima.info,  Node: Operador Préfixado,  Next: Operadores Aritméticos,  Prev: Operador Pósfixado,  Up: Operadores

5.4 Operador Préfixado
======================

Um operador `prefix' é um que significa uma função de um argumento, o
qual imediatamente segue uma ocorrência do operador.  `prefix("x")' é
uma função de extensão sintática que declara x como sendo um operador
`prefix'.

   Veja também `syntax'.


File: maxima.info,  Node: Operadores Aritméticos,  Next: Operadores Relacionais,  Prev: Operador Préfixado,  Up: Operadores

5.5 Operadores Aritméticos
==========================

 -- Operador: +
 -- Operador: -
 -- Operador: *
 -- Operador: /
 -- Operador: ^
     Os símbolos `+' `*' `/' e `^' representam adição, multiplicação,
     divisão, e exponenciação, respectivamente.  O nome desses
     operadores são `"+"' `"*"' `"/"' e `"^"', os quais podem aparecer
     em lugares onde o nome da função ou operador é requerido.

     Os símbolos `+' e `-' representam a adição unária e a negação
     unária, respectivamente, e os nomes desses operadores são `"+"' e
     `"-"', respectivamente.

     A subtração `a - b' é representada dentro do Maxima como a
     adição, `a + (- b)'.  Expressões tais como `a + (- b)' são
     mostradas como subtração.  Maxima reconhece `"-"' somente como o
     nome do operador unário de negação, e não como o nome do operador
     binário de subração.

     A divisão `a / b' é representada dentro do Maxima como
     multiplicação, `a * b^(- 1)'.  Expressões tais como `a * b^(- 1)'
     são mostradas como divisão.  Maxima reconhece `"/"' como o nome do
     operador de divisão.

     A adição e a multiplicação são operadores enários e comutativos.
     a divisão e a exponenciação são operadores binários e não
     comutativos.

     Maxima ordena os operandos de operadores não comutativos para
     construir uma representação canónica.  Para armazenamento interno,
     a ordem é determinada por `orderlessp'.  Para mostrar na tela, a
     ordem para adição é determinada por `ordergreatp', e para a
     multiplicação, a ordem é a mesma da ordenação para armazenamento
     interno.

     Computações aritiméticas são realizadas sobre números literais
     (inteiro, racionais, números comuns em ponto flutuante, e grandes
     números em ponto flutuante de dupla precisão).  Execto a
     exponenciação, todas as operações aritméticas sobre números são
     simplificadas para números.  A exponenciação é simplificada para
     um número se ou o operando é um número comum em ponto flutuante ou
     um grande número em ponto flutuante de dupla precisão ou se o
     resultado for um inteiro exato ou um racional exato; de outra
     forma uma exponenciação pode ser simplificada para `sqrt' ou outra
     exponenciação ou permanecer inalterada.

     A propagação de números em ponto flutuante aplica-se a
     computações aritiméticas: Se qualquer operando for um grande
     número em ponto flutuante, o resultado é um grande número em ponto
     flutuante; de outra forma, se qualquer operando for um número em
     ponto flutuante comum, o resultado é um número comum em ponto
     flutuante; de outra forma, se os operandos forem racioanis ou
     inteiros e o resultado será um racional ou inteiro.

     Computaçãoes aritiméticas são uma simplificação, não uma
     avaliação.  Dessa forma a aritmética é realizada em  expressões
     com apóstrofo (mas simplificadas).

     Operações aritméticas são aplicadas elemento-por-elemento para
     listas quando a variável global `listarith' for `true', e sempre
     aplicada elemento-por-elemento para matrizes.  Quando um operando
     for uma lista ou uma matriz e outro for um operando de algum outro
     tipo, o outro operando é combinado com cada um dos elementos da
     lista ou matriz.

     Exemplos:

     Adição e multiplicação são opeadores enários comutativos.  Maxima
     ordena os operandos para construir uma representação canónica.  Os
     nomes desses operadores são `"+"' e `"*"'.

          (%i1) c + g + d + a + b + e + f;
          (%o1)               g + f + e + d + c + b + a
          (%i2) [op (%), args (%)];
          (%o2)              [+, [g, f, e, d, c, b, a]]
          (%i3) c * g * d * a * b * e * f;
          (%o3)                     a b c d e f g
          (%i4) [op (%), args (%)];
          (%o4)              [*, [a, b, c, d, e, f, g]]
          (%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
          (%o5)                    3 x + 2 a + 19
          (%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                           2  3
          (%o6)                       144 a  x

     Divisão e exponenciação são operadores binários e não comutativos.
     Os nomes desses operadores são `"/"' e `"^"'.

          (%i1) [a / b, a ^ b];
                                        a   b
          (%o1)                        [-, a ]
                                        b
          (%i2) [map (op, %), map (args, %)];
          (%o2)              [[/, ^], [[a, b], [a, b]]]
          (%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                                        a   b
          (%o3)                        [-, a ]
                                        b

     Subtração e divisão são representados internamente em termos de
     adição e multiplicação, respectivamente.

          (%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
          (%o1)                      [+, a, - b]
          (%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                             1
          (%o2)                       [*, a, -]
                                             b

     Cálculos são realizados sobre números lterais.  A propagação de
     números em poto flutuante aplica-se.

          (%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                                 5
          (%o1)                   b + sqrt(11) + -
                                                 2
          (%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
          (%o2)                   [46, 46.0, 4.6b1]

     Computações aritméticas são uma simplificação, não uma
     avaliação.

          (%i1) simp : false;
          (%o1)                         false
          (%i2) '(17 + 29*11/7 - 5^3);
                                        29 11    3
          (%o2)                    17 + ----- - 5
                                          7
          (%i3) simp : true;
          (%o3)                         true
          (%i4) '(17 + 29*11/7 - 5^3);
                                          437
          (%o4)                         - ---
                                           7

     A aritmética é realizada elemento-por-elemento para listas lists
     (dependendo de `listarith') e dependendo de matrizes.

          (%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                                  [ a - 1  x - 2 ]
          (%o1)                   [              ]
                                  [ h - 3  u - 4 ]
          (%i2) 5 * matrix ([a, x], [h, u]);
                                    [ 5 a  5 x ]
          (%o2)                     [          ]
                                    [ 5 h  5 u ]
          (%i3) listarith : false;
          (%o3)                         false
          (%i4) [a, c, m, t] / [1, 7, 2, 9];
                                    [a, c, m, t]
          (%o4)                     ------------
                                    [1, 7, 2, 9]
          (%i5) [a, c, m, t] ^ x;
                                                x
          (%o5)                     [a, c, m, t]
          (%i6) listarith : true;
          (%o6)                         true
          (%i7) [a, c, m, t] / [1, 7, 2, 9];
                                        c  m  t
          (%o7)                     [a, -, -, -]
                                        7  2  9
          (%i8) [a, c, m, t] ^ x;
                                    x   x   x   x
          (%o8)                   [a , c , m , t ]


 -- Operador: **
     Operador de exponenciação.  Maxima reconhece `**' como o mesmo
     operador que `^' em entrada, e `**' é mostrado como `^' em saída
     unidimensional, ou colocando o expoente  como sobrescrito em saída
     bidimensional.

     A função `fortran' mostra o operador de exponenciação com como
     `**', independente de a entrada ter sido na forma `**' ou a forma
     `^'.

     Exemplos:

          (%i1) is (a**b = a^b);
          (%o1)                         true
          (%i2) x**y + x^z;
                                        z    y
          (%o2)                        x  + x
          (%i3) string (x**y + x^z);
          (%o3)                        x^z+x^y
          (%i4) fortran (x**y + x^z);
                x**z+x**y
          (%o4)                         done



File: maxima.info,  Node: Operadores Relacionais,  Next: Operadores Geral,  Prev: Operadores Aritméticos,  Up: Operadores

5.6 Operadores Relacionais
==========================

 -- Operador: <
 -- Operador: <=
 -- Operador: >=
 -- Operador: >


File: maxima.info,  Node: Operadores Geral,  Prev: Operadores Relacionais,  Up: Operadores

5.7 Operadores Geral
====================

 -- Operador: ^^

 -- Operador: !
     O operador factorial.  Para qualquer número complexo `x'
     (incluíndo números inteiros, racionais, e reais) excepto para
     inteiros negativos, `x!' é definido como `gamma(x+1)'.

     Para um inteiro `x', `x!' simplifica para o produto de inteiros de
     1 a `x' inclusive.  `0!' simplifica para 1.  Para um número em
     ponto flutuante `x', `x!' simplifica para o valor de `gamma (x+1)'.
     Para `x' igual a `n/2' onde `n' é um inteiro ímpar, `x!'
     simplifica para um factor racional vezes `sqrt (%pi)' (uma vez que
     `gamma (1/2)' é igual a `sqrt (%pi)').  Se `x' for qualquer outra
     coisa, `x!' não é simplificado.

     As variáveis `factlim', `minfactorial', e `factcomb' controlam a
     simplificação de expressões contendo factoriais.

     As funções `gamma', `bffac', e `cbffac' são variedades da
     função `gamma'.  `makegamma' substitui `gamma' para funções
     relacionadas a factoriais.

     Veja também `binomial'.

     O factorial de um inteiro, inteiro dividido por dois, ou argumento
     em ponto flutuante é simplificado a menos que o operando seja
     maior que `factlim'.

          (%i1) factlim : 10;
          (%o1)                          10
          (%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
          +            105 sqrt(%pi)
          +(%o2)   [1, -------------, 81.44668037931199, 40320, 20!]
          +                 16

     O factorial de um número complexo, constante conhecida, ou
     expressão geral não é simplificado.  Ainda assim pode ser possível
     simplificar o factorial após avaliar o operando.

          (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
          (%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
          (%i2) ev (%, numer, %enumer);
          (%o2) [(%i + 1)!, 7.188082728976037, 4.260820476357,
                                                         1.227580202486819]

     O factorial de um símbolo não associado não é simplificado.

          (%i1) kill (foo);
          (%o1)                         done
          (%i2) foo!;
          (%o2)                         foo!

     Factoriais são simplificados, não avaliados.  Dessa forma `x!'
     pode ser substituído mesmo em uma expressão com apóstrofo.

          (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                    105 sqrt(%pi)
          (%o1) [1, -------------, 81.44668037931199, 40320,
                         16
                                                       2432902008176640000]


 -- Operador: !!
     O operador de duplo factorial.

     Para um número inteiro, número em ponto flutuante, ou número
     racional `n', `n!!' avalia para o produto `n (n-2) (n-4) (n-6) ...
     (n - 2 (k-1))' onde `k' é igual a `entier (n/2)', que é, o maior
     inteiro menor que ou igual a `n/2'.  Note que essa definição não
     coincide com outras definições publicadas para argumentos que não
     são inteiros.

     Para um inteiro par (ou ímpar) `n', `n!!' avalia para o produto de
     todos os inteiros consecutivos pares (ou ímpares) de 2 (ou 1) até
     `n' inclusive.

     Para um argumento `n' que não é um número inteiro, um número em
     ponto flutuante, ou um número racional, `n!!' retorna uma forma
     substantiva `genfact (n, n/2, 2)'.


 -- Operador: #
     Representa a negação da igualdade sintática `='.

     Note que pelo facto de as regras de avaliação de expressões
     predicadas (em particular pelo facto de `not <expr>' fazer com que
     ocorra a avaliação de <expr>), a forma `not <a> = <b>' não é
     equivalente à forma `<a> # <b>' em alguns casos.

     Note que devido às regras para avaliação de expressões predicadas
     (em particular devido a `not <expr>' fazer com que a avaliação de
     <expr> ocorra), `not <a> = <b>' é equivalente a `is(<a> # <b>)',
     em lugar de ser equivalente a `<a> # <b>'.

     Exemplos:
          (%i1) a = b;
          (%o1)                         a = b
          (%i2) é (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not a = b;
          (%o4)                         true
          (%i5) é (a # b);
          (%o5)                         true
          (%i6) é (not a = b);
          (%o6)                         true


 -- Operador: .
     O operador ponto, para multiplicação (não comutativa) de matrizes.
     Quando "." é usado com essa finalidade, espaços devem ser
     colocados em ambos os lados desse operador, e.g. A . B.  Isso
     distingue o operador ponto plenamente de um ponto decimal em um
     número em ponto flutuante.

     Veja também `dot', `dot0nscsimp', `dot0simp', `dot1simp',
     `dotassoc', `dotconstrules', `dotdistrib', `dotexptsimp',
     `dotident', e `dotscrules'.


 -- Operador: :
     O operador de atribuição.  E.g. A:3 escolhe a variável A para 3.


 -- Operador: ::
     Operador de atribuição.  :: atribui o valor da expressão em seu
     lado direito para o valor da quantidade na sua esquerda, que pode
     avaliar para uma variável atômica ou variável subscrita.


 -- Operador: ::=
     Operador de definição de função de macro.  `::=' define uma
     função (chamada uma "macro" por razões históricas) que coloca um
     apóstrofo em seus argumentos (evitando avaliação), e a expressão
     que é retornada (chamada a "expansão de macro") é avaliada no
     contexto a partir do qual a macro foi chamada.  Uma função de
     macro é de outra forma o mesmo que uma função comum.

     `macroexpand' retorna uma expansão de macro (sem avaliar a
     expansão).  `macroexpand (foo (x))' seguida por `''%' é
     equivalente a `foo (x)' quando `foo' for uma função de macro.

     `::=' coloca o nome da nova função de macro dentro da lista global
     `macros'.  `kill', `remove', e `remfunction' desassocia
     definições de função de macro e remove nomes de `macros'.

     `fundef' e `dispfun' retornam respectivamente uma definição de
     função de macro e uma atribuição dessa definição a um rótulo,
     respectivamente.

     Funções de macro comumente possuem expressões `buildq' e `splice'
     para construir uma expressão, que é então avaliada.

     Exemplos

     Uma função de macro coloca um apóstrofo em seus argumentos
     evitando então a avaliação, então mensagem (1) mostra `y - z', não
     o valor de `y - z'.  A expansão de macro (a expressão com
     apóstrofo `'(print ("(2) x is equal to", x))' é avaliada no
     contexto a partir do qual a macro for chamada, mostrando a
     mensagem (2).

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printq1 (x) ::= block (print ("(1) x é igual a", x), '(print ("(2) x é igual a", x)));
          (%o4) printq1(x) ::= block(print("(1) x é igual a", x),
                                          '(print("(2) x é igual a", x)))
          (%i5) printq1 (y - z);
          (1) x é igual a y - z
          (2) x é igual a %pi
          (%o5)                          %pi

     Uma função comum avalia seus argumentos, então message (1) mostra
     o valor de `y - z'.  O valor de retorno não é avaliado, então
     mensagem (2) não é mostrada até a avaliação explícita `''%'.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printe1 (x) := block (print ("(1) x é igual a", x), '(print ("(2) x é igual a", x)));
          (%o4) printe1(x) := block(print("(1) x é igual a", x),
                                          '(print("(2) x é igual a", x)))
          (%i5) printe1 (y - z);
          (1) x é igual a 1234 - 1729 w
          (%o5)              print((2) x é igual a, x)
          (%i6) ''%;
          (2) x é igual a %pi
          (%o6)                          %pi

     `macroexpand' retorna uma expansão de macro.  `macroexpand (foo
     (x))' seguido por `''%' é equivalente a `foo (x)' quando `foo' for
     uma função de macro.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) g (x) ::= buildq ([x], print ("x é igual a", x));
          (%o4)    g(x) ::= buildq([x], print("x é igual a", x))
          (%i5) macroexpand (g (y - z));
          (%o5)              print(x é igual a, y - z)
          (%i6) ''%;
          x é igual a 1234 - 1729 w
          (%o6)                     1234 - 1729 w
          (%i7) g (y - z);
          x é igual a 1234 - 1729 w
          (%o7)                     1234 - 1729 w


 -- Operador: :=
     O operador de definição de função.  E.g. `f(x):=sin(x)' define uma
     função `f'.


 -- Operador: =
     O operador de equação.

     Uma expressão `<a> = <b>', por si mesma, representa uma equação
     não avaliada, a qual pode ou não se manter.  Equações não
     avaliadas podem aparecer como argumentos para `solve' e `algsys'
     ou algumas outras funções.

     A função `is' avalia `=' para um valor Booleano.  `is(<a> = <b>)'
     avalia `<a> = <b>' para `true' quando <a> e <b> forem idênticos.
     Isto é, <a> e <b> forem átomos que são idênticos, ou se eles não
     forem átomos e seus operadores forem idênticos e seus argumentos
     forem idênticos.  De outra forma, `is(<a> = <b>)' avalia para
     `false'; `is(<a> = <b>)' nunca avalia para `unknown'.  Quando
     `is(<a> = <b>)' for `true', <a> e <b> são ditos para serem
     sintaticamente iguais, em contraste para serem expressões
     equivalentes, para as quais `is(equal(<a>, <b>))' é `true'.
     Expressões podem ser equivalentes e não sintáticamente iguais.

     A negação de `=' é representada por `#'.  Da mesma forma que com
     `=', uma expressão `<a> # <b>', por si mesma, não é avaliada.
     `is(<a> # <b>)' avalia `<a> # <b>' para `true' ou `false'.

     Complementando a função `is', alguns outros operadores avaliam `='
     e `#' para `true' ou `false', a saber `if', `and', `or', e `not'.

     Note que pelo facto de as regras de avaliação de expressões
     predicadas (em particular pelo facto de `not <expr>' fazer com que
     ocorra a avaliação de <expr>), a forma `not <a> = <b>' é
     equivalente a `is(<a> # <b>)', em lugar de ser equivalente a `<a>
     # <b>'.

     `rhs' e `lhs' retornam o primeiro membro e o segundo membro de uma
     equação, respectivamente, de uma equação ou inequação.

     Veja também `equal' e `notequal'.

     Exemplos:

     Uma expressão `<a> = <b>', por si mesma, representa uma equação
     não avaliada, a qual pode ou não se manter.

          (%i1) eq_1 : a * x - 5 * y = 17;
          (%o1)                    a x - 5 y = 17
          (%i2) eq_2 : b * x + 3 * y = 29;
          (%o2)                    3 y + b x = 29
          (%i3) solve ([eq_1, eq_2], [x, y]);
                                  196         29 a - 17 b
          (%o3)          [[x = ---------, y = -----------]]
                               5 b + 3 a       5 b + 3 a
          (%i4) subst (%, [eq_1, eq_2]);
                   196 a     5 (29 a - 17 b)
          (%o4) [--------- - --------------- = 17,
                 5 b + 3 a      5 b + 3 a
                                            196 b     3 (29 a - 17 b)
                                          --------- + --------------- = 29]
                                          5 b + 3 a      5 b + 3 a
          (%i5) ratsimp (%);
          (%o5)                  [17 = 17, 29 = 29]

     `is(<a> = <b>)' avalia `<a> = <b>' para `true' quando <a> e <b>
     são sintaticamente iguais (isto é, identicos).  Expressões podem
     ser equivalentes e não sintaticamente iguais.

          (%i1) a : (x + 1) * (x - 1);
          (%o1)                    (x - 1) (x + 1)
          (%i2) b : x^2 - 1;
                                        2
          (%o2)                        x  - 1
          (%i3) [is (a = b), is (a # b)];
          (%o3)                     [false, true]
          (%i4) [is (equal (a, b)), is (notequal (a, b))];
          (%o4)                     [true, false]

     Alguns operadores avaliam `=' e `#' para `true' ou `false'.

          (%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else BAR;
          (%o1)                          FOO
          (%i2) eq_3 : 2 * x = 3 * x;
          (%o2)                       2 x = 3 x
          (%i3) eq_4 : exp (2) = %e^2;
                                        2     2
          (%o3)                       %e  = %e
          (%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
          (%o4)                  [false, true, true]

     Devido a `not <expr>' fazer com que a avaliação de <expr> ocorra,
     `not <a> = <b>' é equivalente a `is(<a> # <b>)'.

          (%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
          (%o1)                   [2 x # 3 x, true]
          (%i2) is (2 * x # 3 * x);
          (%o2)                         true


 -- Operador: and
     O operador lógico de conjunção.  `and' é um operador n-ário infixo;
     seus operandos são expressões Booleanas, e seu resultado é um
     valor Booleano.

     `and' força avaliação (como `is') de um ou mais operandos, e pode
     forçar a avaliação de todos os operandos.

     Operandos são avaliados na ordem em que aparecerem.  `and' avalia
     somente quantos de seus operandos forem necessários para
     determinar o resultado.  Se qualquer operando for `false', o
     resultado é `false' e os operandos restantes não são avaliados.

     O sinalizador global `prederror' governa o comportamento de `and'
     quando um operando avaliado não pode ser determinado como sendo
     `true' ou `false'.  `and' imprime uma mensagem de erro quando
     `prederror' for `true'.  De outra forma, `and' retorna `unknown'
     (desconhecido).

     `and' não é comutativo: `a and b' pode não ser igual a `b and a'
     devido ao tratamento de operandos indeterminados.


 -- Operador: or
     O operador lógico de disjunção.  `or' é um operador n-ário infixo;
     seus operandos são expressões Booleanas, e seu resultado é um
     valor Booleano.

     `or' força avaliação (como `is') de um ou mais operandos, e pode
     forçar a avaliação de todos os operandos.

     Operandos são avaliados na ordem em que aparecem.  `or' avalia
     somente quantos de seus operandos forem necessários para
     determinar o resultado.  Se qualquer operando for `true', o
     resultado é `true' e os operandos restantes não são avaliados.

     O sinalizador global `prederror' governa o comportamento de `or'
     quando um operando avaliado não puder ser determinado como sendo
     `true' ou `false'.  `or' imprime uma mensagem de erro quando
     `prederror' for `true'.  De outra forma, `or' retorna `unknown'.

     `or' não é comutativo: `a or b' pode não ser igual a `b or a'
     devido ao tratamento de operando indeterminados.


 -- Operador: not
     O operador lógico de negação.  `not' é operador prefixado; Seu
     operando é uma expressão Booleana, e seu resultado é um valor
     Booleano.

     `not' força a avaliação (como `is') de seu operando.

     O sinalizador global `prederror' governa o comportamento de `not'
     quando seu operando não pode ser determinado em termos de `true'
     ou `false'.  `not' imprime uma mensagem de erro quando `prederror'
     for `true'.  De outra forma, `not' retorna `unknown'.


 -- Função: abs (<expr>)
     Retorna o valor absoluto de <expr>.  Se <expr> for um número
     complexo, retorna o módulo complexo de <expr>.


 -- Palavra chave: additive
     Se `declare(f,additive)' tiver sido executado, então:

     (1) Se `f' for uma função de uma única variável, sempre que o
     simplificador encontrar `f' aplicada a uma adição, `f' será
     distribuído sobre aquela adição.  I.e. `f(y+x)' irá simplificar
     para `f(y)+f(x)'.

     (2) Se `f' for uma função de 2 ou mais argumentos, a adição é
     definida como adição no primeiro argumento para `f', como no caso
     de `sum' ou `integrate', i.e. `f(h(x)+g(x),x)' irá simplificar
     para `f(h(x),x)+f(g(x),x)'.  Essa simplificação não ocorre quando
     `f' é aplicada para expressões da forma
     `sum(x[i],i,lower-limit,upper-limit)'.


 -- Palavra chave: allbut
     trabalha com os comandos `part' (i.e. `part', `inpart',
     `substpart', `substinpart', `dpart', e `lpart').  Por exemplo,

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

     enquanto

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, allbut (2, 5));
          (%o2)                       e + c + b

     `allbut' é também reconhecido por `kill'.

          (%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
          (%o1)                 [11, 22, 33, 44, 55]
          (%i2) kill (allbut (cc, dd));
          (%o0)                         done
          (%i1) [aa, bb, cc, dd];
          (%o1)                   [aa, bb, 33, 44]

     `kill(allbut(<a_1>, <a_2>, ...))' tem o mesmo efeito que
     `kill(all)' excepto que não elimina os símbolos <a_1>, <a_2>, ... .


 -- Declaração: antisymmetric
     Se `declare(h,antisymmetric)' é concluída, diz ao simplicador que
     `h' é uma função antisimétrica.  E.g. `h(x,z,y)' simplificará para
     `- h(x, y, z)'.  Isto é, dará (-1)^n vezes o resultado dado por
     `symmetric' ou `commutative', quando n for o número de
     interescolhas de dois argumentos necessários para converter isso
     naquela forma.


 -- Função: cabs (<expr>)
     Retorna o valor absoluto complexo (o módulo complexo) de <expr>.


 -- Função: ceiling (<x>)
     Quando <x> for um número real, retorna o último inteiro que é
     maior que ou igual a <x>.

     Se <x> for uma expressão constante (`10 * %pi', por exemplo),
     `ceiling' avalia <x> usando grandes números em ponto flutuante, e
     aplica `ceiling' para o grande número em ponto flutuante
     resultante. Porque `ceiling' usa avaliação de ponto flutuante, é
     possível, embora improvável, que `ceiling' possa retornar uma
     valor errôneo para entradas constantes. Para prevenir erros, a
     avaliação de ponto flutuante é concluída usando três valores para
     `fpprec'.

     Para entradas não constantes, `ceiling' tenta retornar um valor
     simplificado.  Aqui está um exemplo de simplificações que `ceiling'
     conhece:

          (%i1) ceiling (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) ceiling (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
          (%o4)                [n, abs(n), max(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) ceiling (x);
          (%o6)                           1
          (%i7) tex (ceiling (a));
          $$\left \lceil a \right \rceil$$
          (%o7)                         false

     A função `ceiling' não mapeia automaticamente sobre listas ou
     matrizes.  Finalmente, para todas as entradas que forem
     manifestamente complexas, `ceiling' retorna uma forma substantiva.

     Se o intervalo de uma função é um subconjunto dos inteiros, o
     intervalo pode ser declarado `integervalued'. Ambas as funções
     `ceiling' e `floor' podem usar essa informação; por exemplo:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1


 -- Função: charfun (<p>)
     Retorna 0 quando o predicado <p> avaliar para `false'; retorna 1
     quando o predicado avaliar para `true'.  Quando o predicado
     avaliar para alguma coisa que não `true' ou `false' (`unknown'),
     retorna uma forma substantiva.

     Exemplos:

          (%i1) charfun (x < 1);
          (%o1)                    charfun(x < 1)
          (%i2) subst (x = -1, %);
          (%o2)                           1
          (%i3) e : charfun ('"and" (-1 < x, x < 1))$
          (%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
          (%o4)                       [0, 1, 0]


 -- Declaração: commutative
     Se `declare(h,commutative)' é concluída, diz ao simplicador que
     `h' é uma função comutativa.  E.g. `h(x,z,y)' irá simplificar para
     `h(x, y, z)'.  Isto é o mesmo que `symmetric'.


 -- Função: compare (<x>, <y>)
     Retorna um operador de comparação <op> (`<', `<=', `>', `>=', `=',
     ou `#') tal que `is (<x> <op> <y>)' avalia para `true'; quando ou
     <x> ou <y> dependendo de `%i' e `<x> # <y>', retorna
     `notcomparable'; Quando não existir tal operador ou Maxima não
     estiver apto a determinar o operador, retorna `unknown'.

     Exemplos:

          (%i1) compare (1, 2);
          (%o1)                           <
          (%i2) compare (1, x);
          (%o2)                        unknown
          (%i3) compare (%i, %i);
          (%o3)                           =
          (%i4) compare (%i, %i + 1);
          (%o4)                     notcomparable
          (%i5) compare (1/x, 0);
          (%o5)                           #
          (%i6) compare (x, abs(x));
          (%o6)                          <=

     A função `compare' não tenta de terminar se o domínio real de seus
     argumentos é não vazio; dessa forma

          (%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
          (%o1)                           <

     O domínio real de `acos (x^2 + 1)' é vazio.


 -- Função: entier (<x>)
     Retorna o último inteiro menor que ou igual a <x> onde <x> é
     numérico.  `fix' (como em `fixnum') é um sinônimo disso, então
     `fix(<x>)' é precisamente o mesmo.


 -- Função: equal (<a>, <b>)
     Representa a equivalência, isto é, valor igual.

     Por si mesma, `equal' não avalia ou simplifica.  A função `is'
     tenta avaliar `equal' para um valor Booleano.  `is(equal(<a>,
     <b>))' retorna `true' (ou `false') se e somente se <a> e <b> forem
     iguais (ou não iguais) para todos os possíveis valores de suas
     variáveis, como determinado através da avaliação de `ratsimp(<a> -
     <b>)'; se `ratsimp' retornar 0, as duas expressões são
     consideradas equivalentes.  Duas expressões podem ser equivalentes
     mesmo se mesmo se elas não forem sintaticamente iguais (i.e.,
     identicas).

     Quando `is' falhar em reduzir `equal' a `true' ou `false', o
     resultado é governado através do sinalizador global `prederror'.
     Quando `prederror' for `true', `is' reclama com uma mensagem de
     erro.  De outra forma, `is' retorna `unknown'.

     Complementando `is', alguns outros operadores avaliam `equal' e
     `notequal' para `true' ou `false', a saber `if', `and', `or', e
     `not'.

     A negação de `equal' é `notequal'.  Note que devido às regras de
     avaliação de expressões predicadas (em particular pelo facto de
     `not <expr>' causar a avaliação de <expr>), `not equal(<a>, <b>)'
     é equivalente a `is(notequal(<a>, <b>))' em lugar de ser
     equivalente a `notequal(<a>, <b>)'.

     Exemplos:

     Por si mesmo, `equal' não avalia ou simplifica.

          (%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                                  2
          (%o1)            equal(x  - 1, (x - 1) (x + 1))
          (%i2) equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) equal (x, y);
          (%o3)                      equal(x, y)

     A função `is' tenta avaliar `equal' para um valor Booleano.
     `is(equal(<a>, <b>))' retorna `true' quando `ratsimp(<a> - <b>)'
     retornar 0.  Duas expressões podem ser equivalentes mesmo se não
     forem sintaticamente iguais (i.e., identicas).

          (%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
          (%o1)                           0
          (%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
          (%o2)                         true
          (%i3) is (x^2 - 1 = (x + 1) * (x - 1));
          (%o3)                         false
          (%i4) ratsimp (x - (x + 1));
          (%o4)                          - 1
          (%i5) is (equal (x, x + 1));
          (%o5)                         false
          (%i6) is (x = x + 1);
          (%o6)                         false
          (%i7) ratsimp (x - y);
          (%o7)                         x - y
          (%i8) is (equal (x, y));
          Maxima was unable to evaluate the predicate:
          equal(x, y)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i9) is (x = y);
          (%o9)                         false

     Quando `is' falha em reduzir `equal' a `true' ou `false', o
     resultado é governado através do sinalizador global `prederror'.

          (%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                              2             2
          (%o1)             [x  + 2 x + 1, x  - 2 x - 1]
          (%i2) ratsimp (aa - bb);
          (%o2)                        4 x + 2
          (%i3) prederror : true;
           (%o3)                         true
          (%i4) is (equal (aa, bb));
          Maxima was unable to evaluate the predicate:
                 2             2
          equal(x  + 2 x + 1, x  - 2 x - 1)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) prederror : false;
          (%o5)                         false
          (%i6) is (equal (aa, bb));
          (%o6)                        unknown

     Alguns operadores avaliam `equal' e `notequal' para `true' ou
     `false'.

          (%i1) if equal (a, b) then FOO else BAR;
          Maxima was unable to evaluate the predicate:
          equal(a, b)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i2) eq_1 : equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                                   2                   2
          (%o3)             equal(y  + 2 y + 1, (y + 1) )
          (%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
          (%o4)                  [false, true, true]

     Devido a `not <expr>' fazer com que ocorra a avaliação de <expr>,
     `not equal(<a>, <b>)' é equivalente a `is(notequal(<a>, <b>))'.

          (%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
          (%o1)            [notequal(2 z, 2 z - 1), true]
          (%i2) is (notequal (2*z, 2*z - 1));
          (%o2)                         true


 -- Função: floor (<x>)
     Quando <x> for um número real, retorna o maior inteiro que é menor
     que ou igual a <x>.

     Se <x> for uma expressão constante (`10 * %pi', for exemplo),
     `floor' avalia <x> usando grandes números em ponto flutuante, e
     aplica `floor' ao grande número em ponto flutuante resultante.
     Porque `floor' usa avaliação em ponto flutuante, é possível,
     embora improvável, que `floor' não possa retornar um valor errôneo
     para entradas constantes.  Para prevenir erros, a avaliação de
     ponto flutuante é concluída usando três valores para `fpprec'.

     Para entradas não constantes, `floor' tenta retornar um valor
     simplificado.  Aqui está exemplos de simplificações que `floor'
     conhece:

          (%i1) floor (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) floor (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
          (%o4)                [n, abs(n), min(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) floor (x);
          (%o6)                           0
          (%i7) tex (floor (a));
          $$\left \lfloor a \right \rfloor$$
          (%o7)                         false

     A função `floor' não mapeia automaticamente sobre listas ou
     matrizes.  Finalmente, para todas as entradas que forem
     manifestamente complexas, `floor' retorna uma forma substantiva.

     Se o intervalo de uma função for um subconjunto dos inteiros, o
     intervalo pode ser declarado `integervalued'. Ambas as funções
     `ceiling' e `floor' podem usar essa informação; por exemplo:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1


 -- Função: notequal (<a>, <b>)
     Represents the negation of `equal(<a>, <b>)'.

     Note que pelo facto de as regras de avaliação de expressões
     predicadas (em particular pelo facto de `not <expr>' causar a
     avaliação de <expr>), `not equal(<a>, <b>)' é equivalente a
     `is(notequal(<a>, <b>))' em lugar de ser equivalente a
     `notequal(<a>, <b>)'.

     Exemplos:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          Maxima was unable to evaluate the predicate:
          equal(a, b)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) maybe (not equal (a, b));
          (%o6)                        unknown
          (%i7) assume (a > b);
          (%o7)                        [a > b]
          (%i8) equal (a, b);
          (%o8)                      equal(a, b)
          (%i9) maybe (equal (a, b));
          (%o9)                         false
          (%i10) notequal (a, b);
          (%o10)                   notequal(a, b)
          (%i11) not equal (a, b);
          (%o11)                        true
          (%i12) maybe (notequal (a, b));
          (%o12)                        true
          (%i13) maybe (not equal (a, b));
          (%o13)                        true


 -- Operador: eval
     Como um argumento em uma chamada a `ev (<expr>)', `eval' causa uma
     avaliação extra de <expr>.  Veja `ev'.


 -- Função: evenp (<expr>)
     Retorna `true' se <expr> for um inteiro sempre.  `false' é
     retornado em todos os outros casos.


 -- Função: fix (<x>)
     Um sinônimo para `entier (<x>)'.


 -- Função: fullmap (<f>, <expr_1>, ...)
     Similar a `map', mas `fullmap' mantém mapeadas para baixo todas as
     subexpressões até que os operadores principais não mais sejam os
     mesmos.

     `fullmap' é usada pelo simplificador do Maxima para certas
     manipulações de matrizes; dessa forma, Maxima algumas vezes gera
     uma mensagem de erro concernente a `fullmap' mesmo apesar de
     `fullmap' não ter sido explicitamente chamada pelo utilizador.

     Exemplos:

          (%i1) a + b * c;
          (%o1)                        b c + a
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)


 -- Função: fullmapl (<f>, <list_1>, ...)
     Similar a `fullmap', mas `fullmapl' somente mapeia sobre listas e
     matrizes.

     Exemplo:

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]


 -- Função: is (<expr>)
     Tenta determinar se a <expr> predicada (expressões que avaliam
     para `true' ou `false') é dedutível de factos localizados na base
     de dados de `assume'.

     Se a dedutibilidade do predicado for `true' ou `false', `is'
     retorna `true' ou `false', respectivamente.  De outra forma, o
     valor de retorno é governado através do sinalizador global
     `prederror'.  Quando `prederror' for `true', `is' reclama com uma
     mensagem de erro.  De outra forma, `is' retorna `unknown'.

     `ev(<expr>, pred)' (que pode ser escrita da forma  `<expr>, pred'
     na linha de comando interativa) é equivalente a `is(<expr>)'.

     Veja também `assume', `facts', e `maybe'.

     Exemplos:

     `is' causa avaliação de predicados.

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) é (%pi > %e);
          (%o2)                         true

     `is' tenta derivar predicados da base de dados do `assume'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) é (a < b);
          (%o3)                         false
          (%i4) é (a > c);
          (%o4)                         true
          (%i5) é (equal (a, c));
          (%o5)                         false

     Se `is' não puder nem comprovar nem refutar uma forma predicada a
     partir da base de dados de `assume', o sinalizador global
     `prederror' governa o comportamento de `is'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) é (a > 0);
          Maxima was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) é (a > 0);
          (%o5)                        unknown


 -- Função: maybe (<expr>)
     Tenta determinar se a <expr> predicada é dedutível dos factos na
     base de dados de `assume'.

     Se a dedutibilidade do predicado for `true' ou `false', `maybe'
     retorna `true' ou `false', respectivamente.  De outra forma,
     `maybe' retorna `unknown'.

     `maybe' é funcinalmente equivalente a `is' com `prederror: false',
     mas o resultado é computado sem actualmente atribuir um valor a
     `prederror'.

     Veja também `assume', `facts', e `is'.

     Exemplos:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true


 -- Função: isqrt (<x>)
     Retorna o "inteiro raíz quadrada" do valor absoluto de <x>, que é
     um inteiro.


 -- Função: lmax (<L>)
     Quando <L> for uma lista ou um conjunto, retorna `apply ('max,
     args (<L>))'.  Quando <L> não for uma lista ou também não for um
     conjunto, sinaliza um erro.


 -- Função: lmin (<L>)
     Quando <L> for uma lista ou um conjunto, retorna `apply ('min,
     args (<L>))'. Quando <L> não for uma lista ou ou também não for um
     conjunto, sinaliza um erro.


 -- Função: max (<x_1>, ..., <x_n>)
     Retorna um valor simplificado para o máximo entre as expressões
     <x_1> a <x_n>.  Quando `get (trylevel, maxmin)', for dois ou mais,
     `max' usa a simplificação `max (e, -e) --> |e|'.  Quando `get
     (trylevel, maxmin)' for 3 ou mais, <max> tenta eliminar expressões
     que estiverem entre dois outros argumentos; por exemplo, `max (x,
     2*x, 3*x) --> max (x, 3*x)'. Para escolher o valor de `trylevel'
     para 2, use `put (trylevel, 2, maxmin)'.


 -- Função: min (<x_1>, ..., <x_n>)
     Retorna um valor simplificado para o mínimo entre as expressões
     `x_1' até `x_n'.  Quando `get (trylevel, maxmin)', for 2 ou mais,
     `min' usa a simplificação `min (e, -e) --> -|e|'.  Quando `get
     (trylevel, maxmin)' for 3 ou mais, `min' tenta eliminar expressões
     que estiverem entre dois outros argumentos; por exemplo, `min (x,
     2*x, 3*x) --> min (x, 3*x)'. Para escolher o valor de `trylevel'
     para 2, use `put (trylevel, 2, maxmin)'.


 -- Função: polymod (<p>)
 -- Função: polymod (<p>, <m>)
     Converte o polinómio <p> para uma representação modular com
     relação ao módulo corrente que é o valor da variável `modulus'.

     `polymod (<p>, <m>)' especifica um módulo <m> para ser usado em
     lugar do valor corrente de `modulus'.

     Veja `modulus'.


 -- Função: mod (<x>, <y>)
     Se <x> e <y> forem números reais e <y> for não nulo, retorna `<x>
     - <y> * floor(<x> / <y>)'.  Adicionalmente para todo real <x>, nós
     temos `mod (<x>, 0) = <x>'. Para uma discursão da definição `mod
     (<x>, 0) = <x>', veja a Seção 3.4, de "Concrete Mathematics," por
     Graham, Knuth, e Patashnik. A função `mod (<x>, 1)' é uma
     função dente de serra com período 1 e com `mod (1, 1) = 0' e `mod
     (0, 1) = 0'.

     Para encontrar o argumento (um número no intervalo `(-%pi, %pi]')
     de um número complexo, use a função `<x> |-> %pi - mod (%pi - <x>,
     2*%pi)', onde <x> é um argumento.

     Quando <x> e <y> forem expressões constantes (`10 * %pi', por
     exemplo), `mod' usa o mesmo esquema de avaliação em ponto
     flutuante que `floor' e `ceiling' usam.  Novamente, é possível,
     embora improvável, que `mod' possa retornar um valor errôneo
     nesses casos.

     Para argumentos não numéricos <x> ou <y>, `mod 'conhece muitas
     regras de simplificação:

          (%i1) mod (x, 0);
          (%o1)                           x
          (%i2) mod (a*x, a*y);
          (%o2)                      a mod(x, y)
          (%i3) mod (0, x);
          (%o3)                           0


 -- Função: oddp (<expr>)
     é `true' se <expr> for um inteiro ímpar.  `false' é retornado em
     todos os outros casos.


 -- Operador: pred
     Como um argumento em uma chamada a `ev (<expr>)', `pred' faz com
     que predicados (expressões que avaliam para `true' ou `false')
     sejam avaliados.  Veja `ev'.


 -- Função: make_random_state (<n>)
 -- Função: make_random_state (<s>)
 -- Função: make_random_state (true)
 -- Função: make_random_state (false)
     Um objecto de estado aleatório representa o estado do gerador de
     números aleatórios (aleatórios).  O estado compreende 627 palavras
     de 32 bits.

     `make_random_state (<n>)' retorna um novo objecto de estado
     aleatório criado de um valor inteiro semente igual a <n> modulo
     2^32.  <n> pode ser negativo.

     `make_random_state (<s>)' retorna uma copia do estado aleatório
     <s>.

     `make_random_state (true)' retorna um novo objecto de estado
     aleatório, usando a hora corrente  do relógio do computador como
     semente.

     `make_random_state (false)' retorna uma cópia do estado corrente
     do gerador de números aleatórios.


 -- Função: set_random_state (<s>)
     Copia <s> para o estado do gerador de números aleatórios.

     `set_random_state' sempre retorna `done'.


 -- Função: random (<x>)
     Retorna um número pseudoaleatório. Se <x> é um inteiro, `random
     (<x>)' retorna um inteiro de 0 a `<x> - 1' inclusive. Se <x> for
     um número em ponto flutuante, `random (<x>)' retorna um número não
     negativo em ponto flutuante menor que <x>.  `random' reclama com
     um erro se <x> não for nem um inteiro nem um número em ponto
     flutuante, ou se <x> não for positivo.

     As funções `make_random_state' e `set_random_state' mantém o
     estado do gerador de números aleatórios.

     O gerador de números aleatórios do Maxima é uma implementação do
     algoritmo de Mersenne twister MT 19937.

     Exemplos:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853


 -- Função: rationalize (<expr>)
     Converte todos os números em ponto flutuante de precisão dupla e
     grandes números em ponto flutuante na expressão do Maxima <expr>
     para seus exatos equivalentes racionais. Se vnão estiver
     familiarizado com a representação binária dos números em ponto
     flutuante, pode ficar surpreendido em saber que `rationalize (0.1)'
     não é igual a 1/10.  Esse comportamento não é especial do Maxima -
     o número 1/10 tem uma representação binária repetitiva e não
     terminada.

          (%i1) rationalize (0.5);
                                          1
          (%o1)                           -
                                          2
          (%i2) rationalize (0.1);
                                         1
          (%o2)                          --
                                         10
           (%i3) fpprec : 5$
          (%i4) rationalize (0.1b0);
                                       209715
          (%o4)                        -------
                                       2097152
          (%i5) fpprec : 20$
          (%i6) rationalize (0.1b0);
                               236118324143482260685
          (%o6)                ----------------------
                               2361183241434822606848
          (%i7) rationalize (sin (0.1*x + 5.6));
                                        x    28
          (%o7)                     sin(-- + --)
                                        10   5

     Exemplo de utilização:

          (%i1) unitfrac(r) := block([uf : [], q],
              if not(ratnump(r)) then error("The input to 'unitfrac' must be a rational number"),
              while r # 0 do (
                  uf : cons(q : 1/ceiling(1/r), uf),
                  r : r - q),
              reverse(uf));
          (%o1) unitfrac(r) := block([uf : [], q],
          if not ratnump(r) then error("The input to 'unitfrac' must be a rational number"
                                               1
          ), while r # 0 do (uf : cons(q : ----------, uf), r : r - q),
                                                   1
                                           ceiling(-)
                                                   r
          reverse(uf))
          (%i2) unitfrac (9/10);
                                      1  1  1
          (%o2)                      [-, -, --]
                                      2  3  15
          (%i3) apply ("+", %);
                                         9
          (%o3)                          --
                                         10
          (%i4) unitfrac (-9/10);
                                            1
          (%o4)                       [- 1, --]
                                            10
          (%i5) apply ("+", %);
                                          9
          (%o5)                         - --
                                          10
          (%i6) unitfrac (36/37);
                                  1  1  1  1    1
          (%o6)                  [-, -, -, --, ----]
                                  2  3  8  69  6808
          (%i7) apply ("+", %);
                                         36
          (%o7)                          --
                                         37


 -- Função: sign (<expr>)
     Tenta determinar o sinal de <expr> a partir dos factos na base de
     dados corrente.  Retorna uma das seguintes respostar: `pos'
     (positivo), `neg' (negativo), `zero', `pz' (positivo ou zero),
     `nz' (negativo ou zero), `pn' (positivo ou negativo), ou `pnz'
     (positivo, negativo, ou zero, i.e. nada se sabe sobre o sinal da
     epressão).


 -- Função: signum (<x>)
     Para um <x> numérico retorna 0 se <x> for 0, de outra forma
     retorna -1 ou +1 à medida que <x> seja menor ou maior que 0,
     respectivamente.

     Se <x> não for numérico então uma forma simplificada mas
     equivalente é retornada.  Por exemplo, `signum(-x)' fornece
     `-signum(x)'.


 -- Função: sort (<L>, <P>)
 -- Função: sort (<L>)
     Organiza uma lista <L> coforme o predicado `P' de dois argumentos,
     de forma que `<P> (<L>[k], <L>[k + 1])' seja `true' para qualquer
     dois elementos sucessivos.  O predicado pode ser especificado como
     o nome de uma função ou operador binário infixo, ou como uma
     expressão `lambda'.  Se especificado como o nome de um operador, o
     nome deve ser contido entre "aspas duplas".

     A lista ordenada é retornada como novo objecto; o argumento <L>
     não é modificado.  Para construir o valor de retorno, `sort' faz
     uma cópia superficial dos elementos de <L>.  Se o predicado <P>
     não for uma ordem total sobre os elementos de <L>, então `sort'
     possivelvente pode executar para concluir sem error, mas os
     resultados são indefinidos.  `sort' reclama se o predicado avaliar
     para alguma outra coisa que não seja `true' ou `false'.

     `sort (<L>)' é equivalente a `sort (<L>, orderlessp)'.  Isto é, a
     ordem padrão de organização é ascendente, como determinado por
     `orderlessp'.  Todos os átomos do Maxima e expressões são
     comparáveis sob `orderlessp', embora exista exemplos isolados de
     expressões para as quais `orderlessp' não é transitiva; isso é uma
     falha.

     Exemplos:

          (%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x]);
                         5
          (%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
                         2
          (%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x], ordergreatp);
                                                             5
          (%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                             2
          (%i3) sort ([%pi, 3, 4, %e, %gamma]);
          (%o3)                [3, 4, %e, %gamma, %pi]
          (%i4) sort ([%pi, 3, 4, %e, %gamma], "<");
          (%o4)                [%gamma, %e, 3, %pi, 4]
          (%i5) my_list : [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]];
          (%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
          (%i6) sort (my_list);
          (%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
          (%i7) sort (my_list, lambda ([a, b], orderlessp (reverse (a), reverse (b))));
          (%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]


 -- Função: sqrt (<x>)
     A raíz quadrada de <x>. É representada internamente por
     `<x>^(1/2)'.  Veja também `rootscontract'.

     `radexpand' se `true' fará com que n-ésimas raízes de factores de
     um produto que forem potências de n sejam colocados fora do
     radical, e.g.  `sqrt(16*x^2)' retonará `4*x' somente se
     `radexpand' for `true'.


 -- Variável de opção: sqrtdispflag
     Valor por omissão: `true'

     Quando `sqrtdispflag' for `false', faz com que `sqrt' seja
     mostrado como expoente 1/2.


 -- Função: sublis (<lista>, <expr>)
     Faz múltiplas substituições paralelas dentro de uma expressão.

     A variável `sublis_apply_lambda' controla a simplificação após
     `sublis'.

     Exemplo:



 -- Função: sublist (<lista>, <p>)
     Retorna a lista de elementos da <lista> da qual o predicado `p'
     retornar `true'.

     Exemplo:

          (%i1) L: [1, 2, 3, 4, 5, 6];
          (%o1)                  [1, 2, 3, 4, 5, 6]
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]


 -- Variável de opção: sublis_apply_lambda
     Valor por omissão: `true' - controla se os substitutos de `lambda'
     são aplicados na simplificação após as `sublis' serem usadas ou se
     tiver que fazer um `ev' para obter coisas para aplicar.  `true'
     significa faça a aplicação.


 -- Função: subst (<a>, <b>, <c>)
     Substitue <a> por <b> em <c>.  <b> deve ser um átomo ou uma
     subexpressão completa de <c>.  Por exemplo, `x+y+z' é uma
     subexpressão completa de `2*(x+y+z)/w' enquanto `x+y' não é.
     Quando <b> não tem essas características, pode-se algumas vezes
     usar `substpart' ou `ratsubst' (veja abaixo).  Alternativamente,
     se <b> for da forma de `e/f' então se poderá usar `subst (a*f, e,
     c)' enquanto se <b> for da forma `e^(1/f)' então se poderá usar
     `subst (a^f, e, c)'.  O comando `subst' também discerne o `x^y' de
     `x^-y' de modo que `subst (a, sqrt(x), 1/sqrt(x))' retorna `1/a'.
     <a> e <b> podem também ser operadores de uma expressão contida
     entre aspas duplas `"' ou eles podem ser nomes de função.  Se se
     desejar substituir por uma variável independente em formas
     derivadas então a função `at' (veja abaixo) poderá ser usada.

     `subst' é um álias para `substitute'.

     `subst (<eq_1>, <expr>)' ou `subst ([<eq_1>, ..., <eq_k>], <expr>)'
     são outras formas permitidas.  As <eq_i> são equações indicando
     substituições a serem feitas.  Para cada equação, o lado direito
     será substituído pelo lado esquerdo na expressão <expr>.

     `exptsubst' se `true' permite que substituições como `y' por
     `%e^x' em `%e^(a*x)' ocorram.

     Quando `opsubst' for `false', `subst' tentará substituir dentro do
     operador de uma expressão.  E.g. `(opsubst: false, subst (x^2, r,
     r+r[0]))' trabalhará.

     Exemplos:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     Para exemplos adicionais, faça `example (subst)'.


 -- Função: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Similar a `substpart', mas `substinpart' trabalha sobre a
     representação interna de <expr>.

     Exemplos:

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       d
          (%o1)                   x . (--- (f(x)))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x + 1), 0);
          (%o3)                       f1(x + 1)

     Se o último argumento para a função `part' for uma lista de
     índices então muitas subexpressões são escolhidas, cada uma
     correspondendo a um índice da lista.  Dessa forma

          (%i1) part (x + y + z, [1, 3]);
          (%o1)                         z + x

     `piece' recebe o valor da última expressão seleccionada quando
     usando as funções `part'.  `piece' é escolhida durante a
     execução da função e dessa forma pode ser referenciada para a
     própria função como mostrado abaixo.  Se `partswitch' for
     escolhida para `true' então `end' é retornado quando uma parte
     seleccionada de uma expressão não existir, de outra forma uma
     mensagem de erro é fornecida.

          (%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
                        3         2       2            3
          (%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
          (%i2) part (expr, 2, [1, 3]);
                                            2
          (%o2)                         54 y
          (%i3) sqrt (piece/54);
          (%o3)                        abs(y)
          (%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                                         3
          (%o4)               (3 y + 2 x)  + y + x + 1
          (%i5) expr: 1/x + y/x - 1/z;
                                       1   y   1
          (%o5)                      - - + - + -
                                       z   x   x
          (%i6) substpart (xthru (piece), expr, [2, 3]);
                                      y + 1   1
          (%o6)                       ----- - -
                                        x     z

     Também, escolhendo a opção `inflag' para `true' e chamando `part'
     ou `substpart' é o mesmo que chamando `inpart' ou `substinpart'.


 -- Função: substpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Substitue <x> para a subexpressão seleccionada pelo resto dos
     argumentos como em `part'.  Isso retorna o novo valor de <expr>.
     <x> pode ser algum operador a ser substituído por um operador de
     <expr>.  Em alguns casos <x> precisa ser contido em aspas duplas
     `"' (e.g.  `substpart ("+", a*b, 0)' retorna `b + a').

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f (b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

     Também, escolhendo a opção `inflag' para `true' e chamando `part'
     ou `substpart' é o mesmo que chamando `inpart' ou `substinpart'.


 -- Função: subvarp (<expr>)
     Retorna `true' se <expr> for uma variável subscrita (i.e. que
     possui índice ou subscrito em sua grafia), por exemplo `a[i]'.


 -- Função: symbolp (<expr>)
     Retorna `true' se <expr> for um símbolo, de outra forma retorna
     `false'.  com efeito, `symbolp(x)' é equivalente ao predicado
     `atom(x) and not numberp(x)'.

     Veja também _Identificadores_


 -- Função: unorder ()
     Disabilita a ação de alias criada pelo último uso dos comandos de
     ordenação `ordergreat' e `orderless'. `ordergreat' e `orderless'
     não podem ser usados mais que uma vez cada sem chamar `unorder'.
     Veja também `ordergreat' e `orderless'.

     Exemplos:

          (%i1) unorder();
          (%o1)                          []
          (%i2) b*x + a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat (a);
          (%o3)                         done
          (%i4) b*x + a^2;
           %th(1) - %th(3);
                                       2
          (%o4)                       a  + b x
          (%i5) unorder();
                                        2    2
          (%o5)                        a  - a


 -- Função: vectorpotential (<givencurl>)
     Retorna o potencial do vector de um dado vector de torção, no
     sistema de coordenadas corrente.  `potentialzeroloc' tem um papel
     similar ao de `potential', mas a ordem dos lados esquerdos das
     equações deve ser uma permutação cíclica das variáveis de
     coordenadas.


 -- Função: xthru (<expr>)
     Combina todos os termos de <expr> (o qual pode ser uma adição)
     sobre um denominador comum sem produtos e somas exponenciadas como
     `ratsimp' faz.  `xthru' cancela factores comuns no numerador e
     denominador de expressões racionais mas somente se os factores são
     explícitos.

     Algumas vezes é melhor usar `xthru' antes de `ratsimp' em uma
     expressão com o objectivo de fazer com que factores explicitos do
     máximo divisor comum entre o numerador e o denominador seja
     cancelado simplificando dessa forma a expressão a ser aplicado o
     `ratsimp'.

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)
          (%i2) xthru (%);
                                           20
                                    (x + 2)   - y
          (%o2)                     -------------
                                             20
                                      (y + x)


 -- Função: zeroequiv (<expr>, <v>)
     Testa se a expressão <expr> na variável <v> é equivalente a zero,
     retornando `true', `false', ou `dontknow' (não sei).

     `zeroequiv' Tem essas restrições:
       1. Não use funções que o Maxima não sabe como diferenciar e
          avaliar.

       2. Se a expressão tem postes sobre o eixo real, podem existir
          erros no resultado (mas isso é improvável ocorrer).

       3. Se a expressão contem funções que não são soluções para
          equações diferenciais de primeira ordem (e.g.  funções de
          Bessel) pode ocorrer resultados incorrectos.

       4. O algoritmo usa avaliação em pontos aleatóriamente escolhidos
          para subexpressões seleccionadas cuidadosamente.  Isso é
          sempre negócio um tanto quanto perigoso, embora o algoritmo
          tente minimizar o potencial de erro.

     Por exemplo  `zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)' retorna
     `true' e `zeroequiv (%e^x + x, x)' retorna `false'.  Por outro
     lado `zeroequiv (log(a*b) - log(a) - log(b), a)' retorna
     `dontknow' devido à presença de um parâmetro extra `b'.



File: maxima.info,  Node: Expressões,  Next: Simplificação,  Prev: Operadores,  Up: Top

6 Expressões
************

* Menu:

* Introdução a Expressões::
* Complexo::
* Substantivos e Verbos::
* Identificadores::
* Sequências de caracteres::
* Desigualdade::
* Sintaxe::
* Definições para Expressões::


File: maxima.info,  Node: Introdução a Expressões,  Next: Complexo,  Prev: Expressões,  Up: Expressões

6.1 Introdução a Expressões
===========================

Existe um conjunto de palavras reservadas que não pode ser usado como
nome de variável.   Seu uso pode causar um possível erro crítico de
sintaxe.

     integrate            next           from                 diff
     in                   at             limit                sum
     for                  and            elseif               then
     else                 do             or                   if
     unless               product        while                thru
     step

   Muitas coisas em Maxima são expressões.   Uma sequência de expressões
pode ser feita dentro de uma expressão maior através da separação
dessas através de vírgulas e colocando parêntesis em torno dela.   Isso
é similar ao C expressão com vírgula.

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

   Mesmo ciclos em Maxima são expressões, embora o valor de retorno
desses ciclos não seja muito útil (eles retornam sempre `done').

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

   enquanto que o que realmente queira seja provavelmente incluir um
terceiro termo na expressão com vírgula que fornece de volta o valor
actualizado.

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800


File: maxima.info,  Node: Complexo,  Next: Substantivos e Verbos,  Prev: Introdução a Expressões,  Up: Expressões

6.2 Complexo
============

Uma expressão complexa é especificada no Maxima através da adição da
parte real da expressão a `%i' vezes a parte imaginária.  Dessa forma as
raízes da equação `x^2 - 4*x + 13 = 0' são `2 + 3*%i' e `2 - 3*%i'.
Note que produtos de simplificação de expressões complexas podem ser
efetuadas através da expansão do produto.  Simplificação de quocientes,
raízes, e outras funções de expressões complexas podem usualmente serem
realizadas através do uso das funções `realpart', `imagpart',
`rectform', `polarform', `abs', `carg'.


File: maxima.info,  Node: Substantivos e Verbos,  Next: Identificadores,  Prev: Complexo,  Up: Expressões

6.3 Substantivos e Verbos
=========================

Maxima distingue entre operadores que são "substantivos" e operadores
que são "verbos".  Um verbo é um operador que pode ser executado.  Um
substantivo é um operador que aparece como um símbolo em uma expressão,
sem ser executado.  Por padrão, nomes de função são verbos.  Um verbo
pode ser mudado em um substantivo através da adição de um apóstrofo no
início do nome da função ou aplicando a função `nounify'.  Um
substantivo pode ser mudado em um verbo através da aplicação da
função `verbify'.  O sinalizador de avaliação `nouns' faz com que `ev'
avalie substantivos em uma expressão.

   A forma verbal é distinguida através de um sinal de dólar `$' no
início do símbolo Lisp correspondente.  De forma oposta, a forma
substantiva é distinguida através de um sinal de `%' no início do
símbolo Lisp correspondente.  Alguns substantivos possuem propriedades
especiais de exibição, tais como `'integrate' e `'derivative'
(retornado por `diff'), mas muitos não.  Por padrão, as formas
substantiva e verbal de uma função são idênticas quando mostradas.  O
sinalizador global `noundisp' faz com que Maxima mostre substantivos
com um apóstrofo no início `''.

   Veja também `noun', `nouns', `nounify', e `verbify'.

   Exemplos:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Identificadores,  Next: Sequências de caracteres,  Prev: Substantivos e Verbos,  Up: Expressões

6.4 Identificadores
===================

Identificadores do Maxima podem compreender caracteres alfabéticos,
mais os numerais de 0 a 9, mais qualquer caractere especial precedido
por um caractere contra-barra `\'.

   Um numeral pode ser o primeiro caractere de um identificador se esse
numeral for precedido por uma contra-barra.  Numerais que forem o
segundo ou o último caractere não precisam ser precedidos por uma
contra barra.

   Caracteres podem ser declarados para serem alfabéticos por meio da
função `declare'.  Se então declarados alfabéticos, eles não precisam
serem precedidos de uma contrabarra em um identificador.  Os caracteres
alfabéticos vão inicialmente de `A' a `Z', de `a' a `z', `%', e `_'.

   Maxima é sensível à caixa . Os identificadores `algumacoisa',
`ALGUMACOISA', e `Algumacoisa' são distintos.  Veja _Lisp e Maxima_
para mais sobre esse ponto.

   Um identificador Maxima é um símbolo Lisp que começa com um sinal de
dólar `$'.  Qualquer outro símbolo Lisp é precedido por um ponto de
interrogação `?' quando aparecer no Maxima.  Veja _Lisp e Maxima_ para
maiores detalhes sobre esse ponto.

   Exemplos:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Sequências de caracteres,  Next: Desigualdade,  Prev: Identificadores,  Up: Expressões

6.5 Sequências de caracteres
============================

Strings (sequências de caracteres) são contidas entre aspas duplas `"'
em entradas de dados usados pelo Maxima, e mostradas com ou sem as
aspas duplas, dependendo do valor escolhido para a variável global
`stringdisp'.

   Sequências de caracteres podem conter quaisquer caracteres,
incluindo tabulações (tab), nova linha (ou fim de linha), e caracteres
de retorno da cabeça de impressão (carriage return).  A sequência `\"'
é reconhecida com uma aspa dupla literal, e `\\' como uma contrabarra
literal.  Quando a contrabarra aparecer no final de uma linha, a
contrabarra e a terminação de linha (ou nova linha ou retorno de carro
e nova linha) são ignorados, de forma que a sequência de caracteres
continue na próxima linha.  Nenhuma outra combinação especial de
contrabarra com outro caractere é reconhecida; quando a contrabarra
aparecer antes de qualquer outro caractere que não seja `"', `\', ou um
fim de linha, a contrabarra é ignorada.  Não exite caminho para
representar um caractere especial (tal como uma tabulação, nova linha,
ou retorno da cabeça de impressão) excepto através de encaixar o
caractere literal na sequência de caracteres.

   Não existe tipo de caractere no Maxima; um caractere simples é
representado como uma sequência de caracteres de um único caractere.

   Sequências de caracteres no Maxima são implementadas como símbolos
do Lisp, não como sequencias de caracteres do not Lisp; o que pode
mudar em futuras versões do Maxima.  Maxima pode mostrar sequências de
caracteres do Lisp e caracteres do Lisp, embora algumas outras
operações (por exemplo, testes de igualdade) possam falhar.

   O pacote adicional `stringproc' contém muitas funções que trabalham
com sequências de caracteres.

   Exemplos:

     (%i1) s_1 : "Isso é uma sequência de caracteres  do Maxima.";
     (%o1)               Isso é uma sequência de caracteres  do Maxima.
     (%i2) s_2 : "Caracteres \"aspas duplas\" e contrabarras \\ encaixados em uma sequência de caracteres.";
     (%o2) Caracteres "aspas duplas" e contrabarra \ encaixados em uma sequência de caracteres.
     (%i3) s_3 : "Caractere de fim de linha encaixado
     nessa sequência de caracteres.";
     (%o3) Caractere de fim de linha encaixado
     nessa sequência de caracteres.
     (%i4) s_4 : "Ignore o \
     caractere de \
     fim de linha nessa \
     sequência de caracteres.";
     (%o4) Ignore o caractere de fim de linha nessa sequência de caracteres.
     (%i5) stringdisp : false;
     (%o5)                         false
     (%i6) s_1;
     (%o6)               Isso é uma sequência de caracteres  do Maxima.
     (%i7) stringdisp : true;
     (%o7)                         true
     (%i8) s_1;
     (%o8)              "Isso é uma sequência de caracteres  do Maxima."


File: maxima.info,  Node: Desigualdade,  Next: Sintaxe,  Prev: Sequências de caracteres,  Up: Expressões

6.6 Desigualdade
================

Maxima tem os operadores de desigualdade `<', `<=', `>=', `>', `#', e
`notequal'.  Veja `if' para uma descrição de expressões condicionais.


File: maxima.info,  Node: Sintaxe,  Next: Definições para Expressões,  Prev: Desigualdade,  Up: Expressões

6.7 Sintaxe
===========

É possível definir novos operadores com precedência especificada,
remover a definição de operadores existentes, ou redefinir a
precedência de operadores existentes.  Um operador pode ser unário
prefixado ou unário pósfixado, binario infixado, n-ário infixado,
matchfix, ou nofix.  "Matchfix" significa um par de símbolos que
abraçam seu argumento ou seus argumentos, e "nofix" significa um
operador que não precisa de argumentos.  Como exemplos dos diferentes
tipos de operadores, existe o seguinte.

unário prefixado
     negação `- a'

unário posfixado
     factorial `a!'

binário infixado
     exponenciação `a^b'

n-ário infixado
     adição `a + b'

matchfix
     construção de lista `[a, b]'

   (Não existe operadores internos nofix; para um exemplo de tal
operador, veja `nofix'.)

   O mecanismo para definir um novo operador é directo.  Somente é
necessário declarar uma função como um operador; a função operador pode
ou não estar definida previamente.

   Um exemplo de operadores definidos pelo utilizador é o seguinte.
Note que a chamada explícita de função `"dd" (a)' é equivalente a `dd
a', da mesma forma `"<-" (a, b)' é equivalente a `a <- b'.  Note também
que as funções `"dd"' e `"<-"' são indefinidas nesse exemplo.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

   As funções máxima que definem novos operadores estão sumarizadas
nessa tabela, equilibrando expoente associado esquerdo (padrão) e o
expoente associado direito ("eae" e "ead", respectivamente).
(Associação de expoentes determina a precedência do operador. todavia,
uma vez que os expoentes esquerdo e direito podem ser diferentes,
associação de expoentes é até certo ponto mais complicado que
precedência.)  Alguma das funções de definição de operações tomam
argumentos adicionais; veja as descrições de função para maiores
detalhes.

`prefixado'
     ead=180

`posfixado'
     eae=180

`infixado'
     eae=180, ead=180

`nário'
     eae=180, ead=180

`matchfix'
     (associação de expoentes não é aplicável)

`nofix'
     (associação de expoentes não é aplicável)

   Para comparação, aqui está alguns operadores internos e seus
expoentes associados esquerdo e direito.

     Operador   eae     ead

       :        180     20
       ::       180     20
       :=       180     20
       ::=      180     20
       !        160
       !!       160
       ^        140     139
       .        130     129
       *        120
       /        120     120
       +        100     100
       -        100     134
       =        80      80
       #        80      80
       >        80      80
       >=       80      80
       <        80      80
       <=       80      80
       not              70
       and      65
       or       60
       ,        10
       $        -1
       ;        -1

   `remove' e `kill' removem propriedades de operador de um átomo.
`remove ("<a>", op)' remove somente as propriedades de operador de <a>.
`kill ("<a>")' remove todas as propriedades de <a>, incluindo as
propriedades de operador.  Note que o nome do operador dever estar
abraçado por aspas duplas.

     (%i1) infix ("##");
     (%o1)                          ##
     (%i2) "##" (a, b) := a^b;
                                          b
     (%o2)                     a ## b := a
     (%i3) 5 ## 3;
     (%o3)                          125
     (%i4) remove ("##", op);
     (%o4)                         done
     (%i5) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i5) "##" (5, 3);
     (%o5)                          125
     (%i6) infix ("##");
     (%o6)                          ##
     (%i7) 5 ## 3;
     (%o7)                          125
     (%i8) kill ("##");
     (%o8)                         done
     (%i9) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i9) "##" (5, 3);
     (%o9)                       ##(5, 3)


File: maxima.info,  Node: Definições para Expressões,  Prev: Sintaxe,  Up: Expressões

6.8 Definições para Expressões
==============================

 -- Função: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Função: at (<expr>, <eqn>)
     Avalia a expressão <expr> com as variáveis assumindo os valores
     como especificado para elas na lista de equações `[<eqn_1>, ...,
     <eqn_n>]' ou a equação simples <eqn>.

     Se uma subexpressão depender de qualquer das variáveis para a qual
     um valor foi especificado mas não existe `atvalue' especificado e
     essa subexpressão não pode ser avaliada de outra forma, então uma
     forma substantiva de `at' é retornada que mostra em uma forma
     bidimensional.

     `at' realiza múltiplas substituições em série, não em paralelo.

     Veja também `atvalue'.  Para outras funções que realizam
     substituições, veja também `subst' e `ev'.

     Exemplos:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Função: box (<expr>)
 -- Função: box (<expr>, <a>)
     Retorna <expr> dentro de uma caixa.  O valor de retorno é uma
     expressão com `box' como o operador e <expr> como o argumento.
     Uma caixa é desenhada sobre a tela quando `display2d' for `true'.

     `box (<expr>, <a>)' Empacota <expr> em uma caixa rotulada pelo
     símbolo <a>.  O rótulo é truncado se for maior que a largura da
     caixa.

     `box' avalia seu argumento.  Todavia, uma expressão dentro de uma
     caixa não avalia para seu conteúdo, então expressões dentro de
     caixas são efectivamente excluídas de cálculos.

     `boxchar' é o caractere usado para desenhar a caixa em `box' e nas
     funções `dpart' e `lpart'.

     Exemplos:

          (%i1) box (a^2 + b^2);
                                      """""""""
                                      " 2    2"
          (%o1)                       "b  + a "
                                      """""""""
          (%i2) a : 1234;
          (%o2)                         1234
          (%i3) b : c - d;
          (%o3)                         c - d
          (%i4) box (a^2 + b^2);
                                """"""""""""""""""""
                                "       2          "
          (%o4)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i5) box (a^2 + b^2, term_1);
                                term_1""""""""""""""
                                "       2          "
          (%o5)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i6) 1729 - box (1729);
                                           """"""
          (%o6)                     1729 - "1729"
                                           """"""
          (%i7) boxchar: "-";
          (%o7)                           -
          (%i8) box (sin(x) + cos(y));
                                  -----------------
          (%o8)                   -cos(y) + sin(x)-
                                  -----------------


 -- Variável de opção: boxchar
     Valor por omissão: `"'

     `boxchar' é o caractere usado para desenhar a caixa por `box' e
     nas funções `dpart' e `lpart'.

     Todas as caixas em uma expressão são desenhadas com o valor actual
     de `boxchar'; o caractere de desenho não é armazenado com a
     expressão de caixa. Isso quer dizer que se desenhar uma caixa e em
     seguida mudar o caracter de desenho a caixa anteriormente desenhada
     será redesenhada com o caracter mudado caso isso seja solicitado.


 -- Função: carg (<z>)
     Retorna o argumento complexo de <z>.  O argumento complexo é um
     ângulo `theta' no intervalo de `(-%pi, %pi]' tal que `r exp (theta
     %i) = <z>' onde `r' é o módulo de <z>.

     `carg' é uma função computacional, não uma função de
     simplificação.

     `carg' ignora a declaração `declare (<x>, complex)', e trata <x>
     como uma variável real.  Isso é um erro.  Veja também `abs'
     (módulo de número complexo), `polarform', `rectform', `realpart',
     e `imagpart'.

     Exemplos:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2


 -- Opereador especial: constant
     `declare (<a>, constant)' declara <a> para ser uma constante.
     Veja `declare'.


 -- Função: constantp (<expr>)
     Retorna `true' se <expr> for uma expressão constante, de outra
     forma retorna `false'.

     Uma expressão é considerada uma expressão constante se seus
     argumentos forem números (incluindo números racionais, como
     mostrado com `/R/'), constantes simbólicas como `%pi', `%e', e
     `%i', variáveis associadas a uma constante ou constante declarada
     através de `declare', ou funções cujos argumentos forem constantes.

     `constantp' avalia seus argumentos.

     Exemplos:

          (%i1) constantp (7 * sin(2));
          (%o1)                                true
          (%i2) constantp (rat (17/29));
          (%o2)                                true
          (%i3) constantp (%pi * sin(%e));
          (%o3)                                true
          (%i4) constantp (exp (x));
          (%o4)                                false
          (%i5) declare (x, constant);
          (%o5)                                done
          (%i6) constantp (exp (x));
          (%o6)                                true
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7)                                false
          (%i8)


 -- Função: declare (<a_1>, <p_1>, <a_2>, <p_2>, ...)
     Atribui aos átomos ou lista de átomos <a_i> a propriedade ou lista
     de propriedades <p_i>.  Quando <a_i> e/ou <p_i> forem listas, cada
     um dos átomos recebe todas as propriedades.

     `declare' não avalia seus argumentos.  `declare' sempre retorna
     `done'.

     Como colocado na descrição para cada sinalizador de declaração,
     para alguns sinalizadores `featurep(<objecto>, <recurso>)' retorna
     `true' se <objecto> tiver sido declarado para ter <recurso>.
     Todavia, `featurep' não reconhece alguns sinalizadores; isso é um
     erro.

     Veja também `features'.

     `declare' reconhece as seguintes propriedades:

    `evfun'
          Torna <a_i> conhecido para `ev' de forma que a função nomeada
          por <a_i> é aplicada quando <a_i> aparece como um sinalizador
          argumento de `ev'.  Veja `evfun'.

    `evflag'
          Torna <a_i> conhecido para a função `ev' de forma que <a_i> é
          associado a `true' durante a execução de `ev' quando <a_i>
          aparece como um sinalizador argumento de `ev'.  Veja `evflag'.

    `bindtest'
          Diz ao Maxima para disparar um erro quando <a_i> for avaliado
          como sendo livre de associação.

    `noun'
          Diz ao Maxima para passar <a_i> como um substantivo.  O
          efeito disso é substituir intâncias de <a_i> com `'<a_i>' ou
          `nounify(<a_i>)', ependendo do contexto.

    `constant'
          Diz ao Maxima para considerar <a_i> uma constante simbólica.

    `scalar'
          Diz ao Maxima para considerar <a_i> uma variável escalar.

    `nonscalar'
          Diz ao Maxima para considerar <a_i> uma variável não escalar.
          The usual application is to declare a variable as a symbolic
          vector or matrix.

    `mainvar'
          Diz ao Maxima para considerar <a_i> uma "variável principal"
          (`mainvar').  `ordergreatp' determina a ordenação de átomos
          como segue:

          (variáveis principais) > (outras variáveis) > (variáveis
          escalares) > (constantes) > (números)

    `alphabetic'
          Diz ao Maxima para reconhecer todos os caracteres em <a_i>
          (que deve ser uma sequência de caracteres) como caractere
          alfabético.

    `feature'
          Diz ao Maxima para reconhecer <a_i> como nome de um recurso.
          Other atoms may then be declared to have the <a_i> property.

    `rassociative', `lassociative'
          Diz ao Maxima para reconhecer <a_i> como uma funcão
          associativa a direita ou associativa a esquerda.

    `nary'
          Diz ao Maxima para reconhecer <a_i> como uma função n-ária
          (com muitos argumentos).

          A declaração `nary' não tem o mesmo objectivo que uma chamada
          à função `nary'.  O único efeito de `declare(foo, nary)' é
          para instruir o simplificador do Maxima a melhorar as
          próximas expressões, por exemplo, para simplificar `foo(x,
          foo(y, z))' para `foo(x, y, z)'.

    `symmetric', `antisymmetric', `commutative'
          Diz ao Maxima para reconhecer <a_i> como uma função simétrica
          ou antisimétrica.  `commutative' é o mesmo que `symmetric'.


          `oddfun', `evenfun' Diz ao Maxima para reconhecer <a_i> como
          uma função par ou uma função ímpar.

    `outative'
          Diz ao Maxima para simplificar expressões <a_i> colocando
          factores constantes em evidência no primeiro argumento.

          Quando <a_i> tiver um argumento, um factor é onsiderado
          constante se for um literal ou se for declarado como sendo
          constante.

          Quando <a_i> tiver dois ou mais argumentos, um factor é
          considerado constante se o segundo argumento for um símbolo e
          o factor estiver livre do segundo argumento.

    `multiplicative'
          Diz ao Maxima para simplificar expressões do tipo <a_i>
          através da substituição `<a_i>(x * y * z * ...)' `-->'
          `<a_i>(x) * <a_i>(y) * <a_i>(z) * ...'.  A substituição é
          realizada no primeiro argumento somente.

    `additive'
          Diz ao Maxima para simplificar expressões do tipo <a_i>
          através da substituição `<a_i>(x + y + z + ...)' `-->'
          `<a_i>(x) + <a_i>(y) + <a_i>(z) + ...'.  A substituição é
          realizada no primeiro argumento somente.

    `linear'
          Equivalente a declarar <a_i> ao mesmo tempo `outative' e
          `additive'.

    `integer', `noninteger'
          Diz ao Maxima para reconhecer <a_i> como como uma variável
          inteira ou como uma variável não inteira.

          Maxima reconhece os seguintes recursos de objectos:

    `even', `odd'
          Diz ao Maxima para reconhecer <a_i> como uma variável inteira
          par ou como uma variável inteira ímpar.

    `rational', `irrational'
          Diz ao Maxima para reconhecer <a_i> como uma variável real e
          racional ou como uma variável real e irracional.

    `real', `imaginary', `complex'
          Dia ao Maxima para reconhecer <a_i> como uma variável real,
          imaginária pura ou complexa.

    `increasing', `decreasing'
          Dia ao Maxima para reconhecer <a_i> como uma função de
          incremento ou decremento.

    `posfun'
          Diz ao Maxima para reconhecer <a_i> como uma função positiva.

    `integervalued'
          Diz ao Maxima para reconhecer <a_i> como uma função de
          valores inteiros.


     Exemplos:

     Declarações `evfun' e `evflag'.
          (%i1) declare (expand, evfun);
          (%o1)                         done
          (%i2) (a + b)^3;
                                             3
          (%o2)                       (b + a)
          (%i3) (a + b)^3, expand;
                               3        2      2      3
          (%o3)               b  + 3 a b  + 3 a  b + a
          (%i4) declare (demoivre, evflag);
          (%o4)                         done
          (%i5) exp (a + b*%i);
                                       %i b + a
          (%o5)                      %e
          (%i6) exp (a + b*%i), demoivre;
                                a
          (%o6)               %e  (%i sin(b) + cos(b))

     Declaração `bindtest'.
          (%i1) aa + bb;
          (%o1)                        bb + aa
          (%i2) declare (aa, bindtest);
          (%o2)                         done
          (%i3) aa + bb;
          aa unbound variable
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) aa : 1234;
          (%o4)                         1234
          (%i5) aa + bb;
          (%o5)                       bb + 1234

     Declaração `noun'.
          (%i1) factor (12345678);
                                       2
          (%o1)                     2 3  47 14593
          (%i2) declare (factor, noun);
          (%o2)                         done
          (%i3) factor (12345678);
          (%o3)                   factor(12345678)
          (%i4) ''%, nouns;
                                       2
          (%o4)                     2 3  47 14593

     Declarações `constant', `scalar', `nonscalar', e `mainvar'.

     Declaração `alphabetic'.
          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

     Declaração `feature'.
          (%i1) declare (FOO, feature);
          (%o1)                         done
          (%i2) declare (x, FOO);
          (%o2)                         done
          (%i3) featurep (x, FOO);
          (%o3)                         true

     Declarações `rassociative' e `lassociative'.

     Declaração `nary'.
          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

     Declarações `symmetric' e `antisymmetric'.
          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (S, symmetric);
          (%o2)                         done
          (%i3) S (b, a);
          (%o3)                        S(a, b)
          (%i4) S (a, c, e, d, b);
          (%o4)                   S(a, b, c, d, e)
          (%i5) T (b, a);
          (%o5)                        T(b, a)
          (%i6) declare (T, antisymmetric);
          (%o6)                         done
          (%i7) T (b, a);
          (%o7)                       - T(a, b)
          (%i8) T (a, c, e, d, b);
          (%o8)                   T(a, b, c, d, e)

     Declarações `oddfun' e `evenfun'.
          (%i1) o (- u) + o (u);
          (%o1)                     o(u) + o(- u)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- u) + o (u);
          (%o3)                           0
          (%i4) e (- u) - e (u);
          (%o4)                     e(- u) - e(u)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- u) - e (u);
          (%o6)                           0

     Declaração `outative'.
          (%i1) F1 (100 * x);
          (%o1)                       F1(100 x)
          (%i2) declare (F1, outative);
          (%o2)                         done
          (%i3) F1 (100 * x);
          (%o3)                       100 F1(x)
          (%i4) declare (zz, constant);
          (%o4)                         done
          (%i5) F1 (zz * y);
          (%o5)                       zz F1(y)

     Declaração `multiplicative'.
          (%i1) F2 (a * b * c);
          (%o1)                       F2(a b c)
          (%i2) declare (F2, multiplicative);
          (%o2)                         done
          (%i3) F2 (a * b * c);
          (%o3)                   F2(a) F2(b) F2(c)

     Declaração `additive'.
          (%i1) F3 (a + b + c);
          (%o1)                     F3(c + b + a)
          (%i2) declare (F3, additive);
          (%o2)                         done
          (%i3) F3 (a + b + c);
          (%o3)                 F3(c) + F3(b) + F3(a)

     Declaração `linear'.
          (%i1) 'sum (F(k) + G(k), k, 1, inf);
                                 inf
                                 ====
                                 \
          (%o1)                   >    (G(k) + F(k))
                                 /
                                 ====
                                 k = 1
          (%i2) declare (nounify (sum), linear);
          (%o2)                         done
          (%i3) 'sum (F(k) + G(k), k, 1, inf);
                               inf          inf
                               ====         ====
                               \            \
          (%o3)                 >    G(k) +  >    F(k)
                               /            /
                               ====         ====
                               k = 1        k = 1


 -- Função: disolate (<expr>, <x_1>, ..., <x_n>)
     é similar a `isolate (<expr>, <x>)' excepto que essa função
     habilita ao utilizador isolar mais que uma variável
     simultâneamente.  Isso pode ser útil, por exemplo, se se tiver
     tentado mudar variáveis em uma integração múltipla, e em
     mudança de variável envolvendo duas ou mais das variáveis de
     integração.  Essa função é chamada automaticamente de
     `simplification/disol.mac'.  Uma demostração está disponível
     através de `demo("disol")$'.


 -- Função: dispform (<expr>)
     Retorna a representação externa de <expr> com relação a seu
     principal operador.  Isso pode ser útil em conjunção com `part' que
     também lida com a representação externa.  Suponha que <expr> seja
     -A .  Então a representação interna de <expr> é  "*"(-1,A),
     enquanto que a representação externa é "-"(A). `dispform (<expr>,
     all)' converte a expressão inteira (não apenas o nível mais alto)
     para o formato externo.  Por exemplo, se `expr: sin (sqrt (x))',
     então `freeof (sqrt, expr)' e `freeof (sqrt, dispform (expr))'
     fornece `true', enquanto `freeof (sqrt, dispform (expr, all))'
     fornece `false'.


 -- Função: distrib (<expr>)
     Distribue adições sobre produtos.  `distrib' difere de `expand' no
     facto de que `distrib' trabalha em somente no nível mais alto de
     uma expressão, i.e., `distrib' não é recursiva e `distrib' é mais
     rápida que `expand'.  `distrib' difere de `multthru' no que
     `distrib' expande todas as adições naquele nível.

     Exemplos:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c


 -- Função: dpart (<expr>, <n_1>, ..., <n_k>)
     Selecciona a mesma subexpressão que `part', mas em lugar de apenas
     retornar aquela subexpressão como seu valor, isso retorna a
     expressão completa com a subexpressão seleccionada mostrada dentro
     de uma caixa.  A caixa é actualmente parte da expressão.

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """


 -- Função: exp (<x>)
     Representa função exponencial.  Instâncias de `exp (<x>)' em uma
     entrada são simplificadas para `%e^<x>'; `exp' não aparece em
     expressões simplificadas.

     `demoivre' se `true' faz com que `%e^(a + b %i)' simplificar para
     `%e^(a (cos(b) + %i sin(b)))' se `b' for livre de `%i'. veja
     `demoivre'.

     `%emode', quando `true', faz com que `%e^(%pi %i x)' seja
     simplificado. Veja `%emode'.

     `%enumer', quando `true' faz com que `%e' seja substituído por
     2.718...  quando `numer' for `true'. Veja `%enumer'.


 -- Variável de opção: %emode
     Valor por omissão: `true'

     Quando `%emode' for `true', `%e^(%pi %i x)' é simplificado como
     segue.

     `%e^(%pi %i x)' simplifica para `cos (%pi x) + %i sin (%pi x)' se
     `x' for um inteiro ou um múltiplo de 1/2, 1/3, 1/4, ou 1/6, e
     então é adicionalmente simplificado.

     Para outro `x' numérico, `%e^(%pi %i x)' simplifica para `%e^(%pi
     %i y)' onde `y' é `x - 2 k' para algum inteiro `k' tal que `abs(y)
     < 1'.

     Quando `%emode' for `false', nenhuma simplificação adicional de
     `%e^(%pi %i x)' é realizada.


 -- Variável de opção: %enumer
     Valor por omissão: `false'

     Quando `%enumer' for `true', `%e' é substituido por seu valor
     numérico 2.718...  mesmo que `numer' seja `true'.

     Quando `%enumer' for `false', essa substituição é realizada
     somente se o expoente em `%e^x' avaliar para um número.

     Veja também `ev' e `numer'.


 -- Variável de opção: exptisolate
     Valor por omissão: `false'

     `exptisolate', quando `true', faz com que `isolate (expr, var)'
     examine expoentes de átomos (tais como `%e') que contenham `var'.


 -- Variável de opção: exptsubst
     Valor por omissão: `false'

     `exptsubst', quando `true', permite substituições tais como `y'
     para `%e^x' em `%e^(a x)'.


 -- Função: freeof (<x_1>, ..., <x_n>, <expr>)
     `freeof (<x_1>, <expr>)' Retorna `true' se nenhuma subexpressão de
     <expr> for igual a <x_1> ou se <x_1> ocorrer somente uma variável
     que não tenha associação fora da expressão <expr>, e retorna
     `false' de outra forma.

     `freeof (<x_1>, ..., <x_n>, <expr>)' é equivalente a `freeof
     (<x_1>, <expr>) and ... and freeof (<x_n>, <expr>)'.

     Os argumentos <x_1>, ..., <x_n> podem ser nomes de funções e
     variáveis, nomes subscritos, operadores (empacotados em aspas
     duplas), ou expressões gerais.  `freeof' avalia seus argumentos.

     `freeof' opera somente sobre <expr> como isso representa (após
     simplificação e avaliação) e não tenta determinar se alguma
     expressão equivalente pode fornecer um resultado diferente.  Em
     particular, simplificação pode retornar uma expressão equivalente
     mas diferente que compreende alguns diferentes elementos da forma
     original de <expr>.

     Uma variável é uma variável dummy em uma expressão se não tiver
     associação fora da expressão.  Variáveis dummy recoreconhecidas
     através de `freeof' são o índice de um somatório ou produtório, o
     limite da variável em `limit', a variável de integração na forma
     de integral definida de `integrate', a variável original em
     `laplace', variáveis formais em expressoes `at', e argumentos em
     expressões `lambda'.  Variáveis locais em `block' não são
     reconhecidas por `freeof' como variáveis dummy; isso é um bug.

     A forma indefinida de `integrate' not é livre de suas variáveis de
     integração.

        * Argumentos são nomes de funções, variáveis, nomes subscritos,
          operadores, e expressões.  `freeof (a, b, expr)' é
          equivalente a `freeof (a, expr) and freeof (b, expr)'.

               (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                                d + c  3
               (%o1)                   cos(a ) b      z
                                            1
               (%i2) freeof (z, expr);
               (%o2)                         false
               (%i3) freeof (cos, expr);
               (%o3)                         false
               (%i4) freeof (a[1], expr);
               (%o4)                         false
               (%i5) freeof (cos (a[1]), expr);
               (%o5)                         false
               (%i6) freeof (b^(c+d), expr);
               (%o6)                         false
               (%i7) freeof ("^", expr);
               (%o7)                         false
               (%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
               (%o8)                         true

        * `freeof' avalia seus argumentos.

               (%i1) expr: (a+b)^5$
               (%i2) c: a$
               (%i3) freeof (c, expr);
               (%o3)                         false

        * `freeof' não considera expressões equivalentes.
          Simplificação pode retornar uma expressão equivalente mas
          diferente.

               (%i1) expr: (a+b)^5$
               (%i2) expand (expr);
                         5        4       2  3       3  2      4      5
               (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
               (%i3) freeof (a+b, %);
               (%o3)                         true
               (%i4) freeof (a+b, expr);
               (%o4)                         false
               (%i5) exp (x);
                                                x
               (%o5)                          %e
               (%i6) freeof (exp, exp (x));
               (%o6)                         true

        * Um somatório ou uma integral definida está livre de uma
          variável dummy.  Uma integral indefinida não é livre de suas
          variáveis de integração.

               (%i1) freeof (i, 'sum (f(i), i, 0, n));
               (%o1)                         true
               (%i2) freeof (x, 'integrate (x^2, x, 0, 1));
               (%o2)                         true
               (%i3) freeof (x, 'integrate (x^2, x));
               (%o3)                         false


 -- Função: genfact (<x>, <y>, <z>)
     Retorna o factorial generalizado, definido como `x (x-z) (x - 2 z)
     ... (x - (y - 1) z)'.  Dessa forma, para integral <x>, `genfact
     (x, x, 1) = x!' e `genfact (x, x/2, 2) = x!!'.


 -- Função: imagpart (<expr>)
     Retorna a parte imaginária da expressão <expr>.

     `imagpart' é uma função computacional, não uma função de
     simplificação.

     Veja também `abs', `carg', `polarform', `rectform', e `realpart'.


 -- Função: infix (<op>)
 -- Função: infix (<op>, <lbp>, <rbp>)
 -- Função: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)
     Declara <op> para ser um operador infixo.  Um operador infixo é
     uma função de dois argumentos, com o nome da função escrito entre
     os argumentos.  Por exemplo, o operador de subtração `-' é um
     operador infixo.

     `infix (<op>)' declara <op> para ser um operador infixo com
     expoentes associados padrão (esquerdo e direito ambos iguais a 180)
     e podendo ser qualquer entre prefixado, infixado, posfixado, nário,
     matchfix e nofix (esquerdo e direito ambos iguais a `any').

     `infix (<op>, <lbp>, <rbp>)' declara <op> para ser um operador
     infixo com expoentes associados esquerdo e directio equilibrados e
     podendo ser qualquer entre prefixado, infixado, posfixado, nário,
     matchfix e nofix (esquerdo e direito ambos iguais a `any').

     `infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)' declara <op>
     para ser um operdor infixo com expoentes associados padrão e
     podendo ser um entre prefixado, infixado, posfixado, nário,
     matchfix e nofix.

     A precedência de <op> com relação a outros operadores derivam dos
     expoentes associados directiro e esquerdo dos operadores em
     questão.  Se os expoentes associados esquerdo e direito de <op>
     forem ambos maiores que o expoente associado esquerdo e o direito
     de algum outro operador, então <op> tem prededência sobre o outro
     operador.  Se os expoentes associados não forem ambos maior ou
     menor, alguma relação mais complicada ocorre.

     A associatividade de <op> depende de seus expoentes associados.
     Maior expoente associado esquerdo (<eae>) implica uma instância de
     <op> é avaliadas antes de outros operadores para sua esquerda em
     uma expressão, enquanto maior expoente associado direito (<ead>)
     implica uma instância de <op> é avaliada antes de outros
     operadores para sua direita em uma expressão.  Dessa forma maior
     <eae> torna <op> associativo à direita, enquanto maior <ead> torna
     <op> associativa à esquerda.  Se <eae> for igual a <ead>, <op> é
     associativa à esquerda.

     Veja também `Syntax'.

     Exemplos:

     Se os expoentes associados esquerdo e direito de <op> forem ambos
     maiores que os expoentes associados à direita e à esquerda de
     algum outro operador, então <op> tem precedência sobre o outro
     operador.

          (%i1) :lisp (get '$+ 'lbp)
          100
          (%i1) :lisp (get '$+ 'rbp)
          100
          (%i1) infix ("##", 101, 101);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
          (%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
          (%i3) 1 + a ## b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("##", 99, 99);
          (%o4)                          ##
          (%i5) 1 + a ## b + 2;
          (%o5)                       (a+1,b+2)

     grande <eae> torna <op> associativa à direita, enquanto grande
     <ead> torna <op> associativa à esquerda.

          (%i1) infix ("##", 100, 99);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i3) foo ## bar ## baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("##", 100, 101);
          (%o4)                          ##
          (%i5) foo ## bar ## baz;
          (%o5)                    ((foo,bar),baz)


 -- Variável de opção: inflag
     Velor padrão: `false'

     Quando `inflag' for `true', funções para extração de partes
     inspecionam a forma interna de `expr'.

     Note que o simplificador re-organiza expressões.  Dessa forma
     `first (x + y)' retorna `x' se `inflag' for `true' e `y' se
     `inflag' for `false'.  (`first (y + x)' fornece os mesmos
     resultados.)

     Também, escolhendo `inflag' para `true' e chamando `part' ou
     `substpart' é o mesmo que chamar `inpart' ou `substinpart'.

     As funções afectadas pela posição do sinalizador `inflag' são:
     `part', `substpart', `first', `rest', `last', `length', a
     estrutura `for' ... `in', `map', `fullmap', `maplist', `reveal' e
     `pickapart'.


 -- Função: inpart (<expr>, <n_1>, ..., <n_k>)
     É similar a `part' mas trabalha sobre a representação interna da
     expressão em lugar da forma de exibição e dessa forma pode ser
     mais rápida uma vez que nenhuma formatação é realizada.  Cuidado
     deve ser tomado com relação à ordem de subexpressões em adições e
     produtos (uma vez que a ordem das variáveis na forma interna é
     muitas vezes diferente daquela na forma mostrada) e no manuseio
     com menos unário, subtração, e divisão (uma vez que esses
     operadores são removidos da expressão). `part (x+y, 0)' ou `inpart
     (x+y, 0)' retorna `+', embora com o objectivo de referirse ao
     operador isso deva ser abraçado por aspas duplas.  Por exemplo
     `... if inpart (%o9,0) = "+" then ...'.

     Exemplos:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)


 -- Função: isolate (<expr>, <x>)
     Retorna <expr> com subexpressões que são adições e que não possuem
     <x> substituido por rótulos de expressão intermédia (esses sendo
     símbolos atômicos como `%t1', `%t2', ...).  Isso é muitas vezes
     útil para evitar expansões desnecessárias de subexpressões que não
     possuam a variável de interesse.  Uma vez que os rótulos
     intermédios são associados às subexpressões eles podem todos ser
     substituídos de volta por avaliação da expressão em que ocorrerem.

     `exptisolate' (valor padrão: `false') se `true' fará com que
     `isolate' examine expoentes de átomos (como `%e') que contenham
     <x>.

     `isolate_wrt_times' se `true', então `isolate' irá também isolar
     com relação a produtos. Veja `isolate_wrt_times'.

     Faça `example (isolate)' para exemplos.


 -- Variável de opção: isolate_wrt_times
     Valor por omissão: `false'

     Quando `isolate_wrt_times' for `true', `isolate' irá também isolar
     com relação a produtos.  E.g. compare ambas as escolhas do
     comutador em

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4


 -- Variável de opção: listconstvars
     Valor por omissão: `false'

     Quando `listconstvars' for `true', isso fará com que `listofvars'
     inclua `%e', `%pi', `%i', e quaisquer variáveis declaradas
     contantes na lista seja retornado se aparecer na expressão que
     chamar `listofvars'.  O comportamento padrão é omitir isso.


 -- Variável de opção: listdummyvars
     Valor por omissão: `true'

     Quando `listdummyvars' for `false', "variáveis dummy" na expressão
     não serão incluídas na lista retornada por `listofvars'.  (O
     significado de "variável dummy" é o mesmo que em `freeof'.
     "Variáveis dummy" são conceitos matemáticos como o índice de um
     somatório ou produtório, a variável limite, e a variável da
     integral definida.)  Exemplo:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]


 -- Função: listofvars (<expr>)
     Retorna uma lista de variáveis em <expr>.

     `listconstvars' se `true' faz com que `listofvars' inclua `%e',
     `%pi', `%i', e quaisquer variáveis declaradas constantes na lista
     é retornada se aparecer em <expr>.  O comportamento padrão é
     omitir isso.

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1


 -- Função: lfreeof (<lista>, <expr>)
     Para cada um dos membros <m> de lista, chama `freeof (<m>,
     <expr>)'.  Retorna `false' se qualquer chamada a `freeof' for
     feita e `true' de outra forma.

 -- Função: lopow (<expr>, <x>)
     Retorna o menor expoente de <x> que explicitamente aparecer em
     <expr>.  Dessa forma

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)


 -- Função: lpart (<rótulo>, <expr>, <n_1>, ..., <n_k>)
     é similar a `dpart' mas usa uma caixa rotulada. Uma caixa rotulada
     é similar à que é produzida por `dpart' mas a produzida por
     `lpart' tem o nome na linha do topo.


 -- Função: multthru (<expr>)
 -- Função: multthru (<expr_1>, <expr_2>)
     Multiplica um factor (que pode ser uma adição) de <expr> pelos
     outros factores de <expr>.  Isto é, <expr> é `<f_1> <f_2> ...
     <f_n>' onde ao menos um factor, digamos <f_i>, é uma soma de
     termos.  Cada termo naquela soma é multiplicado por outros
     factores no produto.  (A saber todos os factores excepto <f_i>).
     `multthru' não expande somas exponenciais.  Essa função é o
     caminho mais rápido para distribuir produtos (comutativos ou não)
     sobre adições.  Uma vez que quocientes são representados como
     produtos `multthru' podem ser usados para dividir adições por
     produtos também.

     `multthru (<expr_1>, <expr_2>)' multiplica cada termo em <expr_2>
     (que pode ser uma adição ou uma equção) por <expr_1>.  Se <expr_1>
     não for por si mesmo uma adição então essa forma é equivalente a
     `multthru (<expr_1>*<expr_2>)'.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note que isso não expande (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b


 -- Função: nounify (<f>)
     Retorna a forma substantiva do nome da função <f>.  Isso é
     necessário se se quer referir ao nome de uma função verbo como se
     esse nome fosse um substantivo.  Note que algumas funções verbos
     irão retornar sua forma substantiva senão puderem ser avaliadas
     para certos argumentos.  A forma substantiva é também a forma
     retornada se uma chamada de função é precedida por um apóstrofo.


 -- Função: nterms (<expr>)
     Retorna o número de termos que <expr> pode ter se for
     completamente expandida e nenhum cancelamento ou combinação de
     termos acontecer.  Note expressões como `sin (<expr>)', `sqrt
     (<expr>)', `exp (<expr>)', etc.  contam como apenas um termo
     independentemente de quantos termos <expr> tenha (se <expr> for uma
     adição).


 -- Função: op (<expr>)
     Retorna o operador principal da expressão <expr>.  `op (<expr>)' é
     equivalente a `part (<expr>, 0)'.

     `op' retorna uma sequência de caracteres se o operador principal
     for uma operador interno ou definido pelo utilizador como
     prefixado, binário ou n-ário infixo, posfixado, matchfix ou nofix.
     De outra forma, se <expr> for uma expressão de função subscrita,
     `op' retorna uma função subscrita; nesse caso o valor de retorno
     não é um átomo.  De outro modo, <expr> é uma função de array ou
     uma expressão de função comum, e `op' retorna um símbolo.

     `op' observa o valor do sinalizador global `inflag'.

     `op' avalia seus argumentos.

     Veja também `args'.

     Exemplos:

          (%i1) stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"
          (%i12) op (F [x, y] (a, b, c));
          (%o12)                        F
                                         x, y
          (%i13) op (G [u, v, w]);
          (%o13)                          G


 -- Função: operatorp (<expr>, <op>)
 -- Função: operatorp (<expr>, [<op_1>, ..., <op_n>])
     `operatorp (<expr>, <op>)' retorna `true' se <op> for igual ao
     operador de <expr>.

     `operatorp (<expr>, [<op_1>, ..., <op_n>])' retorna `true' se
     algum elementos de <op_1>, ..., <op_n> for igual ao operador de
     <expr>.


 -- Função: optimize (<expr>)
     Retorna uma expressão que produz o mesmo valor e efeito que <expr>
     mas faz de forma mais eficientemente por evitar a recomputação de
     subexpressões comuns.  `optimize' também tem o mesmo efeito de
     "colapsar" seus argumentos de forma que todas as subexpressões
     comuns são compartilhadas.  Faça `example (optimize)' para
     exemplos.


 -- Variável de opção: optimprefix
     Valor por omissão: `%'

     `optimprefix' é o prefixo usado para símbolos gerados pelo comando
     `optimize'.


 -- Função: ordergreat (<v_1>, ..., <v_n>)
     Escolhe aliases para as variáveis <v_1>, ..., <v_n> tais que <v_1>
     > <v_2> > ...  > <v_n>, e <v_n> > qualquer outra variável não
     mencionada como um argumento.

     Veja também `orderless'.


 -- Função: ordergreatp (<expr_1>, <expr_2>)
     Retorna `true' se <expr_2> precede <expr_1> na ordenação escolhida
     com a função `ordergreat'.


 -- Função: orderless (<v_1>, ..., <v_n>)
     Escolhe aliases para as variáveis <v_1>, ..., <v_n> tais que <v_1>
     < <v_2> < ...  < <v_n>, and <v_n> < qualquer outra variável não
     mencionada como um argumento.

     Dessa forma a escala de ordenação completa é: constantes numéricas
     < constantes declaradas < escalares declarados < primeiro
     argumento para `orderless' < ...  < último argumento para
     `orderless' < variáveis que começam com A < ...  < variáveis que
     começam com Z < último argumento para `ordergreat' <  ... <
     primeiro argumento para `ordergreat' < `mainvar's - variáveis
     principais declaradas.

     Veja também `ordergreat' e `mainvar'.


 -- Função: orderlessp (<expr_1>, <expr_2>)
     Retorna `true' se <expr_1> precede <expr_2> na ordenação escolhida
     pelo comando `orderless'.


 -- Função: part (<expr>, <n_1>, ..., <n_k>)
     Retorna partes da forma exibida de `expr'. Essa função obtém a
     parte de `expr' como especificado pelos índices <n_1>, ..., <n_k>.
     A primeira parte <n_1> de `expr' é obtida, então a parte <n_2>
     daquela  é obtida, etc.  O resultado é parte <n_k> de ... parte
     <n_2> da parte <n_1> da `expr'.

     `part' pode ser usada para obter um elemento de uma lista, uma
     linha de uma matriz, etc.

     Se o último argumento para uma função `part' for uma lista de
     índices então muitas subexpressões serão pinçadas, cada uma
     correspondendo a um índice da lista.  Dessa forma `part (x + y +
     z, [1, 3])' é `z+x'.

     `piece' mantém a última expressão seleccionada quando usando as
     funções `part'.  Isso é escolhido durante a execução da função e
     dessa forma pode referir-se à função em si mesma como mostrado
     abaixo.

     Se `partswitch' for escolhido para `true' então `end' é retornado
     quando uma parte seleccionada de uma expressão não existir, de
     outra forma uma mensagem de erro é forncecida.

     Exemplo: `part (z+2*y, 2, 1)' retorna 2.

     `example (part)' mostra exemplos adicionais.


 -- Função: partition (<expr>, <x>)
     Retorna uma lista de duas expressões.  Elas são (1) os factores de
     <expr> (se essa expressão for um produto), os termos de <expr> (se
     isso for uma adição), ou a lista (se isso for uma lsita) que não
     contiver `var' e, (2) os factores, termos, ou lista que faz.

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]


 -- Variável de opção: partswitch
     Valor por omissão: `false'

     Quando `partswitch' for `true', `end' é retornado quando uma parte
     seleccionada de uma expressão não existir, de outra forma uma
     mensagem de erro é fornecida.


 -- Função: pickapart (<expr>, <n>)
     Atribui rótulos de expressão intermédia a subexpressões de <expr>
     de comprimento <n>, um inteiro.  A subexpressões maiores ou
     menores não são atribuidos rótulos.  `pickapart' retorna uma
     expressão em termos de expressões intermédias equivalentes à
     expressão original <expr>.

     Veja também `part', `dpart', `lpart', `inpart', e `reveal'.

     Exemplos:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);

                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2

          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)

                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2


 -- Variável de sistema: piece
     Mantém a ultima expressão seleccionada quando usando funções
     `part'.  Isso é escolhido durante a execução da função e dessa
     forma pode referir-se à função em si mesma.


 -- Função: polarform (<expr>)
     Retorna uma expressão `r %e^(%i theta)' equivalente a <expr>, tal
     que `r' e `theta' sejam puramente reais.


 -- Função: powers (<expr>, <x>)
     Fornece os expoentes de <x> que ocorrem em expressão <expr>.

     `load (powers)' chama essa função.


 -- Função: product (<expr>, <i>, <i_0>, <i_1>)
     Representa um produto dos velores de `expr' com o índice <i>
     variando de <i_0> a <i_1>.  A forma substantiva `'product' é
     mostrada como um pi maiísculo.

     `product' avalia <expr> e os limites inferior e superior <i_0> e
     <i_1>, `product' coloca um apóstrofo (não avalia) o índice <i>.

     Se os limites superiores e inferiores diferirem por um inteiro,
     <expr> é avaliada para cada valor do índice <i>, e o resultado  um
     produto explícito.

     de outra forma, o intervalo do índice é indefinido.  Algumas
     regras são aplicads para simplificar o produto.  Quando a variável
     global `simpproduct' for `true', regras adicionais são aplicadas.
     Em alguns casos, simplificação um resultado que não é um produto;
     de outra forma, o resultado é uma forma substantiva `'product'.

     Veja também `nouns' e `evflag'.

     Exemplos:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b


 -- Função: realpart (<expr>)
     Retorna a parte real de <expr>. `realpart' e `imagpart' irão
     trabalhar sobre expressões envolvendo funções trigonométricas e
     hiperbólicas, bem como raízes quadradas, logaritmos, e
     exponenciação.


 -- Função: rectform (<expr>)
     Retorna uma expressão `a + b %i' equivalente a <expr>, tal que <a>
     e <b> sejam puramente reais.


 -- Função: rembox (<expr>, unlabelled)
 -- Função: rembox (<expr>, <rótulo>)
 -- Função: rembox (<expr>)
     Remove caixas de <expr>.

     `rembox (<expr>, unlabelled)' remove todas as caixas sem rótulos
     de <expr>.

     `rembox (<expr>, <rótulo>)' remove somente caixas contendo
     <rótulo>.

     `rembox (<expr>)' remove todas as caixas, rotuladas e nã rotuladas.

     Caixas são desenhadas pelas funções `box', `dpart', e `lpart'.

     Exemplos:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h
          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"
          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""
          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h


 -- Função: sum (<expr>, <i>, <i_0>, <i_1>)
     Representa um somatório dos valores de <expr> com o índice <i>
     variando de <i_0> a <i_1>.  A forma substantiva `'sum' é mostrada
     com uma letra sigma maiúscula.  `sum' avalia seu somando <expr> e
     limites inferior e superior <i_0> e <i_1>, `sum' coloca apóstrofo
     (não avalia) o índice <i>.

     Se os limites superiores e inferiores diferirem de um número
     inteiro, o somatoriando <expr> é avaliado para cada valor do
     índice do somatório <i>, e o resultado é uma adição explícita.

     De outra forma, o intervalo dos índices é indefinido.  Algumas
     regras são aplicadas para simplificar o somatório.  Quando a
     variável global `simpsum' for `true', regras adicionais são
     aplicadas.  Em alguns casos, simplificações retornam um resultado
     que não é um somatório; de outra forma, o resultado é uma forma
     substantiva `'sum'.

     Quando o `evflag' (sinalizador de avaliação) `cauchysum' for
     `true', um produto de somatórios é mostrado como um produto de
     Cauchy, no qual o índice do somatório mais interno é uma função de
     índice de um nível acima, em lugar de variar independentemente.

     A variável global `genindex' é o prefixo alfabético usado para
     gerar o próximo índice do somatório, quando um índice
     automaticamente gerado for necessário.

     `gensumnum' é o sufixo numérico usando para gerar o próximo índice
     do somatório, quando um índice gerado automaticamente for
     necessário.  Quando `gensumnum' for `false', um índice gerado
     automaticamente é somente `genindex' sem sufixo numérico.

     Veja também `sumcontract', `intosum', `bashindices', `niceindices',
     `nouns', `evflag', e `zeilberger'.

     Exemplos:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10));
          Incorrect syntax: Too many )'s
          else b^k, k, 1, 10))
                            ^
          (%i12) linenum:11;
          (%o11)                         11
          (%i12) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o12)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i13) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o13)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a


 -- Função: lsum (<expr>, <x>, <L>)
     Representas a adição de <expr> a cada elemento <x> em <L>.

     Uma forma substantiva `'lsum' é retornada se o argumento <L> não
     avaliar para uma lista.

     Exemplos:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1)


 -- Função: verbify (<f>)
     Retorna a forma verbal da função chamada <f>.

     Veja também `verb', `noun', e `nounify'.

     Exemplos:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO



File: maxima.info,  Node: Simplificação,  Next: Criação de Gráficos,  Prev: Expressões,  Up: Top

7 Simplificação
***************

* Menu:

* Definições para Simplificação::


File: maxima.info,  Node: Definições para Simplificação,  Prev: Simplificação,  Up: Simplificação

7.1 Definições para Simplificação
=================================

 -- Variável de sistema: askexp
     Quando `asksign' é chamada, `askexp' é a expressão que `asksign'
     está a testar.

     Antigamente, era possível para um utilizador inspecionar `askexp'
     parando o Maxima com control-A.

 -- Função: askinteger (<expr>, integer)
 -- Função: askinteger (<expr>)
 -- Função: askinteger (<expr>, even)
 -- Função: askinteger (<expr>, odd)
     `askinteger (<expr>, integer)' tenta determinar a partir da base
     de dados do `assume' se <expr> é um inteiro. Se não conseguir,
     `askinteger' perguntará ao utilizador, na linha de comandos, e
     inserirá essa informação na base de dados do `assume', se for
     possível.  `askinteger (<expr>)' é equivalente a `askinteger
     (<expr>, integer)'.

     Da mesma forma, `askinteger (<expr>, even)' e `askinteger (<expr>,
     odd)' tentam determinar se <expr> é um inteiro par ou inteiro
     ímpar, respectivamente.


 -- Função: asksign (<expr>)
     Primeiro tenta determinar se a expressão especificada é positiva,
     negativa, ou zero. Se isso não for possível, `asksign' perguntará
     ao utilizador as questões necessárias para completar a sua
     dedução. As respostas do utilizador serão guardadas na base de
     dados pelo tempo que durar a cálculo actual. O valor de retorno de
     `asksign' será `pos', `neg', ou `zero'.


 -- Função: demoivre (<expr>)
 -- Variável de opção: demoivre
     A função `demoivre (expr)' transforma uma expressão sem modificar
     a variável global `demoivre'.

     Quando a variável `demoivre' for `true', as exponenciais complexas
     serão convertidas em expressões equivalentes em termos das
     funções circulares: `exp (a + b*%i)' simplifica para `%e^a *
     (cos(b) + %i*sin(b))' se `b' não incluir `%i'.  `a' e `b' não
     serão expandidos.

     O valor padrão de `demoivre' é `false'.

     `exponentialize' converte funções circulares e hiperbólicas para a
     forma exponencial.  `demoivre' e `exponentialize' não podem ambas
     serem `true' ao mesmo tempo.


 -- Variável de opção: domain
     Valor por omissão: `real'

     Quando a `domain' for dado o valor `complex', `sqrt(x^2)'
     permanecerá `sqrt (x^2)' em lugar de retornar `abs(x)'.


 -- Função: expand (<expr>)
 -- Função: expand (<expr>, <p>, <n>)
     Expande a expressão <expr>.  Nos rodutos de somas e exponenciais
     de somas são expandidos os produtos, os numeradores de expressões
     racionais que incluirem somas serão quebrados nas suas respectivas
     parcelas, e os produtos (comutativos e não comutativos) são
     distribuídos sobre as somas em todos os níveis de <expr>.

     Para polinómios se pode usar frequêntemente `ratexpand' que possui
     um algoritmo mais eficiente.

     `maxnegex' e `maxposex' controlam o máximo expoente negativo e o
     máximo expoente positivo, respectivamente, que irão expandir.

     `expand (<expr>, <p>, <n>)' expande <expr>, usando <p> para
     `maxposex' e <n> para `maxnegex'.  Isso é útil para expandir
     partes numa expressão mas não toda.

     `expon' - o expoente da maior potência negativa que é
     automaticamente expandida (independente de chamadas a `expand').
     Por Exemplo se `expon' for 4 então `(x+1)^(-5)' não será
     automaticamente expandido.

     `expop' - o maior expoente positivo que é automaticamente
     expandido.  Dessa forma `(x+1)^3', quando digitado, será
     automaticamente expandido somente se `expop' for maior que ou igual
     a 3.  Se quiser que `(x+1)^n' seja expandido onde `n' for maior
     que `expop', então `expand ((x+1)^n)' funcionará unicamente se
     `maxposex' não for menor que `n'.

     O sinalizador `expand' usado com `ev' causa expansão.

     O ficheiro `simplification/facexp.mac' contém muitas funções
     relacionadas (em particular `facsum', `factorfacsum' e
     `collectterms', que são carregadas automaticamente) e as variáveis
     (`nextlayerfactor' e `facsum_combine') que fornecem ao utilizador
     a possibilidade de estruturar expressões por expansão controlada.
     Uma descrição breve das função encontra-se no ficheiro
     `simplification/facexp.usg'.  Há também uma demonstração
     disponível com o comando `demo("facexp")'.


 -- Função: expandwrt (<expr>, <x_1>, ..., <x_n>)
     Expande a expressão `expr' com relação às variáveis <x_1>, ...,
     <x_n>.  Todos os produtos que encvolvam as variáveis aparecerão
     explicitamente. O resultado estará livre de produtos de somas de
     expressões que não estejam livres das variáveis.  <x_1>, ...,
     <x_n> podem ser variáveis, operadores, ou expressões.

     Por omissão, os denominadores não são expandidos, mas isso pode ser
     controlado através da variável `expandwrt_denom'.

     Esta função é carregada automaticamente a partir de
     `simplification/stopex.mac'.


 -- Variável de opção: expandwrt_denom
     Valor por omissão: `false'

     `expandwrt_denom' controla a simplificação de expressões racionais
     feita por `expandwrt'. Se tiver valor `true', então tanto o
     numerador como o denominador da expressão serão expandidos
     conforme os argumentos de `expandwrt', mas se `expandwrt_denom'
     for `false', então somente o numerador será expandido.


 -- Função: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)
     é similar a `expandwrt', mas trata os produtos numa forma
     diferente.  `expandwrt_factored' expande somente sobre esses
     factores de `expr' que contiverem as variáveis <x_1>, ..., <x_n>.

     Esta função é carregada automaticamente a partir de
     `simplification/stopex.mac'.


 -- Variável de opção: expon
     Valor por omissão: 0

     `expon' é o expoente da maior potência negativa que é
     automaticamente expandido (independente de chamadas a `expand').
     Por exemplo, se `expon' for 4 então `(x+1)^(-5)' não será
     automaticamente expandido.


 -- Função: exponentialize (<expr>)
 -- Variável de opção: exponentialize
     A função `exponentialize (expr)' converte as funções circulares e
     hiperbólicas em <expr> para exponenciais, sem modificar a variável
     global `exponentialize'.

     Quando a variável `exponentialize' for `true', todas as funções
     circulares e hiperbólicas são convertidas para a forma
     exponencial. O valor por omissão é `false'.

     `demoivre' converte exponenciais complexas em funções circulares.
     `exponentialize' e `demoivre' não podem ambas serem `true' ao
     mesmo tempo.


 -- Variável de opção: expop
     Valor por omissão: 0

     `expop' - o maior expoente positivo que é automaticamente
     expandido.  Dessa forma `(x+1)^3', será automaticamente expandido
     somente se `expop' for maior que ou igual a 3.  Se quiser que
     `(x+1)^n' seja expandido onde `n' for maior que `expop', então
     `expand ((x+1)^n)' funcionará somente se `maxposex' não for menor
     que `n'.


 -- Variável de opção: factlim
     Valor por omissão: -1

     `factlim' especifica o maior factorial que é automaticamente
     expandido. Se for -1 então todos os inteiros são expandidos.


 -- Função: intosum (<expr>)
     Move factores multiplicativos fora de um somatório para dentro.
     Se um índice for usado na expressão de fora, então a função
     tentará achar um índice razoável, o mesmo que é feito para
     `sumcontract'.  Isto é essencialmente a ideia inversa da
     propriedade `outative' de somatórios, mas repare que não elimina
     essa propriedade, apenas faz com que seja ignorada.

     Em alguns casos, poderá ser necessário um
     `scanmap(multthru,<expr>)' antes de `intosum'.


 -- Declaração: lassociative
     `declare (g, lassociative)' diz ao simplificador do Maxima que `g'
     é associativa à esquerda.  E.g., `g (g (a, b), g (c, d))' irá
     simplificar para `g (g (g (a, b), c), d)'.


 -- Declaração: linear
     Uma das propriedades operativas do Maxima. As funções de uma única
     variável `f' assim declaradas fazem com que a expressão `f(x + y)'
     seja expandida em `f(x) + f(y)', a expressão `f(a*x)'
     transforma-se em `a*f(x)' se `a' for uma constante. Para funções
     de dois ou mais argumentos, a linearidade define-se igual que no
     caso de `sum' ou `integrate', isto é, `f (a*x + b, x)' retorna
     `a*f(x,x) + b*f(1,x)', se `a' e `b' forem independentesx de `x'.

     `linear' é equivalente a `additive' e `outative'.  Veja também
     `opproperties'.


 -- Declaração: mainvar
     Permite declarar variáveis do tipo `mainvar' (variável principal).
     A escala de ordenação para átomos é essencialmente: números <
     constantes (e.g., `%e', `%pi') < escalares < outras variáveis <
     mainvars.  Por exemplo, compare `expand ((X+Y)^4)' com `(declare
     (x, mainvar), expand ((x+y)^4))'.  (Nota: este recurso deverá ser
     usado com cautela. Por exemplo, se subtrair uma expressão, na qual
     `x' for uma `mainvar', da mesma expressão, mas onde `x' não for
     `mainvar', poderá precisar de resimplificação, por exemplo, com
     `ev (expr, simp)', para que sejam canceladas.  Também, se grava
     uma expressão na qual `x' for uma `mainvar', provavelmente deverá
     também gravar `x'.)


 -- Variável de opção: maxapplydepth
     Valor por omissão: 10000

     `maxapplydepth' é a profundidade máxima ate a qual `apply1' e
     `apply2' deverão descer.


 -- Variável de opção: maxapplyheight
     Valor por omissão: 10000

     `maxapplyheight' é nível máximo a ser atingido por `applyb1' antes
     de abandonar.


 -- Variável de opção: maxnegex
     Valor por omissão: 1000

     `maxnegex' é o maior expoente negativo que será expandido pelo
     comando `expand' (veja também `maxposex').


 -- Variável de opção: maxposex
     Valor por omissão: 1000

     `maxposex' é o maior expoente que será expandido com o comando
     `expand' (veja também `maxnegex').


 -- Declaração: multiplicative
     `declare (f, multiplicative)' diz ao simplificador do Maxima que
     `f' é multiplicativa.

       1. Se `f' for uma função de uma única variável, sempre que o
          simplificador encontrar `f' aplicada a um produto, `f' será
          distribuida nesse produto.  Por exemplo, `f(x*y)' simplifica
          para `f(x)*f(y)'.

       2. Se `f' for uma função de 2 ou mais argumentos, a
          multiplicatividade entende-se como multiplicatividade no
          primeiro argumento de `f'. Por exemplo, `f (g(x) * h(x), x)'
          simplifica para `f (g(x) ,x) * f (h(x), x)'.

     Esta simplificação não é feita quando `f' for aplicada a
     expressões da forma `product (x[i], i, m, n)'.


 -- Variável de opção: negdistrib
     Valor por omissão: `true'

     Quando `negdistrib' for `true', -1 distribue sobre uma expressão.
     Por exemplo, `-(x + y)' transforma-se em `- y - x'.  Mudando o
     valor de `negdistrib' para `false' permitirá que `- (x + y)' seja
     mostrado como foi escrito. Embora isso possa ser útil, tenha muito
     cuidado: esta variável e a variável `simp' não deveriam ser
     escolhidas sempre como `false', excepto em forma local no seu
     Maxima.


 -- Variável de opção: negsumdispflag
     Valor por omissão: `true'

     Quando `negsumdispflag' for `true', `x - y' é mostrado como `x -
     y' em lugar de como `- y + x'. Mudando para `false' faz com que
     não seja feita a verificação especial para a apresentação da
     diferença entre duas expressões.  Uma aplicação é para que `a +
     %i*b' e `a - %i*b' sejam mostrados na mesma forma.


 -- Símbolo especial: noeval
     `noeval' suprime a fase de avaliação de `ev'.  Isso é útil
     conjuntamente com outras condições e para fazer com que expressões
     sejam simplificadas sem serem reavaliadas.


 -- Declaração: noun
     `noun' é uma das opções do comando `declare'.  Faz com que as
     funções assim declaradas sejam substantivos (noun), implicando que
     não sejam avaliadas automaticamente.


 -- Variável de opção: noundisp
     Valor por omissão: `false'

     Quando `noundisp' for `true', os substantivos (nouns) são
     mostrados com um apóstrofo. Sempre que se mostra a definição de
     uma função, essa variável é igual a `true'.


 -- Símbolo especial: nouns
     `nouns' é um `evflag' (sinalizador de avaliação). Quando usado
     como uma opção para o comando `ev', `nouns' converte todas as
     formas substantivas (noun), na expressão a ser avaliada, para
     verbos ("verbs"), isto é, avalia essas expressões. Veja também
     `noun', `nounify', `verb', e `verbify'.


 -- Símbolo especial: numer
     `numer' faz com que algumas funções matemáticas (incluindo
     exponenciação) com argumentos numéricos sejam avaliadas em ponto
     flutuante. Isto faz com que variáveis em `expr' que tiverem
     valores numéricos sejam substituídas pelos seus valores
     correspondentes.  `numer' também activa a opção `float'.


 -- Função: numerval (<x_1>, <expr_1>, ..., <var_n>, <expr_n>)
     Declara as variáveis `x_1', ..., <x_n> com valores numéricos
     iguais a `expr_1', ..., `expr_n'.  O valor numérico é avaliado e
     substituido para a variável em quaisquer expressões em que a
     variável aparecer, se o sinalizador `numer' for igual a `true'.
     Veja também `ev'.

     As expressões `expr_1', ..., `expr_n' podem ser quaisquer, não
     necessariamente numéricas.

 -- Variável de sistema: opproperties
     `opproperties' é a lista de propriedades de operadores especiais
     reconhecidas pelo simplificador do Maxima: `linear', `additive',
     `multiplicative', `outative', `evenfun', `oddfun', `commutative',
     `symmetric', `antisymmetric', `nary', `lassociative',
     `rassociative'.


 -- Variável de opção: opsubst
     Valor por omissão: `true'

     Quando `opsubst' for `false', `subst' não tenta substituir dentro
     de um operador de uma expressão.  Por exemplo, `(opsubst: false,
     subst (x^2, r, r+r[0]))'.


 -- Declaração: outative
     `declare (f, outative)' diz ao simplificador do Maxima que factores
     constantes no argumento de `f' podem ser puxados para fora.

       1. Se `f' for uma função de uma única variável, sempre que o
          simplificador encontrar `f' aplicada a um produto, os
          factores que forem constantes nesse produto serão puxados para
          fora. Por exemplo, `f(a*x)' simplificará para `a*f(x)' se `a'
          for uma constante.  Factores de constantes não atômicas não
          serão puxados para fora.

       2. Se `f' for uma função de 2 ou mais argumentos, a colocação
          para fora é definida como no caso de `sum' ou `integrate',
          isto é, `f (a*g(x), x)' irá simplificar para `a * f(g(x), x)'
          se `a' não depender de `x'.

     `sum', `integrate', e `limit' são todas do tipo `outative'.


 -- Declaração: posfun
     `declare (f, posfun)' declara `f' como função positiva.  `is (f(x)
     > 0)' retorna `true'.


 -- Função: radcan (<expr>)
     Simplifica <expr>, que pode conter logaritmos, exponenciais, e
     radicais, convertendo essa expressão numa forma canónica sobre uma
     ampla classe de expressões e com uma dada ordenação de variáveis;
     isto é, todas as formas funcionalmente equivalentes são mapeadas
     numa única forma.  Para uma classe ampla de expressões, `radcan'
     produz uma forma regular.  Duas expressões equivalentes nessa
     classe não possuem necessáriamente a mesma aparência, mas as suas
     diferenças podem ser simplificadas por `radcan' para zero.

     Para algumas expressões `radcan' demora muito tempo. Esse é o
     custo de explorar as realções entre as componentes da expressão
     para simplificar expoentes usando factorização e expansão em
     frações parciais.

     Quando `%e_to_numlog' for `true', `%e^(r*log(expr))' simplifica
     para `expr^r' se `r' for um número racional.

     Quando `radexpand' for `false', certas transformações são
     inibidas.  `radcan (sqrt (1-x))' permanece `sqrt (1-x)' e não é
     simplificada para `%i sqrt (x-1)'.  `radcan (sqrt (x^2 - 2*x +
     11))' permanece `sqrt (x^2 - 2*x + 1)' e não é simplificada para
     `x - 1'.

     `example (radcan)' mostra alguns exemplos.


 -- Variável de opção: radexpand
     Valor por omissão: `true'

     `radexpand' controla algumas simplificações de radicais.

     Quando `radexpand' for `all', todos os factores que forem
     potências de ordem n, dentro de uma raiz de ordem n, serão puxados
     para fora do radical. Por exemplo, se `radexpand' for `all', `sqrt
     (16*x^2)' simplifica para `4*x'.

     Mais particularmente, considere `sqrt (x^2)'.
        * Se `radexpand' for `all' ou `assume (x > 0)' tiver sido
          executado, `sqrt(x^2)' simplifica para `x'.

        * Se `radexpand' for `true' e `domain' for `real' (valores
          usados por omissão), `sqrt(x^2)' simplifica para `abs(x)'.

        * Se `radexpand' for `false', ou `radexpand' for `true' e
          `domain' for `complex', `sqrt(x^2)' não é simplificado.

     Note que, neste exemplo, `domain' somente interessa quando
     `radexpand' for `true'.


 -- Variável de opção: radsubstflag
     Valor por omissão: `false'

     Se `radsubstflag' for `true', permite a `ratsubst' fazer
     substituições tais como `u' por `sqrt (x)' em `x'.


 -- Declaração: rassociative
     `declare (g, rassociative)' diz ao simplificador do Maxima que `g'
     é associativa à direita, isto é, `g(g(a, b), g(c, d))' simplifica
     para `g(a, g(b, g(c, d)))'.


 -- Função: scsimp (<expr>, <rule_1>, ..., <rule_n>)
     Simplificação Sequêncial Comparativa (método devido a Stoute).
     `scsimp' tenta simplificar <expr> conforme as regras <rule_1>,
     ..., <rule_n>.  Se uma expressão pequena for obtida, o processo
     repete-se.  De outra forma após todas as simplificações serem
     tentadas, `scsimp' retorna a resposta original.

     `example (scsimp)' mostra alguns exemplos.


 -- Variável de opção: simpsum
     Valor por omissão: `false'

     Quando `simpsum' for `true', o resultado de um comando `sum' é
     simplificado.  Essa simplificação pode algumas vezes produzir uma
     forma fechada.  Se `simpsum' for `false', ou se a forma com
     apóstrofo `'sum' for usada, o valor é uma forma substantiva
     aditiva que é uma representação da notação sigma usada em
     matemática.


 -- Função: sumcontract (<expr>)
     Combina vários somatórios que possuem limites superiores e
     inferiores que diferem por constantes. O resultado é uma expressão
     que contém apenas um somatório mais todos os termos adicionais que
     tiveram de ser extraídos para obter essa forma.  `sumcontract'
     combina todas as somas compatíveis e usa os indices de uma das
     somas, se puder, ou tenta formar um índice razoável se não poder
     usar nenhum dos que foram fornecidos.

     Poderá ser necessário usar `intosum (<expr>)' antes de
     `sumcontract'.


 -- Variável de opção: sumexpand
     Valor por omissão: `false'

     Quando `sumexpand' for `true', produtos de somas e somas
     exponeciadas simplificam para somas aninhadas.

     Veja também `cauchysum'.

     Exemplos:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0


 -- Variável de opção: sumsplitfact
     Valor por omissão: `true'

     Quando `sumsplitfact' for `false', `minfactorial' é aplicado após
     `factcomb'.


 -- Declaração: symmetric
     `declare (h, symmetric)' diz ao simplificador do Maxima que `h' é
     uma função simétrica.  Nomeadamente, `h (x, z, y)' simplifica para
     `h (x, y, z)'.

     `commutative' é sinônimo de `symmetric'.


 -- Função: unknown (<expr>)
     Retorna `true' se e somente se <expr> contém um operador ou
     função não reconhecida pelo simplificador do Maxima.



File: maxima.info,  Node: Criação de Gráficos,  Next: Entrada e Saída,  Prev: Simplificação,  Up: Top

8 Criação de Gráficos
*********************

* Menu:

* Definições para Criação de Gráficos::


File: maxima.info,  Node: Definições para Criação de Gráficos,  Prev: Criação de Gráficos,  Up: Criação de Gráficos

8.1 Definições para Criação de Gráficos
=======================================

 -- Variável: in_netmath
     Valor por omissão: `false'

     Quando `in_netmath' é `true', `plot3d' imprime uma saída OpenMath
     para a consola se `plot_format' é `openmath'; caso contrário
     `in_netmath' (mesmo se for `true') não tem efeito. `in_netmath'
     não tem efeito sobre `plot2d'.


 -- Função: plot2d (<expr>, <intervalo_x>, ..., <opções>, ...)
 -- Função: plot2d ([<expr_1>, ..., <expr_n>], ..., <opções>, ...)
 -- Função: plot2d ([<expr_1>, ..., <expr_n>], <intervalo_x>,...,
          <opções>, ...)
     Onde <expr>, <expr_1>, ..., <expr_n> podem ser expressões, funções
     ou operadores do Maxima ou do Lisp, ou ainda uma lista da forma
     `[discrete, [<x1>, ..., <xn>], [<y1>, ..., <yn>]]', `[discrete,
     [[<x1>, <y1>], ..., [<xn>, ..., <yn>]]' ou `[parametric, <expr_x>,
     <expr_y>, <intervalo_t>]'.

     Mostra o gráfico de uma ou mais expressões em função de uma
     variável.

     `plot2d' produz o gráfico de uma expressão <expr> ou de várias
     expressões `[<expr_1>, ..., <expr_n>]'. As expressões que não
     forem do tipo paramétrico ou discreto, deverão depender todas de
     uma única variável <var> e será obrigatório usar <intervalo_x>
     para indicar o nome dessa variável, e os seus valores mínimo e
     máximo, usando a sintaxe: `[<var>, <min>, <max>]'. O gráfico
     mostrará o eixo horizontal delimitado pelos valores <min> e <max>.

     Uma expressão a ser representada no gráfico pode ser dada também
     na forma discreta, ou paramétrica. Nomeadamente, por meio de uma
     lista a começar pela palavra "discrete" ou "parametric". A palavra
     chave <discrete> deverá ir seguida por duas listas, ambas do mesmo
     comprimento, que serão as coordenadas horizontais e verticais de um
     conjunto de pontos; em alternativa, as coordenadas de cada ponto
     podem ser colocadas numa lista de dois valores, e todas essas
     coordenadas deverão estar dentro de outra lista. A palavra chave
     <parametric> deverá ir seguida por duas expressões <expr_x> e
     <expr_y>, e um intervalo <intervalo_t> da forma `[<param>, <min>,
     <max>]'. As duas expressões deverão depender unicamente no
     parâmetro <param>, e o gráfico mostrará o percurso seguido pelo
     ponto com coordenadas (<expr_x>, <expr_y>) à medida que <param>
     aumenta desde <min> até <max>.

     O intervalo de valores no eixo vertical não é obrigatório. É mais
     uma das opções do comando, com a sintaxe: `[y, <min>, <max>]'. Se
     essa opção for usada, o gráfico apresentará esse intervalo
     completo, inclusivamente quando as expressões não cheguem a
     atingir esses valores. De outra forma, se não for indicado um
     intervalo no eixo vertical por meio de `set_plot_option', as
     fronteiras do eixo vertical serão seleccionadas automaticamente.

     Todas as outras opções deverão ser listas, a começar pelo nome da
     opção. A opção <xlabel> pode ser usada para dar um texto que
     identificará o eixo horizontal; se essa opção não for usada, o
     eixo será identificado com o nome da variável indicada em
     <intervalo_x>, ou com a expressão <expr_x>, se houver unicamente
     uma expressão paramétrica, ou caso contrário ficará em branco.

     O texto para identificar o eixo vertical pode ser indicado com a
     opção <ylabel>. Se só houver uma única expressão a ser
     representada, e a opção <ylabel> não tiver sido usada, o eixo
     vertical será identificado com essa expressão, a menos que for
     muito comprido, ou com a expressão <expr_y>, se a expressão for
     paramétrica, ou com o texto "discrete data" se a expressão for
     discreta.

     As opções <logx> e <logy> não precisam de quaisquer paraâmetros.
     Fazem com que os eixos horizontal e vertical sejam apresentados em
     forma logarítmica.

     Se houver vá rias expressões a serem representadas, será escrita
     uma legenda para identificar cada uma dessas expressões. O texto
     que deverá ser usado nessa legenda pode ser indicado por meio da
     opção <legend>. Se essa opção não for usada, Maxima criará textos
     para identificar cada expressão.

     Por omissão, as expressões dadas serão representadas por pequenos
     segmentos de recta a ligarem pontos adjacentes num conjunto de
     pontos que, ou é dado usando a forma <discrete>, ou é calculado
     automaticamente a partir das expressões dadas, por meio de um
     algoritmo com ajuste automático dos intervalos entre pontos, usando
     como estimativa inicial do número de pontos o valor indicado pela
     opção <nticks>. A opção <style> serve para fazer com que alguma
     das expressões seja representada por pontos isolados ou por pontos
     mais segmentos de recta.

     Existem várias opções globais, armazenadas na lista
     <plot_options>, quu podem ser modificadas usando a função
     `set_plot_option'; qualquer uma dessad opções pode ser contrariada
     pelos valores locais dados no comando <plot2d>.

     Uma função a ser representada poderá ser identificada pelo nome de
     uma função ou operador do Maxima ou do Lisp, por meio duma
     expressão lambda do Maxima, ou como uma expressão geral do Maxima.
     Se for especificada como um nome ou como expressão lambda, a
     respectiva função deverá depender dum único argumento.

     Exemplos:

     Gráficos de funções ordinárias.

          (%i1) plot2d (sin(x), [x, -5, 5])$

          (%i2) plot2d (sec(x), [x, -2, 2], [y, -20, 20], [nticks, 200])$

     Gráfico de funções identificadas pelo seu nome.

          (%i3) F(x) := x^2 $

          (%i4) :lisp (defun |$g| (x) (m* x x x))

          $g
          (%i5) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $

          (%i6) plot2d (F, [u, -1, 1])$

          (%i7) plot2d ([F, G, H], [u, -1, 1], [y, -1.5, 1.5])$

     Podemos representar um círculo por meio de um gráfico paramétrico
     com um parâmetro <t>. No caso dos gráficos paramétricos não é
     necessário indicar o intervalo da variável na horizontal, já que o
     intervalo do parâmetro <t> determina o domínio. No entanto, como
     os gráficos são representados numa proporção de 4 para 3 entre os
     eixos horizontal e vertical, usaremos a opção <xrange> para obter
     a mesma escala nos dois eixos:

          (%i8) plot2d ([parametric, cos(t), sin(t), [t,-%pi,%pi], [nticks,80]],
                     [x, -4/3, 4/3])$

     Se repetirmos esse gráfico com apenas 8 pontos e etndendo o
     intevalo do parâmetro para que faça duas voltas, obteremos um
     desenho de uma estrela:

          (%i9) plot2d ([parametric, cos(t), sin(t), [t, -%pi*2, %pi*2],
                  [nticks, 8]], [x, -2, 2], [y, -1.5, 1.5])$

     Combinação dum gráfico ordinário de um polinómio cúbico com o
     gráfico paramétrico de um cí:

          (%i10) plot2d ([x^3+2, [parametric, cos(t), sin(t), [t, -5, 5],
                  [nticks, 80]]], [x, -3, 3])$

     Para mostrar alguns exemplos de gráficos discretos, começaremos
     por introduzir as coordenadas de 5 pontos, usando os dois métodos
     que podem ser usados:

          (%i12) xx:[10, 20, 30, 40, 50]$
          (%i13) yy:[.6, .9, 1.1, 1.3, 1.4]$
          (%i14) xy:[[10,.6], [20,.9], [30,1.1], [40,1.3], [50,1.4]]$

     Para apresentar esses pontos, ligados por segmentos de recta,
     usaremos:
          (%i15) plot2d([discrete,xx,yy])$

     A seguir obteremos o gráfico mostrando únicamente os pontos, e
     aproveitando para mostrar o uso do segundo método para indicar as
     coordenadas dos pontos:

          (%i16) plot2d([discrete, xy], [style, points])$

     O gráfico dos pontos dos dados pode ser apresentado junto com o
     gráfico de uma função teórica que explica esses resultados:

          (%i17) plot2d([[discrete,xy], 2*%pi*sqrt(l/980)], [l,0,50],
                  [style, [points,3,5], [lines,1,3]], [legend,"experiment","theory"],
                  [xlabel,"pendulum's length (cm)"], [ylabel,"period (s)"])$

     Veja também `plot_options', que descreve as opções das funções
     gráficas e mostra mais exemplos.


 -- Função: xgraph_curves (<lista>)
     Desenha o gráfico da lista de `grupos de pontos' dados em lista,
     usando xgraph. Se o programa externo xgraph não estiver instalado,
     o comando falha.

     Uma lista de grupos de pontos pode ser da forma

          [x0, y0, x1, y1, x2, y2, ...]
     ou
          [[x0, y0], [x1, y1], ...]
     Um grupo de pontos pode também conter símbolos que fornecem
     rótulos ou outra informação.

          xgraph_curves ([pontos1, pontos2, pontos3]);

     desenha o gráfico das três curvas que passam pelos três grupos de
     pontos.

          pt_set: append (["NoLines: True", "LargePixels: true"],
                                    [x0, y0, x1, y1, ...]);

     faz com que o grupo de pontos (e os grupos de pontos que virem a
     seguir) sejam desenhados sem linhas a ligar os pontos, e que sejam
     usados pixels grandes.  Consulte outras opções que podem ser
     usadas, na página de manual do programa xgraph.

          pt_set: append ([concat ("\"", "x^2+y")], [x0, y0, x1, y1, ...]);

     faz com que esse grupo de pontos em particular seja identificado
     com a legenda "x^2+y". As aspas, `"', no início indicam ao
     programa xgraph que se trata de uma legenda.

          pt_set: append ([concat ("TitleText: Dados da Amostra")], [x0, ...])$

     faz com que o título do gráfico seja "Dados da Amostra" e não o
     habitual "Maxima Plot".

     Para fazer um gráfico de barras, com largura de 0.2 unidades,
     mostrando duas possibilidades diferentes dessas barras:
          (%i1) xgraph_curves ([append (["BarGraph: true", "NoLines: true",
                "BarWidth: .2"], create_list ([i - .2, i^2], i, 1, 3)),
                append (["BarGraph: true", "NoLines: true", "BarWidth: .2"],
                create_list ([i + .2, .7*i^2], i, 1, 3))]);

     Esta função usa um ficheiro temporário `xgraph-out'.


 -- Variável de sistema: plot_options
     Os elementos desta lista estabelecem os valores por omissaão para
     as opções usadas na elaboração de gráficos. Se uma opção estiver
     presente numa chamada a `plot2d' ou `plot3d', esse valor terá
     precedência sobre o valor por omissção. De outra forma, será usado
     o valor em `plot_options'. Os valores por omissção das opções
     podem ser modificados usando `set_plot_option'.

     Cada elemento de `plot_options' é uma lista de dois ou mais ítens.
     O primeiro item é o nome de uma opção, e os restantes compreendem
     o valor ou valores atribuídos à opção.  Em alguns casos, o valor
     atribuído é uma lista, que pode compreender muitos itens.

     As opções globais que são reconhecidas por `plot2d' e `plot3d' são
     as seguintes:

        * Opção: `plot_format'

          Determina a interface gráfica que será usada por `plot2d' e
          `plot3d'.

             * Valor por omissão: `gnuplot'

               Gnuplot é o pcote gráfico mais avançado entre os
               disponíveis no Maxima. Será preciso que o pacote externo
               gnuplot esteja instalado.

             * Valor: `mgnuplot'

               Mgnuplot é uma interface Tk para o gnuplot. Vem incluída
               na distribuíção do Maxima. Mgnuplot oferece uma GUI
               rudimentar para o gnuplot, mas tem menos recursos em
               geral que a interface padrão do gnuplot.  Mgnuplot
               precisa que os pacotes externos gnuplot e Tcl/Tk estejam
               instalados.

             * Valor: `openmath'

               Openmath é um programa gráfico escrito em Tcl/Tk. Este
               formato é fornecido pelo pacote Xmaxima, que é
               distribuido com Maxima. Se quiser usar este formato
               instalar o pacote Xmaxima, que funcionará não só a
               partir do próprio Xmaxima mas também a partir da linha
               de comandos de outras GUI para o Maxima.


        * Opção: `run_viewer'

          Controla se será executado ou não o visualizador apropriado
          para o formato do gráfico.

             * Valor por omissão: `true'

               Executa-se o programa visualizador.

             * Valor: `false'

               Não se executa o programa visualizador.

        * Opção: `y'

          O intervalo vertical do gráfico.

          Exemplo:
               [y, - 3, 3]
          Faz com que o intervalo vertical seja [-3, 3].

        * Opção: `plot_realpart'

          Quando `plot_realpart' for `true', nos pontos onde o valor a
          ser representado no eixo vertical for complexo, será
          apresentada a sua parte real <x>; isso é equivalente a mostrar
          `realpart(<x>)' em lugar de <x>. De outra forma, somente
          valores com a parte imaginária igual a 0 são mostrados no
          gráfico, e os valores complexos serão ignorados.

          Exemplo:
               plot2d (log(x), [x, -5, 5], [plot_realpart, false]);
               plot2d (log(x), [x, -5, 5], [plot_realpart, true]);
          O valor por omissão é `false'.

        * Opção: `nticks'

          No plot2d, é o número de pontos usados, inicialmente, pela
          rotina gráfica adaptativa. É também o número de pontos que
          serão apresentados num gráfico paramétrico.

          Exemplo:
               [nticks, 20]
          O valor por omissão para `nticks' é 10.

        * Opção: `adapt_depth'

          O número maximo de subdivisões usadas pela rotina gráfica
          adaptativa.

          Exemplo:
               [adapt_depth, 5]
          O valor por omissão para `adapt_depth' é 10.

        * Opção: `xlabel'

          O texto que identifica o eixo horizontal num gráfico a 2d.

          Exemplo:
               [xlabel, "Tempo em segundos"]

        * Opção: `ylabel'

          O texto que identifica o eixo vertical num gráfico a 2d.

          Exemplo:
               [ylabel, "Temperatura"]

        * Opção: `logx'

          Faz com que o eixo horizontal num gráfico a 2d seja
          representado em escala logarítmica. Não precisa de nenhum
          parâmetro adicional.

        * Opção: `logy'

          Faz com que o eixo vertical num gráfico a 2d seja
          representado em escala logarítmica. Não precisa de nenhum
          parâmetro adicional.

        * Opção: `legend'

          Os textos para identificar as diversas expressões num gráfico
          a 2d com muitas expressões. Se existirem mais expressões do
          que os textos dados, serão repetidos. Por omissão, seraão
          usados os nomes das expressões ou das funções, ou as palavras
          discrete1, discrete2, ..., no caso de conjuntos discretos de
          pontos.

          Exemplo:
               [legend, "Grupo 1", "Grupo 2", "Grupo 3"]

        * Opção: `style'

          Os estilos que serão usados para as diversas funções ou
          conjuntos discretos de pontos, num gráfico a 2d. A palavra
          <style> deverá ir seguida por um ou mais estilos. Se houver
          mais funções e conjuntos de dados do que os estilos
          definidos, serão repetidos estilos. Cada estilo poderá ser
          <lines> para segmentos de recta, <points> para pontos
          isolados, <linespoints> para segmentos e pontos, ou <dots>
          para pequenos pontos isolados. O Gnuplot também aceita o
          estilo <impulses>.

          Cada um dos estilos poderá ser incorporado numa lista,
          seguido de alguns parâmetros adicionais. <lines> admite um ou
          dois números: a largura da linha e um inteiro que identifica
          uma cor. <points> admite um ou dois números; o primeiro
          número é o raio dos pontos, e o segundo número é um inteiro
          que no Gnuplot permite seleccionar diferentes formas e cores
          para os pontos e no Openmath muda a cor dos pontos usados.
          <linesdots> admite até quatro números; os dois primeiros são
          os mesmos do que para <lines> e os dois últimos são os mesmos
          do que para <points>.

          Exemplo:
               [style,[lines,2,3],[points,1,4]]

          No Gnuplot, isso faz com que a primeira (e terceira, quinta,
          etc) expressão seja apresentada com segmentos de recta azuis
          de largura 2, e a segunda (quarta, sexta, etc) expressão com
          quadrados verdes de tamanho 1. No Openmath, a primeira
          expressão será apresentada com rectas magenta de largura 2, e
          a segunda com pontos laranja de raio 1; repare que
          openmath_color(3) e openmath_color(4) produzem "magenta" e
          "orange".

          O estilo por omissão é segmentos de recta, com largura 1, e
          com diferentes cores.

        * Opção: `grid'

          Define o número de pontos nas direções x e y, na grelha usada
          nos gráficos tridimensionais.

          Exemplo:
               [grid, 50, 50]
          Define uma grelha de 50 por 50 pontos. A grelha padrão é 30
          por 30.

        * Opção: `transform_xy'

          Permite a aplicação de transformações nos gráficos
          tridimensionais.

          Exemplo:
               [transform_xy, false]
          O valor por omiss~ao de `transform_xy' é `false'. Se não for
          `false', deverá ser o resultado produzido por

               make_transform ([x, y, z], f1(x, y, z), f2(x, y, z), f3(x, y, z))$
          A transformação `polar_xy' está previamente definida no
          Maxima. É igual ao resultado da transformação
               make_transform ([r, th, z], r*cos(th), r*sin(th), z)$

     Opções do Gnuplot:

     Existem muitas opções específicas para o Gnuplot. Muitas dessas
     opções são comandos próprios do Gnuplot, especificados como
     sequências de caracteres. Consulte a documentação do gnuplot para
     mais pormenores.

        * `gnuplot_term'

          Define o tipo terminal de saída para gnuplot.
             * Valor por omissão: `default'

               A saída do Gnuplot é mostrada em uma janela gráfica
               separada.

             * Valor: `dumb'

               A saída do Gnuplot é mostrada na consola do Maxima,
               usando uma aproximação "arte ASCII" para gráficos.

             * Valor: `ps'

               Gnuplot gera comandos na linguagem PostScript de
               descrição de páginas.  Se à opção `gnuplot_out_file'
               tiver sido dada o nome de um ficheiro, gnuplot escreverá
               os comandos PostScript nesse ficheiro.  De outra forma,
               os comandos PostScript serão gravados no ficheiro
               `maxplot.ps'.

             * Valor: qualquer outro tipo de terminal aceite pelo
               gnuplot

               Gnuplot pode produzir gráficos em muitos outros formatos
               gráficos tais como png, jpeg, svg, etc. Para criar
               gráficos em algum desses deverá dar-se a `gnuplot_term'
               um (símbolo) suportado pelo gnuplot ou uma especificação
               completa de terminal do gnuplot com opções válidas
               (sequência de caracteres).  Por exemplo
               `[gnuplot_term,png]' cria gráficos no formato PNG
               (Portable Network Graphics) enquanto `[gnuplot_term,"png
               size 1000,1000"]' cria gráficos no formato PNG com
               tamanho de 1000x1000 pixels. Se à opção
               `gnuplot_out_file' for dado o nome de um ficheiro,
               gnuplot gravará o graáfico nesse ficheiro. De outra
               forma, o gráfico é gravado no ficheiro `maxplot.<term>',
               onde <term> é o nome do terminal do gnuplot.


        * Opção: `gnuplot_out_file'

          Grava o gráfico criado por gnuplot para um ficheiro.

             * Valor por omissão: `false'

               Nenhum ficheiro de saída especificado.

             * Valor: <filename>

               Exemplo: `[gnuplot_out_file, "myplot.ps"]' Quando usada
               em conjunto com o terminal PostScript do gnuplot, neste
               exemplo o gráfico será gravado em formato PostScript no
               ficheiro `myplot.ps', .

        * Opção: `gnuplot_pm3d'

          Controla o uso do modo PM3D, que possui recursos avançados em
          3D. O modo PM3D está somente disponível nas versões de
          gnuplot posteriores a 3.7. O valor padrão para `gnuplot_pm3d'
          é `false'.

          Exemplo:
               [gnuplot_pm3d, true]

        * Opção: `gnuplot_preamble'

          Insere comandos antes que o gráfico seja desenhado. Quaisquer
          comandos válidos para o gnuplot podem ser usados. Multiplos
          comandos podem ser separados com um ponto e vírgula. O
          exemplo mostrado produz uma escala logarítmica no gráfico. O
          valor padrão para `gnuplot_preamble' é uma sequência de
          caracteres vazia `""'.

          Exemplo:
               [gnuplot_preamble, "set log y"]

        * Opção: `gnuplot_curve_titles'

          Controla os títulos dados na legenda do gráfico. O valor
          padrão é `[default]', que escolhe automaticamente um título
          para função cujo gráfico está a ser desenhado. Se não for
          igual a `[default]', `gnuplot_curve_titles' poderá conter uma
          lista de sequências de caracteres, cada uma das quais é
          `"title '<nome>'"'.  (Para desabilitar a legenda do gráfico,
          adicione `"set nokey"' a `gnuplot_preamble'.)

          Exemplo:
               [gnuplot_curve_titles,
               ["title 'Minha primeira função'", "title 'Minha segunda função'"]]

        * Opção: `gnuplot_curve_styles'

          Uma lista de sequências de caracteres a ser enviada para o
          gnuplot para controlar a aparência das curvas, nomeadamente,
          cor, largura, brilho, etc.  O valor padrão é `["with lines
          3", "with lines 1", "with lines 2", "with lines 5", "with
          lines 4", "with lines 6", "with lines 7"]', que circula
          através de diferentes cores. Consulte a documentação de
          `plot' no manual do gnuplot para mais informações.

          Exemplo:
               [gnuplot_curve_styles, ["with lines 7", "with lines 2"]]

        * Opção: `gnuplot_default_term_command'

          O comando do Gnuplot para escolher o tipo de terminal
          gráfico. O valor padrão é a sequência de caracteres vazia
          `""', nomeadamente, usar-se-á o formato padrão do gnuplot.

          Exemplo:
               [gnuplot_default_term_command, "set term x11"]

        * Opção: `gnuplot_dumb_term_command'

          O comando gnuplot para escolher o tipo de terminal não
          gráfico. O valor padrão é `"set term dumb 79 22"', que produz
          saída em texto com 79 por 22 caracteres.

          Exemplo:
               [gnuplot_dumb_term_command, "set term dumb 132 50"]

        * Opção: `gnuplot_ps_term_command'

          O comando gnuplot para escolher o tipo de terminal para o
          terminal PostScript. O valor padrão é `"set size 1.5, 1.5;set
          term postscript eps enhanced color solid 24"', que escolhe o
          tamanho para 1.5 vezes o padrão do gnuplot, e o tamanho da
          fonte para 24, além de outras coisas. Para mais informação,
          consulte a documentação de `set term postscript' no manual do
          gnuplot.

          Exemplo:

          Toda as figuras nos exemplos para a função <plot2d> neste
          manual forma obtidas a partir de ficheiros Postscript que
          foram produzidos após ter mudado `gnuplot_ps_term_command'
          par:

               [gnuplot_ps_term_command,
               "set size 1.3, 1.3; set term postscript eps color solid lw 2.5 30"]


     Exemplos:

        * Grava um gráfico de `sin(x)' para o ficheiro `sin.eps'.

          (%i1) plot2d (sin(x), [x, 0, 2*%pi], [gnuplot_term, ps],
                                  [gnuplot_out_file, "sin.eps"])$

        * Usa a opção y para eliminar singularidades e a opção
          gnuplot_preamble para colocar a legenda na parte inferior do
          gráfico em lugar de no topo.

          (%i2) plot2d ([gamma(x), 1/gamma(x)], [x, -4.5, 5], [y, -10, 10],
                               [gnuplot_preamble, "set key bottom"])$

        * Usa um `gnuplot_preamble' muito complicado para produzir
          rótulos melhores para o eixo x.  (Repare que a sequência de
          caracteres fornecida a `gnuplot_preamble' não pode ter
          qualquer quebra de linha.)

          (%i3) my_preamble: "set xzeroaxis; set xtics ('-2pi' -6.283, \
          '-3pi/2' -4.712, '-pi' -3.1415, '-pi/2' -1.5708, '0' 0, \
          'pi/2' 1.5708, 'pi' 3.1415,'3pi/2' 4.712, '2pi' 6.283)"$

          (%i4) plot2d([cos(x), sin(x), tan(x), cot(x)],
                 [x, -2*%pi, 2.1*%pi], [y, -2, 2],
                 [gnuplot_preamble, my_preamble]);

        * Usa um `gnuplot_preamble' muito complicado para produzir
          rótulos melhores para o eixo x, e produzir saída PostScript
          que utiliza o formato de texto avançado disponível no
          gnuplot. (Repare que a sequência de caracteres fornecida a
          `gnuplot_preamble' não pode ter qualquer quebra de linha.)

          (%i5) my_preamble: "set xzeroaxis; set xtics ('-2{/Symbol p}' \
          -6.283, '-3{/Symbol p}/2' -4.712, '-{/Symbol p}' -3.1415, \
          '-{/Symbol p}/2' -1.5708, '0' 0,'{/Symbol p}/2' 1.5708, \
          '{/Symbol p}' 3.1415,'3{/Symbol p}/2' 4.712, '2{/Symbol p}' \
          6.283)"$

          (%i6) plot2d ([cos(x), sin(x), tan(x)], [x, -2*%pi, 2*%pi],
              [y, -2, 2], [gnuplot_preamble, my_preamble],
              [gnuplot_term, ps], [gnuplot_out_file, "trig.eps"]);

        * Um gráfico tridimensional usando o terminal pm3d do gnuplot.

          (%i7) plot3d (atan (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
                  [grid, 50, 50], [gnuplot_pm3d, true])$

        * Um gráfico tridimensional sem a gralha e com contornos
          projetados no plano inferior.

          (%i8) my_preamble: "set pm3d at s;unset surface;set contour;\
          set cntrparam levels 20;unset key"$
          (%i9) plot3d(atan(-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [grid, 50, 50], [gnuplot_pm3d, true],
              [gnuplot_preamble, my_preamble])$

        * Um gráfico onde o eixo z é representado apenas por cores.
          (Note que a sequência de caracteres fornecida a
          `gnuplot_preamble' não pode ter qualquer quebra de linha.)

          (%i10) plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [gnuplot_preamble, "set view map; unset surface"],
              [gnuplot_pm3d, true], [grid, 150, 150])$


 -- Função: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_range>,
          <y_range>, ..., <opções>, ...)
 -- Função: plot3d (<expr>, <x_range>, <y_range>, ..., <opções>, ...)
 -- Função: plot3d (<name>, <x_range>, <y_range>, ..., <opções>, ...)
 -- Função: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_rge>, <y_rge>)
 -- Função: plot3d ([<nome_1>, <nome_2>, <nome_3>], <x_range>,
          <y_range>, ..., <opções>, ...)
     Mostra o gráfico de uma ou três expressões como funções de duas
     variáveis.

          (%i1) plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -7, 7]);

     desenha o gráfico de `z = 2^(-u^2+v^2)' com `u' e `v' a variar nos
     intervalos fechados [-3,3] e [-2,2], respectivamente, e com <u>
     sobre o eixo x, e `v' sobre o eixo y.

     O mesmo gráfico pode ser visualizado usando openmath (se Xmaxima
     estiver instalado):

          (%i2)  plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2],
                         [plot_format, openmath]);

     neste caso o rato pode ser usado para rodar a superfície,
     mostrando o seu aspecto desde diferentes pontos de observação.

     Um exemplo do terceiro modelo de argumento é

          (%i3) plot3d ([cos(x)*(3 + y*cos(x/2)), sin(x)*(3 + y*cos(x/2)),
             y*sin(x/2)], [x, -%pi, %pi], [y, -1, 1], ['grid, 50, 15]);

     que desenha o gráfico da fita de Moebius, parametrizada por três
     expressões fornecidas como o primeiro argumento para `plot3d'.  Um
     argumento adicional e opcional `['grid, 50, 15]' define o número
     de rectâgulos da grelha nas direções x e y.

     A função a ser representada graficamente pode ser especificada
     como o nome de uma função ou operador, do Maxima ou do Lisp, como
     uma expressão lambda do Maxima, ou como uma expressão geral do
     Maxima. Se especificada como um nome ou como expressão lambda, a
     função deve ser uma função de um argumento.

     O exemplo seguinte mostra o gráfico da parte real de `z^1/3'.

          (%i4) plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
                ['grid, 12, 80], ['transform_xy, polar_to_xy]);

     Outros exemplos são uma superfície de Klein:

          (%i5) expr_1: 5*cos(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y)
                + 3.0) - 10.0$
          (%i6) expr_2: -5*sin(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y)
                + 3.0)$
          (%i7) expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y))$

          (%i8) plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi],
                [y, -%pi, %pi], ['grid, 40, 40]);

     e um toro

          +(%i9) expr_1: cos(y)*(10.0+6*cos(x))$
          +(%i10) expr_2: sin(y)*(10.0+6*cos(x))$
          +(%i11) expr_3: -6*sin(x)$
          +(%i12) plot3d ([expr_1, expr_2, expr_3], [x, 0, 2*%pi],       [y, 0, 2*%pi], ['grid, 40, 40]);

     Algumas vezes será necessário definir uma função para desenhar o
     gráfico da expressão. Todos os argumentos para plot3d são
     avaliados antes de serem passados para plot3d; assim, pode ser
     difi,cil escrever uma expressão que faza apenas o que for preciso;
     será mais fácil criar uma função.

          (%i13) M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4],
                 [1, 2, 3, 3])$
          (%i14) f(x, y) := float (M [?round(x), ?round(y)])$
          (%i15) plot3d (f, [x, 1, 4], [y, 1, 4], ['grid, 4, 4])$

     Veja `plot_options' para mais exemplos.


 -- Função: make_transform (<vars>, <fx>, <fy>, <fz>)
     Produz uma função adequada para a função transformação em plot3d.
     Usa-se conjuntamente com a opção gráfica `transform_xy'.
          make_transform ([r, th, z], r*cos(th), r*sin(th), z)$
     é uma transformação para coordenadas polares.

 -- Função: set_plot_option (<opção>)
     Atribui valores às opções globais para impressão.  <opção> é
     especificada como uma lista de dois ou mais elementos, na qual o
     primeiro elemeto é uma das palavras chave dentro da lista
     `plot_options'.

     O argumento dado a `set_plot_option' é avaliado e
     `set_plot_option' retorna a lista completa `plot_options' (após
     modificar um desses elementos).

     Veja também `plot_options', `plot2d' e `plot3d'.

     Exemplos:

     Modifica a gralha (`grid') e o intervalo de `x'.  Quando uma
     palavra chave em `plot_options' tiver um valor atribuído, colocar
     um apóstrofo evita que seja avaliado.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[x, - 1.755559702014E+305, 1.755559702014E+305],
          [y, - 1.755559702014E+305, 1.755559702014E+305], [t, - 3, 3],
          [grid, 30, 40], [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]
          (%i2) x: 42;
          (%o2)                          42
          (%i3) set_plot_option (['x, -100, 100]);
          (%o3) [[x, - 100.0, 100.0], [y, - 1.755559702014E+305,
          1.755559702014E+305], [t, - 3, 3], [grid, 30, 40],
          [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]



File: maxima.info,  Node: Entrada e Saída,  Next: Ponto Flutuante,  Prev: Criação de Gráficos,  Up: Top

9 Entrada e Saída
*****************

* Menu:

* Comentários::
* Ficheiros::
* Definições para Entrada e Saída::


File: maxima.info,  Node: Comentários,  Next: Ficheiros,  Prev: Entrada e Saída,  Up: Entrada e Saída

9.1 Comentários
===============

Um comentário na entrada do Maxima é qualquer texto entre `/*' e `*/'.

   O analisador do Maxima trata um comentário como espação em branco
para o propósito de encontrar indicações no fluxo de entrada; uma
indicação sempre termina um comentário.  Uma entrada tal como `a/* foo
*/b' contém duas indicações, `a' e `b', e não uma indicação simples
`ab'.  Comentários são de outra Comments are otherwise ignored by
Maxima; nem o conteúdo nem a localização dos comentários são
armazenados pelo analisador de expressões de entrada.

   Comentários podem ser aninhados de forma a terem um nível de
estratificação arbitrario.  O delimitador `/*' e o delimitador `*/'
formam pares.  A quantidade de `/*' deve ser a mesma quantidade de `*/'.

   Exemplos:

     (%i1) /* aa is a variable of interest */  aa : 1234;
     (%o1)                         1234
     (%i2) /* Value of bb depends on aa */  bb : aa^2;
     (%o2)                        1522756
     (%i3) /* User-defined infix operator */  infix ("b");
     (%o3)                           b
     (%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
     (%o4)                         a b c
     (%i5) /* Comments /* can be nested /* to arbitrary depth */ */ */  1 + xyz;
     (%o5)                        xyz + 1


File: maxima.info,  Node: Ficheiros,  Next: Definições para Entrada e Saída,  Prev: Comentários,  Up: Entrada e Saída

9.2 Ficheiros
=============

Um ficheiro é simplesmente uma área sobre um dispositivo particular de
armazenagem que contém dados ou texto.  Ficheiros em disco são
figurativamente agrupados dentro de "directórios".  Um directório é
apenas uma lista de ficheiros.  Comandos que lidam com ficheiros são:
`save', `load', `loadfile', `stringout', `batch', `demo', `writefile',
`closefile', e `appendfile'.



Local Variables:
coding: iso-8859-1
End:
