This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Esse é um Manual do Maxima no formato Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Funções e Variáveis Definidas para Teoria dos Números,  Prev: Teoria dos Números,  Up: Teoria dos Números

31.1 Funções e Variáveis Definidas para Teoria dos Números
==========================================================

 -- Função: bern (<n>)
     Retorna o <n>'ésimo número de Bernoulli para o inteiro <n>.
     Números de Bernoulli iguais a zero são suprimidos se `zerobern'
     for `false'.

     Veja também `burn'.

          (%i1) zerobern: true$
          (%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                            1  1       1      1        1
          (%o2)       [1, - -, -, 0, - --, 0, --, 0, - --]
                            2  6       30     42       30
          (%i3) zerobern: false$
          (%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                      1  1    1   5     691   7    3617  43867
          (%o4) [1, - -, -, - --, --, - ----, -, - ----, -----]
                      2  6    30  66    2730  6    510    798


 -- Função: bernpoly (<x>, <n>)
     Retorna o <n>'ésimo polinômio de Bernoulli na variável <x>.


 -- Função: bfzeta (<s>, <n>)
     Retorna a função zeta de Riemann para o argumento <s>.  O valor de
     retorno é um grande inteiro em ponto flutuante (bfloat); <n> é o
     número de dígitos no valor de retorno.

     `load ("bffac")' chama essa função.


 -- Função: bfhzeta (<s>, <h>, <n>)
     Retorna a função zeta de Hurwitz para os argumentos <s> e <h>.  O
     valor de retorno é um grande inteiro em ponto flutuante (bfloat);
     <n> é o números de dígitos no valor de retorno.

     A função zeta de Hurwitz é definida como

          sum ((k+h)^-s, k, 0, inf)

     `load ("bffac")' chama essa função.


 -- Função: binomial (<x>, <y>)
     O coeficiente binomial `<x>!/(<y>! (<x> - <y>)!)'.  Se <x> e <y>
     forem inteiros, então o valor numérico do coeficiente binomial é
     calculado.  Se <y>, ou <x - y>, for um inteiro, o the coeficiente
     binomial é expresso como um polinômio.

     Exemplos:

          (%i1) binomial (11, 7);
          (%o1)                          330
          (%i2) 11! / 7! / (11 - 7)!;
          (%o2)                          330
          (%i3) binomial (x, 7);
                  (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
          (%o3)   -------------------------------------------------
                                        5040
          (%i4) binomial (x + 7, x);
                (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
          (%o4) -------------------------------------------------------
                                         5040
          (%i5) binomial (11, y);
          (%o5)                    binomial(11, y)


 -- Função: burn (<n>)
     Retorna o <n>'ésimo número de Bernoulli para o inteiro <n>.
     `burn' pode ser mais eficitente que `bern' para valores grandes e
     isolados de <n> (talvez <n> maior que 105 ou algo parecido), como
     `bern' calcula todos os números de Bernoulli até o índice <n>
     antes de retornar.

     `burn' explora a observação que números de Bernoulli (racionais)
     podem ser aproximados através de zetas (transcendentes) com
     eficiência tolerável.

     `load ("bffac")' chama essa função.


 -- Função: cf (<expr>)
     Converte <expr> em uma fração contínua.  <expr> é uma expressão
     compreendendo frações contínuas e raízes quadradas de inteiros.
     Operandos na expressão podem ser combinados com operadores
     aritméticos.  Com excessão de frações contínuas e raízes quadradas,
     fatores na expressão devem ser números inteiros ou racionais.
     Maxima não conhece operações sobre frações contínuas fora de `cf'.

     `cf' avalia seus argumentos após associar `listarith' a `false'.
     `cf' retorna uma fração contínua, representada como uma lista.

     Uma fração contínua `a + 1/(b + 1/(c + ...))' é representada
     através da lista `[a, b, c, ...]'.  Os elementos da lista `a',
     `b', `c', ... devem avaliar para inteiros.  <expr> pode também
     conter `sqrt (n)' onde `n' é um inteiro.  Nesse caso `cf'
     fornecerá tantos termos de fração contínua quantos forem o valor
     da variável `cflength' vezes o período.

     Uma fração contínua pode ser avaliada para um número através de
     avaliação da representação aritmética retornada por `cfdisrep'.
     Veja também `cfexpand' para outro caminho para avaliar uma
     fração contínua.

     Veja também `cfdisrep', `cfexpand', e `cflength'.

     Exemplos:

        * <expr> é uma expressão compreendendo frações contínuas e
          raízes quadradas de inteiros.

               (%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
               (%o1)               [59, 17, 2, 1, 1, 1, 27]
               (%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
               (%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]

        * `cflength' controla quantos períodos de fração contínua são
          computados para números algébricos, números irracionais.

               (%i1) cflength: 1$
               (%i2) cf ((1 + sqrt(5))/2);
               (%o2)                    [1, 1, 1, 1, 2]
               (%i3) cflength: 2$
               (%i4) cf ((1 + sqrt(5))/2);
               (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
               (%i5) cflength: 3$
               (%i6) cf ((1 + sqrt(5))/2);
               (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

        * Um fração contínua pode ser avaliado através da avaliação da
          representação aritmética retornada por `cfdisrep'.

               (%i1) cflength: 3$
               (%i2) cfdisrep (cf (sqrt (3)))$
               (%i3) ev (%, numer);
               (%o3)                   1.731707317073171

        * Maxima não conhece operações sobre frações contínuas fora de
          `cf'.

               (%i1) cf ([1,1,1,1,1,2] * 3);
               (%o1)                     [4, 1, 5, 2]
               (%i2) cf ([1,1,1,1,1,2]) * 3;
               (%o2)                  [3, 3, 3, 3, 3, 6]


 -- Função: cfdisrep (<list>)
     Constrói e retorna uma expressão aritmética comum da forma `a +
     1/(b + 1/(c + ...))' a partir da representação lista de uma
     fração contínua `[a, b, c, ...]'.

          (%i1) cf ([1, 2, -3] + [1, -2, 1]);
          (%o1)                     [1, 1, 1, 2]
          (%i2) cfdisrep (%);
                                            1
          (%o2)                     1 + ---------
                                              1
                                        1 + -----
                                                1
                                            1 + -
                                                2


 -- Função: cfexpand (<x>)
     Retorna uma matriz de numeradores e denominadores dos último
     (columa 1) e penúltimo (columa 2) convergentes da fração contínua
     <x>.

          (%i1) cf (rat (ev (%pi, numer)));

          `rat' replaced 3.141592653589793 by 103993/33102 = 3.141592653011902
          (%o1)                  [3, 7, 15, 1, 292]
          (%i2) cfexpand (%);
                                   [ 103993  355 ]
          (%o2)                    [             ]
                                   [ 33102   113 ]
          (%i3) %[1,1]/%[2,1], numer;
          (%o3)                   3.141592653011902


 -- Variável de opção: cflength
     Valor padrão: 1

     `cflength' controla o número de termos da fração contínua que a
     função `cf' fornecerá, como o valor de `cflength' vezes o período.
     Dessa forma o padrão é fornecer um período.

          (%i1) cflength: 1$
          (%i2) cf ((1 + sqrt(5))/2);
          (%o2)                    [1, 1, 1, 1, 2]
          (%i3) cflength: 2$
          (%i4) cf ((1 + sqrt(5))/2);
          (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
          (%i5) cflength: 3$
          (%i6) cf ((1 + sqrt(5))/2);
          (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]


 -- Função: divsum (<n>, <k>)
 -- Função: divsum (<n>)
     `divsum (<n>, <k>)' retorna a adição dos divisores de <n> elevados
     à <k>'ésima potência.

     `divsum (<n>)' retorna a adição dos divisores de <n>.

          (%i1) divsum (12);
          (%o1)                          28
          (%i2) 1 + 2 + 3 + 4 + 6 + 12;
          (%o2)                          28
          (%i3) divsum (12, 2);
          (%o3)                          210
          (%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
          (%o4)                          210


 -- Função: euler (<n>)
     Retorna o <n>'ésimo número de Euler para o inteiro <n> não
     negativo.

     Para a constante de Euler-Mascheroni, veja `%gamma'.

          (%i1) map (euler, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)    [1, 0, - 1, 0, 5, 0, - 61, 0, 1385, 0, - 50521]


 -- Constante: %gamma
     A constante de Euler-Mascheroni, 0.5772156649015329 ....


 -- Função: factorial (<x>)
     Representa a função fatorial. Maxima trata `factorial (<x>)' da
     mesma forma que `<x>!'.  Veja `!'.


 -- Função: fib (<n>)
     Retorna o <n>'ésimo número de Fibonacci.  `fib(0)' igual a 0 e
     `fib(1)' igual a 1, e `fib (-<n>)' igual a `(-1)^(<n> + 1) *
     fib(<n>)'.

     Após chamar `fib', `prevfib' é iguala `fib (<x> - 1)', o número de
     Fibonacci anterior ao último calculado.

          (%i1) map (fib, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)         [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]


 -- Função: fibtophi (<expr>)
     Expressa números de Fibonacci que aparecem em <expr> em termos da
     constante `%phi', que é `(1 + sqrt(5))/2', aproximadamente
     1.61803399.

     Exemplos:

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0


 -- Função: ifactors (<n>)
     Para um inteiro positivo <n> retorna a fatoração de <n>. Se
     `n=p1^e1..pk^nk' for a decomposição de <n> em fatores primos,
     `ifactors' retorna `[[p1, e1], ... , [pk, ek]]'.

     Os métodos de fatoração usados são divisões triviais por primos
     até 9973, o método rho de Pollard e o método da curva elíptica.

          (%i1) ifactors(51575319651600);
          (%o1)     [[2, 4], [3, 2], [5, 2], [1583, 1], [9050207, 1]]
          (%i2) apply("*", map(lambda([u], u[1]^u[2]), %));
          (%o2)                        51575319651600


 -- Função: inrt (<x>, <n>)
     Retorna a parte inteira da <n>'ésima raíz do valor absoluto de <x>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], inrt (10^a, 3)), l);
          (%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]


 -- Função: inv_mod (<n>, <m>)
     Calcula o  inverso de <n> módulo <m>.  `inv_mod (n,m)' retorna
     `false', se <n> modulo <m> for zero.

          (%i1) inv_mod(3, 41);
          (%o1)                           14
          (%i2) ratsimp(3^-1), modulus=41;
          (%o2)                           14
          (%i3) inv_mod(3, 42);
          (%o3)                          false


 -- Função: jacobi (<p>, <q>)
     Retorna símbolo de Jacobi de <p> e <q>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], jacobi (a, 9)), l);
          (%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]


 -- Função: lcm (<expr_1>, ..., <expr_n>)
     Retorna o menor múltiplo comum entre seus argumentos.  Os
     argumentos podem ser expressões gerais também inteiras.

     `load ("functs")' chama essa função.


 -- Função: minfactorial (<expr>)
     Examina <expr> procurando por ocorrências de dois fatoriais que
     diferem por um inteiro.  `minfactorial' então converte um em um
     polinômio vezes o outro.

          (%i1) n!/(n+2)!;
                                         n!
          (%o1)                       --------
                                      (n + 2)!
          (%i2) minfactorial (%);
                                          1
          (%o2)                    ---------------
                                   (n + 1) (n + 2)


 -- Função: next_prime (<n>)
     Retorna o menor primo maior que <n>.

          (%i1) next_prime(27);
          (%o1)                       29


 -- Função: partfrac (<expr>, <var>)
     Expande a expressão <expr> em frações parciais com relação à
     variável principal <var>.  `partfrac' faz uma decomposição
     completa de fração parcial.  O algorítmo utilizado é baseado no
     fato que os denominadores de uma expansão de fração parcial (os
     fatores do denominador original) são relativamente primos.  Os
     numeradores podem ser escritos como combinação linear dos
     denominadores, e a expansão acontece.

          (%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                                2       2        1
          (%o1)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)
          (%i2) ratsimp (%);
                                           x
          (%o2)                 - -------------------
                                   3      2
                                  x  + 4 x  + 5 x + 2
          (%i3) partfrac (%, x);
                                2       2        1
          (%o3)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)


 -- Função: power_mod (<a>, <n>, <m>)
     Usa um algorítmo modular para calcular `a^n mod m' onde <a> e <n>
     são inteiros e <m> é um inteiro positivo.  Se <n> for negativo,
     `inv_mod' é usada para encontrar o inverso modular.

          (%i1) power_mod(3, 15, 5);
          (%o1)                          2
          (%i2) mod(3^15,5);
          (%o2)                          2
          (%i3) power_mod(2, -1, 5);
          (%o3)                          3
          (%i4) inv_mod(2,5);
          (%o4)                          3


 -- Função: primep (<n>)
     Teste de primalidade. Se `primep (n)' retornar `false', <n> é um
     número compostro e se esse teste retornar `true', <n> é um número
     primo com grande probabilidade.

     Para <n> menor que 341550071728321 uma versão deterministra do
     teste de Miller-Rabin é usada. Se `primep (n)' retornar `true',
     então <n> é um número primo.

     Para <n> maior que 34155071728321 `primep' usa
     `primep_number_of_tests' que é os testes de pseudo-primalidade de
     Miller-Rabin e um teste de pseudo-primalidade de Lucas. A
     probabilidade que <n> irá passar por um teste de Miller-Rabin é
     menor que 1/4. Usando o valor padrão 25 para
     `primep_number_of_tests', a probabilidade de <n> passar no teste
     sendo composto é muito menor que 10^-15.


 -- Variável de opção: primep_number_of_tests
     Valor padrão: 25

     Número de testes de Miller-Rabin usados em `primep'.

 -- Função: prev_prime (<n>)
     Retorna o maior primo menor que <n>.

          (%i1) prev_prime(27);
          (%o1)                       23

 -- Função: qunit (<n>)
     Retorna a principal unidade do campo dos números quadráticos reais
     `sqrt (<n>)' onde <n> é um inteiro, i.e., o elemento cuja norma é
     unidade.  Isso é importante para resolver a equação de Pell `a^2 -
     <n> b^2 = 1'.

          (%i1) qunit (17);
          (%o1)                     sqrt(17) + 4
          (%i2) expand (% * (sqrt(17) - 4));
          (%o2)                           1


 -- Função: totient (<n>)
     Retorna o número de inteiros menores que ou iguais a <n> que são
     relativamente primos com <n>.


 -- Variável de opção: zerobern
     Valor padrão: `true'

     Quando `zerobern' for `false', `bern' exclui os números de
     Bernoulli que forem iguais a zero.  Veja `bern'.


 -- Função: zeta (<n>)
     Retorna a função zeta de Riemann se <x> for um inteiro negativo,
     0, 1, ou número par positivo, e retorna uma forma substantiva
     `zeta (<n>)' para todos os outros argumentos, incluindo não
     inteiros racionais, ponto flutuante, e argumentos complexos.

     Veja também `bfzeta' e `zeta%pi'.

          (%i1) map (zeta, [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]);
                                               2              4
                     1        1     1       %pi            %pi
          (%o1) [0, ---, 0, - --, - -, inf, ----, zeta(3), ----, zeta(5)]
                    120       12    2        6              90


 -- Variável de opção: zeta%pi
     Valor padrão: `true'

     Quando `zeta%pi' for `true', `zeta' retorna uma expressão
     proporcional a `%pi^n' para inteiro par `n'.  De outra forma,
     `zeta' retorna uma forma substantiva `zeta (n)' para inteiro par
     `n'.

          (%i1) zeta%pi: true$
          (%i2) zeta (4);
                                           4
                                        %pi
          (%o2)                         ----
                                         90
          (%i3) zeta%pi: false$
          (%i4) zeta (4);
          (%o4)                        zeta(4)



File: maxima.info,  Node: Simetrias,  Next: Grupos,  Prev: Teoria dos Números,  Up: Top

32 Simetrias
************

* Menu:

* Funções e Variáveis Definidas para Simetrias::


File: maxima.info,  Node: Funções e Variáveis Definidas para Simetrias,  Prev: Simetrias,  Up: Simetrias

32.1 Funções e Variáveis Definidas para Simetrias
=================================================

32.1.1 Mudando a base do sistema de numeração
---------------------------------------------

 -- Função: comp2pui (<n>, <L>)
     implementa a passagem das funções simétricas completamente
     simétricas fornecidas na lista <L> para as funções simétricas
     elementares de 0 a <n>. Se a lista <L> contiver menos que <n+1>
     elementos, será completada com valores formais do tipo <h1>, <h2>,
     etc. Se o primeiro elemento da lista <L> existir, ele é
     interpretado como sendo o tamanho do alfabeto, de outra forma o
     tamanho é escolhido para <n>.

          (%i1) comp2pui (3, [4, g]);
                                  2                    2
          (%o1)    [4, g, 2 h2 - g , 3 h3 - g h2 + g (g  - 2 h2)]


 -- Função: ele2pui (<m>, <L>)
     vai de funções simétricas elementares para as funções completas.
     Similar a `comp2ele' e `comp2pui'.

     Outras funções para mudanças de base: `comp2ele'.


 -- Função: ele2comp (<m>, <L>)
     Vai de funções simétricas elementares para funções completas.
     Similar a `comp2ele' e a `comp2pui'.

     Outras funções para mudanças de base: `comp2ele'.

 -- Função: elem (<ele>, <sym>, <lvar>)
     decompõe o polinômio simétrico <sym>, nas variáveis contidas na
     lista <lvar>, em termos de funções elementares simétricas
     fornecidas na lista <ele>.  Se o primeiro elemento de <ele> for
     fornecido, esse primeiro elemento será o tamanho do alfabeto, de
     outra forma o tamanho será o grau do polinômio <sym>.  Se valores
     forem omitidos na lista <ele>, valores formais do tipo <e1>, <e2>,
     etc. serão adicionados.  O polinômio <sym> pode ser fornecido de
     três diferentes formas: contraída (`elem' pode então ser 1, seu
     valor padrão), particionada (`elem' pode ser 3), ou extendida
     (i.e. o polinômio completo, e `elem' pode então ser 2).  A
     função `pui' é usada então da mesma forma.

     sobre um alfabeto de tamanho 3 com <e1>, a primeira funçào
     elementar simétrica, com valor 7, o polinômio simétrico em 3
     variáveis cuja forma contraída (que aqui depende de duas de suas
     variáveis) é <x^4-2*x*y> decomposto como segue em funções
     elementares simétricas:

          (%i1) elem ([3, 7], x^4 - 2*x*y, [x, y]);
          (%o1) 7 (e3 - 7 e2 + 7 (49 - e2)) + 21 e3

                                                   + (- 2 (49 - e2) - 2) e2
          (%i2) ratsimp (%);
                                        2
          (%o2)             28 e3 + 2 e2  - 198 e2 + 2401

     Outras funções para mudanças de base: `comp2ele'.


 -- Function: mon2schur (<L>)
     a lsita <L> representa a função de Schur S_L: temos L = [i_1, i_2,
     ..., i_q], com i_1 <= i_2 <= ... <= i_q.  A função de Schur
     S_[i_1, i_2, ..., i_q] é a menor da matriz infinita h_[i-j], i <=
     1, j <= 1, consistindo das q primeiras linhas e as colunas 1 + i_1,
     +2 + i_2, ..., q + i_q.

     Essa função de Schur pode ser escrita em termos de monômios usando
     `treinat' e `kostka'.  A forma retornada é um polinômio simétrico
     na representação contraída nas variáveis x_1,x_2,\ldots.

          (%i1) mon2schur ([1, 1, 1]);
          (%o1)                       x1 x2 x3
          (%i2) mon2schur ([3]);
                                            2        3
          (%o2)                x1 x2 x3 + x1  x2 + x1
          (%i3) mon2schur ([1, 2]);
                                                2
          (%o3)                  2 x1 x2 x3 + x1  x2

     o qual significa que para 3 variáveis fornece:

             2 x1 x2 x3 + x1^2 x2 + x2^2 x1 + x1^2 x3 + x3^2 x1
              + x2^2 x3 + x3^2 x2
     Outras funções para mudanças de base: `comp2ele'.


 -- Função: multi_elem (<l_elem>, <multi_pc>, <l_var>)
     decompões um polinômio multi-simétrico na forma multi-contraída
     <multi_pc> nos grupos de variáveis contidas na lista de listas
     <l_var> en termos de funções elementares simétricas contidas em
     <l_elem>.

          (%i1) multi_elem ([[2, e1, e2], [2, f1, f2]], a*x + a^2 + x^3, [[x, y], [a, b]]);
                                                            3
          (%o1)         - 2 f2 + f1 (f1 + e1) - 3 e1 e2 + e1
          (%i2) ratsimp (%);
                                   2                       3
          (%o2)         - 2 f2 + f1  + e1 f1 - 3 e1 e2 + e1

     Outras funções para mudanças de base: `comp2ele'.


 -- Função: multi_pui
     é para a função `pui' o que a função `multi_elem' é para a
     função `elem'.

          (%i1) multi_pui ([[2, p1, p2], [2, t1, t2]], a*x + a^2 + x^3, [[x, y], [a, b]]);
                                                      3
                                          3 p1 p2   p1
          (%o1)              t2 + p1 t1 + ------- - ---
                                             2       2


 -- Função: pui (<L>, <sym>, <lvar>)
     decompõe o polinômio simétrico <sym>, nas variáveis na lista
     <lvar>, em termos de funções exponenciais na lista <L>.  Se o
     primeiro elemento de <L> for fornecido, esse primeiro elemento
     será o tamanho do alfabeto, de outra forma o tamanho será o grau
     do polinômio <sym>.  Se valores forem omitidos na lista <L>,
     valores formais do tipo <p1>, <p2> , etc. serão adicionados. O
     polinômio <sym> pode ser fornecido de três diferentes formas:
     contraída (`elem' pode então ser 1, seu valor padrão),
     particionada (`elem' pode ser 3), ou extendida (i.e. o polinômio
     completo, e `elem' pode então ser 2). A função `pui' é usada da
     mesma forma.

          (%i1) pui;
          (%o1)                           1
          (%i2) pui ([3, a, b], u*x*y*z, [x, y, z]);
                                 2
                             a (a  - b) u   (a b - p3) u
          (%o2)              ------------ - ------------
                                  6              3
          (%i3) ratsimp (%);
                                                 3
                                (2 p3 - 3 a b + a ) u
          (%o3)                 ---------------------
                                          6
     Outras funções para mudanças de base: `comp2ele'.


 -- Função: pui2comp (<n>, <lpui>)
     converte a dista das primeiras <n> funções completas (com o
     comprimento em primeiro lugar) em termos de funções exponenciais
     fornecidas na lista <lpui>. se a lista <lpui> for vazia, o
     cardinal é <n>, de outra forma o cardinal será seu primeiro
     elemento (como em `comp2ele' e em `comp2pui').

          (%i1) pui2comp (2, []);
                                                 2
                                          p2 + p1
          (%o1)                   [2, p1, --------]
                                             2
          (%i2) pui2comp (3, [2, a1]);
                                                      2
                                           a1 (p2 + a1 )
                                   2  p3 + ------------- + a1 p2
                            p2 + a1              2
          (%o2)     [2, a1, --------, --------------------------]
                               2                  3
          (%i3) ratsimp (%);
                                      2                     3
                               p2 + a1   2 p3 + 3 a1 p2 + a1
          (%o3)        [2, a1, --------, --------------------]
                                  2               6
     Outras funções para mudanças de base: `comp2ele'.


 -- Função: pui2ele (<n>, <lpui>)
     efetiva a passagem de funções exponenciais para as funções
     elementares simétricas.  Se o sinalizador `pui2ele' for `girard',
     `pui2ele' irá retornar a lista de funções elementares simétricas
     de 1 a <n>, e se o sinalizador for `close', `pui2ele' retornará a
     <n>-ésima função simétrica elementar.

     Outras funções para mudanças de base: `comp2ele'.

 -- Função: puireduc (<n>, <lpui>)
     <lpui> é uma lista cujo primeiro elemento é um inteiro <m>.
     `puireduc' fornece as primeiras <n> funções exponenciais em termos
     das primeiras <m> funções.

          (%i1) puireduc (3, [2]);
                                                   2
                                             p1 (p1  - p2)
          (%o1)          [2, p1, p2, p1 p2 - -------------]
                                                   2
          (%i2) ratsimp (%);
                                                     3
                                         3 p1 p2 - p1
          (%o2)              [2, p1, p2, -------------]
                                               2

 -- Função: schur2comp (<P>, <l_var>)
     <P> é um polinômio nas variáveis da lista <l_var>.  Cada uma
     dessas variáveis represetna uma função simétrica completa.  Na
     lista <l_var> o <i>-ésima função simétrica completa é representada
     através da concatenação da letra `h' com o inteiro <i>: `h<i>'.
     Essa função expressa <P> em termos de funções de Schur.

          (%i1) schur2comp (h1*h2 - h3, [h1, h2, h3]);
          (%o1)                         s
                                         1, 2
          (%i2) schur2comp (a*h3, [h3]);
          (%o2)                         s  a
                                         3

32.1.2 Modificando represetnações
---------------------------------

 -- Função: cont2part (<pc>, <lvar>)
     Retorna o polinômio particionado associado à forma contraída <pc>
     cujas variáveis estão em <lvar>.

          (%i1) pc: 2*a^3*b*x^4*y + x^5;
                                     3    4      5
          (%o1)                   2 a  b x  y + x
          (%i2) cont2part (pc, [x, y]);
                                             3
          (%o2)              [[1, 5, 0], [2 a  b, 4, 1]]

 -- Função: contract (<psym>, <lvar>)
     retorna uma forma contraída (i.e. um monômio de grupo ssimétrico)
     do polinômio <psym> nas variáveis contidas na lista <lvar>.  A
     função `explose' executa a operação inversa.  A função `tcontract'
     testa a simétria do polinômio.

          (%i1) psym: explose (2*a^3*b*x^4*y, [x, y, z]);
                   3      4      3      4      3    4        3    4
          (%o1) 2 a  b y z  + 2 a  b x z  + 2 a  b y  z + 2 a  b x  z

                                                     3      4      3    4
                                                + 2 a  b x y  + 2 a  b x  y
          (%i2) contract (psym, [x, y, z]);
                                        3    4
          (%o2)                      2 a  b x  y

 -- Função: explose (<pc>, <lvar>)
     retorna o polinômio simétrico associado com a forma contraída
     <pc>. A lista <lvar> conté as variáveis.

          (%i1) explose (a*x + 1, [x, y, z]);
          (%o1)                  a z + a y + a x + 1

 -- Função: part2cont (<ppart>, <lvar>)
     vai da forma particionada para a forma contraída de um polinômio
     simétrico.  A forma contraída é convertida com as variáveis em
     <lvar>.

          (%i1) part2cont ([[2*a^3*b, 4, 1]], [x, y]);
                                        3    4
          (%o1)                      2 a  b x  y

 -- Função: partpol (<psym>, <lvar>)
     <psym> é um polinômio simétrico nas variáveis da lista <lvar>.
     Essa função retorna sua represetnação particionada.

          (%i1) partpol (-a*(x + y) + 3*x*y, [x, y]);
          (%o1)               [[3, 1, 1], [- a, 1, 0]]


 -- Função: tcontract (<pol>, <lvar>)
     testa se o polinômio <pol> é simétrico nas variáveis da lista
     <lvar>.  Se for, `tcontract' retorna uma representação contraída
     como o faz a função `contract'.


 -- Função: tpartpol (<pol>, <lvar>)
     testa se o polinômio <pol> é simétrico nas variáveis da lista
     <lvar>.  Se for, `tpartpol' retorna sua represetnação particionada
     como o faz a função `partpol'.


32.1.3 Grupos e órbitas
-----------------------

 -- Função: direct ([<p_1>, ..., <p_n>], <y>, <f>, [<lvar_1>, ...,
          <lvar_n>])
     calcula a imagem direta (see M. Giusti, D. Lazard et A. Valibouze,
     ISSAC 1988, Rome) associada à função <f>, na lista de variáveis
     <lvar_1>, ..., <lvar_n>, e nos polinômios <p_1>, ..., <p_n> na
     variável <y>.  A quantidade de argumetnos que a funçào <f> pode
     receber é importante para o cálculo.  Dessa forma, se a expressão
     para <f> não depende de alguma variável, é inútil incluir essa
     variável, e não incluir essa variável irá também reduzir
     consideravelmente o montante cálculos efetuados.

          (%i1) direct ([z^2  - e1* z + e2, z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]);
                 2
          (%o1) y  - e1 f1 y

                                           2            2             2   2
                            - 4 e2 f2 - (e1  - 2 e2) (f1  - 2 f2) + e1  f1
                          + -----------------------------------------------
                                                   2
          (%i2) ratsimp (%);
                        2                2                   2
          (%o2)        y  - e1 f1 y + (e1  - 4 e2) f2 + e2 f1
          (%i3) ratsimp (direct ([z^3-e1*z^2+e2*z-e3,z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]));
                 6            5         2                        2    2   4
          (%o3) y  - 2 e1 f1 y  + ((2 e1  - 6 e2) f2 + (2 e2 + e1 ) f1 ) y

                                    3                               3   3
           + ((9 e3 + 5 e1 e2 - 2 e1 ) f1 f2 + (- 2 e3 - 2 e1 e2) f1 ) y

                   2       2        4    2
           + ((9 e2  - 6 e1  e2 + e1 ) f2

                              2       2       2                   2    4
           + (- 9 e1 e3 - 6 e2  + 3 e1  e2) f1  f2 + (2 e1 e3 + e2 ) f1 )

            2          2                      2     3          2
           y  + (((9 e1  - 27 e2) e3 + 3 e1 e2  - e1  e2) f1 f2

                           2            2    3                5
           + ((15 e2 - 2 e1 ) e3 - e1 e2 ) f1  f2 - 2 e2 e3 f1 ) y

                     2                   3           3     2   2    3
           + (- 27 e3  + (18 e1 e2 - 4 e1 ) e3 - 4 e2  + e1  e2 ) f2

                   2      3                   3    2   2
           + (27 e3  + (e1  - 9 e1 e2) e3 + e2 ) f1  f2

                             2    4        2   6
           + (e1 e2 e3 - 9 e3 ) f1  f2 + e3  f1

     Encontrando um polinômio cujas raízes são somatórios a+u onde a é
     uma raíz de z^2 - e_1 z + e_2 e u é uma raíz de z^2 - +f_1 z + f_2.

          (%i1) ratsimp (direct ([z^2 - e1* z + e2, z^2 - f1* z + f2],
                                    z, a + u, [[u], [a]]));
                 4                    3             2
          (%o1) y  + (- 2 f1 - 2 e1) y  + (2 f2 + f1  + 3 e1 f1 + 2 e2

               2   2                              2               2
           + e1 ) y  + ((- 2 f1 - 2 e1) f2 - e1 f1  + (- 2 e2 - e1 ) f1

                            2                     2            2
           - 2 e1 e2) y + f2  + (e1 f1 - 2 e2 + e1 ) f2 + e2 f1  + e1 e2 f1

               2
           + e2

     `direct' aceita dois sinalizadores: `elementaires' (elementares) e
     `puissances' (exponenciais - valor padrão) que permitem a
     decomposição de polinômios simétricos que aparecerem nesses
     cálculos em funções simétricas elementares ou em funções
     exponenciais respectivamente.

     Funções de `sym' utilizadas nesta função :

     `multi_orbit' (portanto `orbit'), `pui_direct', `multi_elem'
     (portanto `elem'), `multi_pui' (portanto `pui'), `pui2ele',
     `ele2pui' (se o sinalizador `direct' for escolhido para
     `puissances').


 -- Função: multi_orbit (<P>, [<lvar_1>, <lvar_2>,..., <lvar_p>])
     <P> é um polinômio no conjunto de variáveis contidas nas lista
     <lvar_1>, <lvar_2>, ..., <lvar_p>. Essa função retorna a órbita do
     polinômio <P> sob a ação do produto dos grupos simétricos dos
     conjuntos de variáveis represetnadas nas <p> listas.

          (%i1) multi_orbit (a*x + b*y, [[x, y], [a, b]]);
          (%o1)                [b y + a x, a y + b x]
          (%i2) multi_orbit (x + y + 2*a, [[x, y], [a, b, c]]);
          (%o2)        [y + x + 2 c, y + x + 2 b, y + x + 2 a]
     Veja também: `orbit' para a ação de um grupo simétrico simples.

 -- Função: multsym (<ppart_1>, <ppart_2>, <n>)
     retorna oproduto de dois polinômios simétricos em <n> varieis
     trabalhando somente módulo a ação do grupo simétrico de ordem <n>.
     O polinômios estão em sua forma particionada.

     Dados 2 polinômio simétricos em <x>, <y>:  `3*(x + y) + 2*x*y' e
     `5*(x^2 + y^2)' cujas formas particionadas são `[[3, 1], [2, 1,
     1]]' e `[[5, 2]]', seu produto irá ser

          (%i1) multsym ([[3, 1], [2, 1, 1]], [[5, 2]], 2);
          (%o1)         [[10, 3, 1], [15, 3, 0], [15, 2, 1]]
     isso é `10*(x^3*y + y^3*x) + 15*(x^2*y + y^2*x) + 15*(x^3 + y^3)'.

     Funções para mudar as representacões de um polinômio simétrico:

     `contract', `cont2part', `explose', `part2cont', `partpol',
     `tcontract', `tpartpol'.

 -- Função: orbit (<P>, <lvar>)
     calcula a órbita do polinômio <P> nas variáveis na lista <lvar>
     sob a ação do grupo simétrico do conjunto das variáveis na lista
     <lvar>.

          (%i1) orbit (a*x + b*y, [x, y]);
          (%o1)                [a y + b x, b y + a x]
          (%i2) orbit (2*x + x^2, [x, y]);
                                  2         2
          (%o2)                 [y  + 2 y, x  + 2 x]
     Veja também `multi_orbit' para a ação de um produto de grupos
     simétricos sobre um polinômio.

 -- Função: pui_direct (<orbite>, [<lvar_1>, ..., <lvar_n>], [<d_1>,
          <d_2>, ..., <d_n>])
     Tomemos <f> para ser um polinômio em <n> blocos de variáveis
     <lvar_1>, ..., <lvar_n>.  Façamos <c_i> ser o n;umero de variáveis
     em <lvar_i>, e <SC> ser o produto de <n> grupos simétricos de grau
     <c_1>, ..., <c_n>. Essas ações dos grupos naturalmente sobre <f>.
     A lista <orbite> é a órbita, denotada `<SC>(<f>)', da função <f>
     sob a ação de <SC>. (Essa lista pode ser obtida através da
     função `multi_orbit'.)  Os <di> são inteiros de forma que c_1 \le
     d_1, c_2 \le d_2, \ldots, c_n \le d_n.

     Tomemos <SD> para ser o produto dos grupos simétricos S_[d_1] x
     S_[d_2] x ... x S_[d_n].  A função `pui_direct' retorna as
     primeiras <n> funções exponenciais de `<SD>(<f>)' deduzidas das
     funções exponenciais de `<SC>(<f>)', onde <n> é o tamanho de
     `<SD>(<f>)'.

     O resultado está na multi-forma contraída com relação a <SD>, i.e.
     somente um elemento é mantido por órbita, sob a ação de <SD>.

          (%i1) l: [[x, y], [a, b]];
          (%o1)                   [[x, y], [a, b]]
          (%i2) pui_direct (multi_orbit (a*x + b*y, l), l, [2, 2]);
                                                 2  2
          (%o2)               [a x, 4 a b x y + a  x ]
          (%i3) pui_direct (multi_orbit (a*x + b*y, l), l, [3, 2]);
                                       2  2     2    2        3  3
          (%o3) [2 a x, 4 a b x y + 2 a  x , 3 a  b x  y + 2 a  x ,

              2  2  2  2      3    3        4  4
          12 a  b  x  y  + 4 a  b x  y + 2 a  x ,

              3  2  3  2      4    4        5  5
          10 a  b  x  y  + 5 a  b x  y + 2 a  x ,

              3  3  3  3       4  2  4  2      5    5        6  6
          40 a  b  x  y  + 15 a  b  x  y  + 6 a  b x  y + 2 a  x ]
          (%i4) pui_direct ([y + x + 2*c, y + x + 2*b, y + x + 2*a], [[x, y], [a, b, c]], [2, 3]);
                                       2              2
          (%o4) [3 x + 2 a, 6 x y + 3 x  + 4 a x + 4 a ,

                           2                   3        2       2        3
                        9 x  y + 12 a x y + 3 x  + 6 a x  + 12 a  x + 8 a ]


32.1.4 Partições
----------------

 -- Função: kostka (<part_1>, <part_2>)
     escrita por P. Esperet, calcula o número de Kostka da partição
     <part_1> e <part_2>.

          (%i1) kostka ([3, 3, 3], [2, 2, 2, 1, 1, 1]);
          (%o1)                           6

 -- Função: lgtreillis (<n>, <m>)
     retorna a lista de partições de peso <n> e comprimento <m>.

          (%i1) lgtreillis (4, 2);
          (%o1)                   [[3, 1], [2, 2]]
     Veja também: `ltreillis', `treillis' e `treinat'.

 -- Função: ltreillis (<n>, <m>)
     retorna a lista de partições de peso <n> e comprimento menor que ou
     igual a <m>.

          (%i1) ltreillis (4, 2);
          (%o1)               [[4, 0], [3, 1], [2, 2]]
     Veja também: `lgtreillis', `treillis' e `treinat'.

 -- Função: treillis (<n>)
     retorna todas as partições de peso <n>.

          (%i1) treillis (4);
          (%o1)    [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]

     Veja também: `lgtreillis', `ltreillis' e `treinat'.


 -- Função: treinat (<part>)
     retorna a lista de partições inferiores à partiçào <part> com
     relação à ordem natural.

          (%i1) treinat ([5]);
          (%o1)                         [[5]]
          (%i2) treinat ([1, 1, 1, 1, 1]);
          (%o2) [[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],

                                                           [1, 1, 1, 1, 1]]
          (%i3) treinat ([3, 2]);
          (%o3)                 [[5], [4, 1], [3, 2]]

     Veja também: `lgtreillis', `ltreillis' e `treillis'.


32.1.5 Polinômios e suas raízes
-------------------------------

 -- Função: ele2polynome (<L>, <z>)
     retorna o polinômio em <z> de forma que as funções elementares
     simétricas de suas raízes estejam na lista `<L> = [<n>, <e_1>,
     ..., <e_n>]', onde <n> é o grau dos polinômios e <e_i> é a
     <i>-ésima função simétrica elementar.

          (%i1) ele2polynome ([2, e1, e2], z);
                                    2
          (%o1)                    z  - e1 z + e2
          (%i2) polynome2ele (x^7 - 14*x^5 + 56*x^3  - 56*x + 22, x);
          (%o2)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i3) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o3)            x  - 14 x  + 56 x  - 56 x + 22
     o inverso: `polynome2ele (<P>, <z>)'.

     Veja também: `polynome2ele', `pui2polynome'.

 -- Função: polynome2ele (<P>, <x>)
     fornece a lista `<l> = [<n>, <e_1>, ..., <e_n>]' onde <n> é o grau
     do polinômio <P> na variável <x> e <e_i> é a <i>-ésima função
     simétrica elementar das raízes de <P>.

          (%i1) polynome2ele (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x);
          (%o1)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i2) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o2)            x  - 14 x  + 56 x  - 56 x + 22
     A inversa: `ele2polynome (<l>, <x>)'

 -- Função: prodrac (<L>, <k>)
     <L> é uma lista contendo as funções simétricas elementares sobre
     um conjunto <A>. `prodrac' retorna o polinômio cujas raízes são os
     produtos <k> por <k> dos elementos de <A>.

     Veja também `somrac'.

 -- Função: pui2polynome (<x>, <lpui>)
     calcula o polinômio em <x> cujas funções exponenciais das raízes
     são dadas na lista <lpui>.

          (%i1) pui;
          (%o1)                           1
          (%i2) kill(labels);
          (%o0)                         done
          (%i1) polynome2ele (x^3 - 4*x^2 + 5*x - 1, x);
          (%o1)                     [3, 4, 5, 1]
          (%i2) ele2pui (3, %);
          (%o2)                     [3, 4, 6, 7]
          (%i3) pui2polynome (x, %);
                                  3      2
          (%o3)                  x  - 4 x  + 5 x - 1
     Veja também: `polynome2ele', `ele2polynome'.

 -- Função: somrac (<L>, <k>)
     A lista <L> contains função simétrica elementars de um polynomial
     <P> . The function computes the polinômio whose roots are the <k>
     by <k> distinct sums of the roots of <P>.

     Also see `prodrac'.

32.1.6 Resolvents
-----------------

 -- Função: resolvante (<P>, <x>, <f>, [<x_1>,..., <x_d>])
     calcula a resilvente do polinômio <P> em <x> de grau <n> >= <d>
     através da fFunção <f> expressa nas variáveis <x_1>, ..., <x_d>.
     Para eficiência de computação é importante não incluir na lista as
     variáveis `[<x_1>, ..., <x_d>]' que não aparecem na função de
     transformação <f>.

     Para melhorar a eficiência do cálculo se pode escolher
     sinalizadores em `resolvante' de forma a usar os algorítmos
     apropriados:

     Se a função <f> for unitária :
        * um polinômio em uma variável simples,

        *   linear ,

        *   alternando,

        *   um somatório,

        *   simétrico,

        *   um produto,

        * a função da resolvente de Cayley (utilizável de grau 5 em
          diante)

               (x1*x2 + x2*x3 + x3*x4 + x4*x5 + x5*x1 -
                    (x1*x3 + x3*x5 + x5*x2 + x2*x4 + x4*x1))^2

          geral,
     o sinalizador da `resolvante' poderá ser respectivamente :
        *   unitaire,

        *   lineaire,

        *   alternee,

        *   somme,

        *   produit,

        *   cayley,

        *   generale.

          (%i1) resolvante: unitaire$
          (%i2) resolvante (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x, x^3 - 1, [x]);

          " resolvante unitaire " [7, 0, 28, 0, 168, 0, 1120, - 154, 7840, - 2772, 56448, - 33880,

          413952, - 352352, 3076668, - 3363360, 23114112, - 30494464,

          175230832, - 267412992, 1338886528, - 2292126760]
            3       6      3       9      6      3
          [x  - 1, x  - 2 x  + 1, x  - 3 x  + 3 x  - 1,

           12      9      6      3       15      12       9       6      3
          x   - 4 x  + 6 x  - 4 x  + 1, x   - 5 x   + 10 x  - 10 x  + 5 x

                 18      15       12       9       6      3
           - 1, x   - 6 x   + 15 x   - 20 x  + 15 x  - 6 x  + 1,

           21      18       15       12       9       6      3
          x   - 7 x   + 21 x   - 35 x   + 35 x  - 21 x  + 7 x  - 1]
          [- 7, 1127, - 6139, 431767, - 5472047, 201692519, - 3603982011]
                 7      6        5         4          3           2
          (%o2) y  + 7 y  - 539 y  - 1841 y  + 51443 y  + 315133 y

                                                        + 376999 y + 125253
          (%i3) resolvante: lineaire$
          (%i4) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante lineaire "
                 24       20         16            12             8
          (%o4) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i5) resolvante: general$
          (%i6) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante generale "
                 24       20         16            12             8
          (%o6) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i7) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3, x4]);

          " resolvante generale "
                 24       20         16            12             8
          (%o7) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i8) direct ([x^4 - 1], x, x1 + 2*x2 + 3*x3, [[x1, x2, x3]]);
                 24       20         16            12             8
          (%o8) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i9) resolvante :lineaire$
          (%i10) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante lineaire "
                                        4
          (%o10)                       y  - 1
          (%i11) resolvante: symetrique$
          (%i12) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante symetrique "
                                        4
          (%o12)                       y  - 1
          (%i13) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante symetrique "
                                     6      2
          (%o13)                    y  - 4 y  - 1
          (%i14) resolvante: alternee$
          (%i15) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante alternee "
                      12      8       6        4        2
          (%o15)     y   + 8 y  + 26 y  - 112 y  + 216 y  + 229
          (%i16) resolvante: produit$
          (%i17) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante produit "
                  35      33         29        28         27        26
          (%o17) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i18) resolvante: symetrique$
          (%i19) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante symetrique "
                  35      33         29        28         27        26
          (%o19) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i20) resolvante: cayley$
          (%i21) resolvante (x^5 - 4*x^2 + x + 1, x, a, []);

          " resolvente de Cayley "
                  6       5         4          3            2
          (%o21) x  - 40 x  + 4080 x  - 92928 x  + 3772160 x  + 37880832 x

                                                                 + 93392896

     Para a resolvente de Cayley, os 2 últimos argumentos são neutros e
     o polinômio fornecido na entrada deve ser necessáriamente de grau
     5.

     Veja também :

     `resolvante_bipartite', `resolvante_produit_sym',
     `resolvante_unitaire', `resolvante_alternee1', `resolvante_klein',
     `resolvante_klein3', `resolvante_vierer', `resolvante_diedrale'.


 -- Função: resolvante_alternee1 (<P>, <x>)
     calcula a transformação de `<P>(<x>)' de grau <n> pela função
     $\prod_{1\leq i<j\leq n-1} (x_i-x_j)$.  product(x_i - x_j, 1 <= i
     < j <= n - 1).

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire', `resolvante' ,
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale', `resolvante_bipartite'.


 -- Função: resolvante_bipartite (<P>, <x>)
     calcula a trasformação de `<P>(<x>)' de mesmo grau <n> através da
     função x_1 x_2 ... x_[n/2] + x_[n/2 + 1] ... x_n.

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire', `resolvante' ,
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale', `resolvante_alternee1'.

          (%i1) resolvante_bipartite (x^6 + 108, x);
                        10        8           6             4
          (%o1)        y   - 972 y  + 314928 y  - 34012224 y

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire', `resolvante',
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale', `resolvante_alternee1'.


 -- Função: resolvante_diedrale (<P>, <x>)
     calcula a transformação de `<P>(<x>)' através da função `<x_1>
     <x_2> + <x_3> <x_4>'.

          (%i1) resolvante_diedrale (x^5 - 3*x^4 + 1, x);
                 15       12       11       10        9         8         7
          (%o1) x   - 21 x   - 81 x   - 21 x   + 207 x  + 1134 x  + 2331 x

                  6         5          4          3          2
           - 945 x  - 4970 x  - 18333 x  - 29079 x  - 20745 x  - 25326 x

           - 697

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante_klein3',
     `resolvante_vierer', `resolvante'.


 -- Função: resolvante_klein (<P>, <x>)
     +calculates the transformation of `<P>(<x>)' by the function
     +`<x_1> <x_2> <x_4> + <x_4>'.

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante', `resolvante_klein3',
     `resolvante_vierer', `resolvante_diedrale'.


 -- Função: resolvante_klein3 (<P>, <x>)
     calcula a transformação de `<P>(<x>)' através da função `<x_1>
     <x_2> <x_4> + <x_4>'.

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante',
     `resolvante_vierer', `resolvante_diedrale'.


 -- Função: resolvante_produit_sym (<P>, <x>)
     calcula a lista de todas as resolventes de produto do polinômio
     `<P>(<x>)'.

          (%i1) resolvante_produit_sym (x^5 + 3*x^4 + 2*x - 1, x);
                  5      4             10      8       7       6       5
          (%o1) [y  + 3 y  + 2 y - 1, y   - 2 y  - 21 y  - 31 y  - 14 y

              4       3      2       10      8       7    6       5       4
           - y  + 14 y  + 3 y  + 1, y   + 3 y  + 14 y  - y  - 14 y  - 31 y

                 3      2       5      4
           - 21 y  - 2 y  + 1, y  - 2 y  - 3 y - 1, y - 1]
          (%i2) resolvante: produit$
          (%i3) resolvante (x^5 + 3*x^4 + 2*x - 1, x, a*b*c, [a, b, c]);

          " resolvente produto "
                 10      8       7    6        5       4       3     2
          (%o3) y   + 3 y  + 14 y  - y  - 14 y  - 31 y  - 21 y  - 2 y  + 1

     Veja também :

     `resolvante', `resolvante_unitaire', `resolvante_alternee1',
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale'.


 -- Função: resolvante_unitaire (<P>, <Q>, <x>)
     calcula a resolvente do polinômio `<P>(<x>)' através do polinomio
     `<Q>(<x>)'.

     Veja também :

     `resolvante_produit_sym', `resolvante', `resolvante_alternee1',
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale'.


 -- Função: resolvante_vierer (<P>, <x>)
     calcula a transformação de `<P>(<x>)' pela função `<x_1> <x_2> -
     <x_3> <x_4>'.

     Veja também :

     `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante_klein3',
     `resolvante', `resolvante_diedrale'.


32.1.7 Miscelânia
-----------------

 -- Função: multinomial (<r>, <part>)
     onde <r> é o peso da partição <part>.  Essa função retorna o
     coefinciente multinomial associado: se as partes de <part> forem
     <i_1>, <i_2>, ..., <i_k>, o resultado é `<r>!/(<i_1>! <i_2>! ...
     <i_k>!)'.

 -- Função: permut (<L>)
     retorna a lista de permutações da lista <L>.


File: maxima.info,  Node: Grupos,  Next: Ambiente em Tempo de Execução,  Prev: Simetrias,  Up: Top

33 Grupos
*********

* Menu:

* Funções e Variáveis Definidas para Grupos::


File: maxima.info,  Node: Funções e Variáveis Definidas para Grupos,  Prev: Grupos,  Up: Grupos

33.1 Funções e Variáveis Definidas para Grupos
==============================================

 -- Função: todd_coxeter (<relação>, <subgroupo>)
 -- Função: todd_coxeter (<relação>)
     Acha a ordem de G/H onde G é o módulo do Grupo Livre <relação>, e
     H é o subgroupo de G gerado por <subgroupo>.  <subgroupo> é um
     argumento opcional, cujo valor padrão é [].  Em fazendo isso a
     função produz uma tabela de multiplicação à direita de G sobre
     G/H, onde os co-conjuntos são enumerados [H,Hg2,Hg3,...].  Isso
     pode ser visto internamente no `todd_coxeter_state'.

     Exemplo:

          (%i1) symet(n):=create_list(
                  if (j - i) = 1 then (p(i,j))^^3 else
                      if (not i = j) then (p(i,j))^^2 else
                          p(i,i) , j, 1, n-1, i, 1, j);
                                                                 <3>
          (%o1) symet(n) := create_list(if j - i = 1 then p(i, j)

                                          <2>
           else (if not i = j then p(i, j)    else p(i, i)), j, 1, n - 1,

          i, 1, j)
          (%i2) p(i,j) := concat(x,i).concat(x,j);
          (%o2)        p(i, j) := concat(x, i) . concat(x, j)
          (%i3) symet(5);
                   <2>           <3>    <2>           <2>           <3>
          (%o3) [x1   , (x1 . x2)   , x2   , (x1 . x3)   , (x2 . x3)   ,

                      <2>           <2>           <2>           <3>    <2>
                    x3   , (x1 . x4)   , (x2 . x4)   , (x3 . x4)   , x4   ]
          (%i4) todd_coxeter(%o3);

          Rows tried 426
          (%o4)                          120
          (%i5) todd_coxeter(%o3,[x1]);

          Rows tried 213
          (%o5)                          60
          (%i6) todd_coxeter(%o3,[x1,x2]);

          Rows tried 71
          (%o6)                          20



File: maxima.info,  Node: Ambiente em Tempo de Execução,  Next: Opções Diversas,  Prev: Grupos,  Up: Top

34 Ambiente em Tempo de Execução
********************************

* Menu:

* Introdução a Ambiente em Tempo de Execução::
* Interrupções::
* Funções e Variáveis Definidas para Ambiente em Tempo de Execução::


File: maxima.info,  Node: Introdução a Ambiente em Tempo de Execução,  Next: Interrupções,  Prev: Ambiente em Tempo de Execução,  Up: Ambiente em Tempo de Execução

34.1 Introdução a Ambiente em Tempo de Execução
===============================================

`maxima-init.mac' é um arquivo que é chamado automaticamente quando o
Maxima inicia.  Você pode usar `maxima-init.mac' para personalizar seu
ambiente Maxima.  `maxima-init.mac', se existir, é tipicamente colocado
no diretório chamado por `maxima_userdir', embora possa estar em
qualquer outro diretório procurado pela função `file_search'.

   Aqui está um exemplo do arquivo `maxima-init.mac':

     setup_autoload ("specfun.mac", ultraspherical, assoc_legendre_p);
     showtime:all;

   Nesse Exemplo, `setup_autoload' diz ao Maxima para chamar o arquivo
especificado (`specfun.mac') se qualquer das funções (`ultraspherical',
`assoc_legendre_p') forem chamadas sem estarem definidas.  Dessa forma
você não precisa lembrar de chamar o arquivo antes das funções.

   A declaração `showtime: all' diz ao Maxima escolher a variável
`showtime'.  O arquivo `maxima-init.mac' pode conter qualquer outras
atribuições ou outras declarações do Maxima.


File: maxima.info,  Node: Interrupções,  Next: Funções e Variáveis Definidas para Ambiente em Tempo de Execução,  Prev: Introdução a Ambiente em Tempo de Execução,  Up: Ambiente em Tempo de Execução

34.2 Interrupções
=================

O usuário pode parar uma computação que consome muito tempo com o
caractere ^C (control-C).  A ação padrão é parar a computação e mostrar
outra linha de comando do usuário.  Nesse caso, não é possível
continuar a computação interrompida.

   Se a variável Lisp `*debugger-hook*' é escolhida para `nil', através
do comando

     :lisp (setq *debugger-hook* nil)

então na ocasião do recebimento do ^C, Maxima iniciará o depurador Lisp,
e o usuário pode usar o depurador para inspecionar o ambiente Lisp.  A
computação interrompida pode ser retomada através do comando `continue'
no depurador Lisp.  O método de retorno para ao Maxima partindo do
depurador Lisp (outro como executando a computação para
complementação) é diferente para cada versão do Lisp.

   Em sistemas Unix, o caratere ^Z (control-Z) faz com que Maxima pare
tudo e aguarde em segundo plano, e o controle é retornado para a linha
de comando do shell.  O comando `fg' faz com que o Maxima retorne ao
primeiro plano e continue a partir do ponto no qual foi interrompido.


File: maxima.info,  Node: Funções e Variáveis Definidas para Ambiente em Tempo de Execução,  Prev: Interrupções,  Up: Ambiente em Tempo de Execução

34.3 Funções e Variáveis Definidas para Ambiente em Tempo de Execução
=====================================================================

 -- Declaração: feature
     Maxima compreende dois tipos distintos de recurso, recursos do
     sistema e recursos aplicados a expressões matemáticas.  Veja
     Também `status' para informações sobre recursos do sistema.  Veja
     Também `features' e `featurep' para informações sobre recursos
     matemáticos.

     `feature' por si mesmo não é o nome de uma função ou variável.


 -- Função: featurep (<a>, <f>)
     Tenta determinar se o objeto <a> tem o recurso <f> na base dos
     fatos dentro base de dados corrente.  Se possue, é retornado
     `true', de outra forma é retornado `false'.

     Note que `featurep' retorna `false' quando nem <f> nem a
     negação de <f> puderem ser estabelecidas.

     `featurep' avalia seus argumentos.

     Veja também `declare' e `features'.

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true


 -- Variável de sistema: maxima_tempdir
     `maxima_tempdir' nomeia o diretório no qual Maxima cria alguns
     arquivos temporários.  Em particular, arquivos temporários para
     impressão são criados no `maxima_tempdir'.

     O valor inicial de `maxima_tempdir' é o diretório do usuário, se o
     maxima puder localizá-lo; de outra forma Maxima supõe um diretório
     adequado.

     A `maxima_tempdir' pode ser atribuído uma seqüência de caracteres
     que corresponde a um diretório.


 -- Variável de sistema: maxima_userdir
     `maxima_userdir' nomeia um diretório no qual Maxima espera
     encontrar seus próprios arquivos e os do arquivos do Lisp.
     (Maxima procura em alguns outros diretórios também;
     `file_search_maxima' e `file_search_lisp' possuem a lista
     completa.)

     O valor inicial de `maxima_userdir' é um subdiretório do diretório
     do usuário, se Maxima puder localizá-lo; de outra forma Maxima
     supõe um diretório adequado.

     A `maxima_userdir' pode ser atribuído uma seqüência de caracteres
     que corresponde a um diretório.  Todavia, fazendo uma
     atribuição a `maxima_userdir' não muda automaticamente o valor de
     `file_search_maxima' e de `file_search_lisp'; Essas variáveis
     devem ser modificadas separadamente.


 -- Função: room ()
 -- Função: room (true)
 -- Função: room (false)
     Mostra uma descrição do estado de armazenamento e gerenciamento de
     pilha no Maxima. `room' chama a função Lisp de mesmo nome.

        * `room ()' mostra uma descrição moderada.

        * `room (true)' mostra uma descrição detalhada.

        * `room (false)' mostra uma descrição resumida.


 -- Função: status (feature)
 -- Função: status (feature, <recurso_ativo>)
 -- Função: status (status)
     Retorna informações sobre a presença ou ausência de certos
     recursos dependentes do sistema operacional.

        * `status (feature)' retorna uma lista dos recursos do sistema.
          Inclui a versão do Lisp, tipo de sistema operacional, etc.  A
          lista pode variar de um tipo de Lisp para outro.

        * `status (feature, <recurso_ativo>)' retorna `true' se
          <recurso_ativo> está na lista de ítens retornada através de
          `status (feature)' e `false' de outra forma.  `status' não
          avalia o argumento <recurso_ativo>.  O operador
          apóstrofo-apóstrofo, `''', evita a avaliação.  Um recurso
          cujo nome contém um caractere especial, tal como um hífem,
          deve ser fornecido como um argumento em forma de seqüência de
          caracteres. Por Exemplo, `status (feature, "ansi-cl")'.

        * `status (status)' retorna uma lista de dois elementos
          `[feature, status]'.  `feature' e `status' são dois
          argumentos aceitos pela função `status'; Não está claro se
          essa lista tem significância adicional.

     A variável `features' contém uma lista de recursos que se aplicam a
     expressões matemáticas. Veja `features' e `featurep' para maiores
     informações.


 -- Função: time (%o1, %o2, %o3, ...)
     Retorna uma lista de tempos, em segundos, usados para calcular as
     linhas de saída `%o1', `%o2', `%o3', .... O tempo retornado é uma
     estimativa do Maxima do tempo interno de computação, não do tempo
     decorrido. `time' pode somente ser aplicado a variáveis(rótulos)
     de saída de linha; para quaisquer outras variáveis, `time' retorna
     `unknown' (tempo desconhecido).

     Escolha `showtime: true' para fazer com que Maxima moste o tempo
     de computação e o tempo decorrido a cada linha de saída.


 -- Função: timedate ()
     Retorna uma seqüência de caracteres representando a data e hora
     atuais.  A seqüência de caracteres tem o formato `HH:MM:SS Dia,
     mm/dd/aaaa (GMT-n)', Onde os campos são horas, minutos, segundos,
     dia da semana, mês, dia do mês, ano, e horas que diferem da hora
     GMT.

     O valor de retorno é uma seqüência de caracteres Lisp.

     Exemplo:

          (%i1) d: timedate ();
          (%o1) 08:05:09 Wed, 11/02/2005 (GMT-7)
          (%i2) print ("timedate mostra o tempo atual", d)$
          timedate reports current time 08:05:09 Wed, 11/02/2005 (GMT-7)


 -- Função: absolute_real_time ()
     Retorna o número de segundos desde a meia noite do dia primeiro de
     janeiro de 1900 (UTC).  O valor de retorno é um inteiro.

     Veja também `elapsed_real_time' e `elapsed_run_time'.

     Exemplo:

          (%i1) absolute_real_time ();
          (%o1)                      3385045277
          (%i2) 1900 + absolute_real_time () / (365.25 * 24 * 3600);
          (%o2)                   2007.265612087104


 -- Função: elapsed_real_time ()
     Retorna o n;umero de segundos (incluindo frações de segundo) desde
     que Maxima tenha sido recentemente iniciado ou reiniciado.  O
     valor de retorno é um número em ponto flutuante.

     Veja também `absolute_real_time' e `elapsed_run_time'.

     Exemplo:

          (%i1) elapsed_real_time ();
          (%o1)                       2.559324
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_real_time ();
          (%o3)                       7.552087


 -- Função: elapsed_run_time ()
     Retorna uma estimativa do número de segundos (incluindo frações de
     segundo) que o Maxima gastou em computações desde que Maxima tenha
     sido recentemente iniciado ou reiniciado.  O valor de retorno é um
     número em ponto flutuante.

     Veja também `absolute_real_time' e `elapsed_real_time'.

     Exemplo:

          (%i1) elapsed_run_time ();
          (%o1)                         0.04
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_run_time ();
          (%o3)                         1.26



File: maxima.info,  Node: Opções Diversas,  Next: Regras e Modelos,  Prev: Ambiente em Tempo de Execução,  Up: Top

35 Opções Diversas
******************

* Menu:

* Introdução a Opções Diversas::
* Compartilhado::
* Funções e Variáveis Definidas para Opções Diversas::


File: maxima.info,  Node: Introdução a Opções Diversas,  Next: Compartilhado,  Prev: Opções Diversas,  Up: Opções Diversas

35.1 Introdução a Opções Diversas
=================================

Nessa seção várias opções são tratadas pelo fato de possuirem um efeito
global sobre a operação do Maxima.   Também várias listas tais como a
lista de todas as funções definidas pelo usuário, são discutidas.


File: maxima.info,  Node: Compartilhado,  Next: Funções e Variáveis Definidas para Opções Diversas,  Prev: Introdução a Opções Diversas,  Up: Opções Diversas

35.2 Compartilhado
==================

O diretório "share" do Maxima contém programas e outros arquivos de
interesse para os usuários do Maxima, mas que não são parte da
implementação do núcleo do Maxima.  Esses programas são tipicamente
chamados via `load' ou `setup_autoload'.

   `:lisp *maxima-sharedir*' mostra a localização do diretório
compartilhado dentro do sistema de arquivos do usuário.

   `printfile ("share.usg")' imprime uma lista de pacotes
desatualizados dos pacotes compartilhados.  Usuários podem encontrar
isso de forma mais detalhada navegando no diretório compartilhado
usando um navegador de sistema de arquivo.


File: maxima.info,  Node: Funções e Variáveis Definidas para Opções Diversas,  Prev: Compartilhado,  Up: Opções Diversas

35.3 Funções e Variáveis Definidas para Opções Diversas
=======================================================

 -- Variável de sistema: aliases
     Valor padrão: `[]'

     `aliases' é a lista de átomos que possuem um alias definido pelo
     usuário (escolhido através das funções `alias', `ordergreat',
     `orderless' ou através da declaração do átomo como sendo um `noun'
     (substantivo) com `declare').

 -- Declaração: alphabetic
     `alphabetic' é uma declaração reconhecida por `declare'.  A
     expressão `declare(<s>, alphabetic)' diz ao Maxima para reconhecer
     como alfabético todos os caracteres em <s>, que deve ser uma
     seqüência de caracteres.

     Veja também *Note Identificadores::.

     Exemplo:

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]


 -- Função: apropos (<string>)
     Procura por nomes Maxima que possuem <string> aparecendo em
     qualquer lugar dentro de seu nome.  Dessa forma, `apropos (exp)'
     retorna uma lista de todos os sinalizadores e funções que possuem
     `exp' como parte de seus nomes, tais como `expand', `exp', e
     `exponentialize'.  Dessa forma você pode somente lembra parte do
     nome de alguma coisa você pode usar esse comando para achar o
     restante do nome.  Similarmente, você pode dizer `apropos (tr_)'
     para achar uma lista de muitos dos comutadores relatando para o
     tradutor, muitos dos quais começam com `tr_'.


 -- Função: args (<expr>)
     Retorna a lista de argumentos de `expr', que pode ser de qualquer
     tipo de expressão outra como um átomo.  Somente os argumentos do
     operador de nível mais alto são extraídos; subexpressões de `expr'
     aparecem como elementos ou subexpressões de elementos da lista de
     argumentos.

     A ordem dos ítens na lista pode depender do sinalizador global
     `inflag'.

     `args (<expr>)' é equivalente a `substpart ("[", <expr>, 0)'.
     Veja também `substpart' e `op'.


 -- Variável de opção: genindex
     Valor padrão: `i'

     `genindex' é o prefixo usado para gerar a próxima variável do
     somatório quando necessário.


 -- Variável de opção: gensumnum
     Valor padrão: 0

     `gensumnum' é o sufixo numérico usado para gerar variável seguinte
     do somatório.  Se isso for escolhido para `false' então o índice
     consistirá somente de `genindex' com um sufixo numérico.


 -- Constante: inf
     Infinito positivo real.


 -- Constante: infinity
     Infinito complexo, uma magnitude infinita de ângulo de fase
     arbitrária.  Veja também `inf' e `minf'.


 -- Variável de sistema: infolists
     Valor padrão: `[]'

     `infolists' é uma lista dos nomes de todas as listas de
     informação no Maxima. São elas:

    `labels'
          Todos associam `%i', `%o', e rótulos `%t'.

    `values'
          Todos associam átomos que são variáveis de usuário, não
          opções do Maxima ou comutadores, criados através de `:' ou
          `::' ou associando funcionalmente.

    `functions'
          Todas as funções definidas pelo usuário, criadas através de
          `:=' ou `define'.

    `arrays'
          Todos os arrays declarados e não declarados, criados através
          de `:', `::', ou `:='.

    `macros'
          Todas as macros definidas pelo usuário.

    `myoptions'
          Todas as opções alguma vez alteradas pelo usuário (mesmo que
          tenham ou não elas tenham mais tarde retornadas para seus
          valores padrão).

    `rules'
          Todos os modelos definidos pelo usuário que coincidirem e
          regras de simplificação, criadas através de `tellsimp',
          `tellsimpafter', `defmatch', ou `defrule'.

    `aliases'
          Todos os átomos que possuem um alias definido pelo usuário,
          criado através das funções `alias', `ordergreat', `orderless'
          ou declarando os átomos como um `noun' com `declare'.

    `dependencies'
          Todos os átomos que possuem dependências funcionais, criadas
          através das funções `depends' ou `gradef'.

    `gradefs'
          Todas as funções que possuem derivadas definidas pelo
          usuário, cridas através da função `gradef'.

    `props'
          Todos os átomos que possuem quaisquer propriedades outras que
          não essas mencionadas acima, tais como propriedades
          estabelecidas por `atvalue' , `matchdeclare', etc., também
          propriedades estabelecidas na função `declare'.

    `let_rule_packages'
          Todos os pacote de régras em uso definidos pelo usuário mais
          o pacote especial `default_let_rule_package'.
          (`default_let_rule_package' é o nome do pacote de régras
          usado quando um não está explicitamente escolhido pelo
          usuário.)



 -- Função: integerp (<expr>)
     Retorna `true' se <expr> é um inteiro numérico literal, de outra
     forma retorna `false'.

     `integerp' retorna `false' se seu argumento for um símbolo, mesmo
     se o argumento for declarado inteiro.

     Exemplos:

          (%i1) integerp (0);
          (%o1)                         true
          (%i2) integerp (1);
          (%o2)                         true
          (%i3) integerp (-17);
          (%o3)                         true
          (%i4) integerp (0.0);
          (%o4)                         false
          (%i5) integerp (1.0);
          (%o5)                         false
          (%i6) integerp (%pi);
          (%o6)                         false
          (%i7) integerp (n);
          (%o7)                         false
          (%i8) declare (n, integer);
          (%o8)                         done
          (%i9) integerp (n);
          (%o9)                         false


 -- Variável de opção: m1pbranch
     Valor padrão: `false'

     `m1pbranch' é principal descendente de `-1' a um expoente.
     Quantidades tais como `(-1)^(1/3)' (isto é, um expoente racional
     "ímpar") e `(-1)^(1/4)' (isto é, um expoente racional "par") são
     manuseados como segue:

                        domain:real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       domain:complex
          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2


 -- Função: numberp (<expr>)
     Retorna `true' se <expr> for um inteiro literal, número racional,
     número em ponto flutuante, ou um grande número em ponto flutuante,
     de outra forma retorna `false'.

     `numberp' retorna `false' se seu argumento for um símbolo, mesmo
     se o argumento for um número simbólico tal como `%pi' ou `%i', ou
     declarado ser `even', `odd', `integer', `rational', `irrational',
     `real', `imaginary', or `complex'. Nota de Tradução: par, ímpar,
     inteiro, racional, irracional, real, imaginário, ou complexo.

     Exemplos:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare (a, even, b, odd, c, integer, d, rational,
               e, irrational, f, real, g, imaginary, h, complex);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e, f, g, h]);
          (%o7) [false, false, false, false, false, false, false, false]


 -- Função: properties (<a>)
     Retorna uma lista de nomes de todas as propriedades associadas com
     o átomo <a>.


 -- Símbolo especial: props
     `props' são átomos que possuem qualquer propriedade outra como
     essas explicitamente mencionadas em `infolists', tais como
     especificado através de `atvalue', `matchdeclare', etc., e também
     propriedades especificadas na função `declare'.


 -- Função: propvars (<prop>)
     Retorna uma lista desses átomos sobre a lista `props' que possui a
     propriedade indicada através de <prop>.  Dessa forma `propvars
     (atvalue)' retorna uma lista de átomos que possuem atvalues.


 -- Função: put (<átomo>, <valor>, <indicador>)
     Atribui <valor> para a propriedade (especificada através de
     <indicador>) do <átomo>.  <indicador> pode ser o nome de qualquer
     propriedade, não apenas uma propriedade definida pelo sistema.

     `put' avalia seus argumentos.  `put' retorna <valor>.

     Exemplos:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello


 -- Função: qput (<átomo>, <valor>, <indicador>)
     Atribui <valor> para a propriedade (especificada através de
     <indicador>) do <átomo>.  Isso é o mesmo que `put', exceto que os
     argumentos nã são avaliados.

     Exemplo:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar


 -- Função: rem (<átomo>, <indicador>)
     Remove a propriedade indicada através de <indicador> do <átomo>.


 -- Função: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Função: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Função: remove ("<a>", operator)
 -- Função: remove (<a>, transfun)
 -- Função: remove (all, <p>)
     Remove propriedades associadas a átomos.

     `remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)' remove a propriedade
     `p_k' do átomo `a_k'.

     `remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)' remove as
     propriedades `<p_1>, ..., <p_n>' dos átomos <a_1>, ..., <a_m>.
     Pode existir mais que um par de listas.

     `remove (all, <p>)' remove a propriedade <p> de todos os átomos
     que a possuem.

     A propriedade removida pode ser definida pelo sistema tal como
     `function', `macro' ou `mode_declare', ou propriedades definidas
     pelo usuário.

     uma propriedade pode ser `transfun' para remover a versão
     traduzida Lisp de uma função.  Após executar isso, a versão Maxima
     da função é executada em lugar da versão traduzida.

     `remove ("<a>", operator)' ou, equivalentemente, `remove ("<a>",
     op)' remove de <a> as propriedades `operator' declaradas através de
     `prefix', `infix', `nary', `postfix', `matchfix', ou `nofix'.
     Note que o nome do operador deve ser escrito como uma seqüência de
     caracteres com apóstofo.

     `remove' sempre retorna `done' se um átomo possui ou não uma
     propriedade especificada.  Esse comportamento é diferente das
     funções remove mais específicas `remvalue', `remarray',
     `remfunction', e `remrule'.


 -- Função: remvalue (<nome_1>, ..., <nome_n>)
 -- Função: remvalue (all)
     Remove os valores de Variáveis de usuário <nome_1>, ..., <nome_n>
     (que podem ser subscritas) do sistema.

     `remvalue (all)' remove os valores de todas as variáveis em
     `values', a lista de todas as variáveis nomeadas através do usuário
     (em oposição a essas que são automaticamente atribuídas através do
     Maxima).

     Veja também `values'.


 -- Função: rncombine (<expr>)
     Transforma <expr> combinando todos os termos de <expr> que possuem
     denominadores idênticos ou denominadores que diferem de cada um
     dos outros apenas por fatores numéricos somente.  Isso é
     ligeiramente diferente do comportamento de de `combine', que
     coleta termos que possuem denominadores idênticos.

     Escolhendo `pfeformat: true' e usando `combine' retorna resultados
     similares a esses que podem ser obtidos com `rncombine', mas
     `rncombine' pega o passo adicional de multiplicar cruzado fatores
     numérios do denominador.  Esses resultados em forma ideal, e a
     possibilidade de reconhecer alguns cancelamentos.

     Para usar essa função escreva primeiramente `load(rncomb)'.

 -- Função: scalarp (<expr>)
     Retorna `true' se <expr> for um número, constante, ou variável
     declarada `scalar' com `declare', ou composta inteiramente de
     números, constantes, e tais Variáveis, bmas não contendo matrizes
     ou listas.


 -- Função: setup_autoload (<nomearquivo>, <função_1>, ..., <função_n>)
     Especifica que se qualquer entre <função_1>, ..., <função_n> for
     referenciado e não ainda definido, <nomedeqrquivo> é chamado via
     `load'.  <nomearquivo> usualmente contém definições para as
     funções especificadas, embora isso não seja obrigatório.

     `setup_autoload' não trabalha para funções array.

     `setup_autoload' não avalia seus argumentos.

     Exemplo:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma função ultraspherical
          Warning - you are redefining the Macsyma função legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2



File: maxima.info,  Node: Regras e Modelos,  Next: Listas,  Prev: Opções Diversas,  Up: Top

36 Regras e Modelos
*******************

* Menu:

* Introdução a Regras e Modelos::
* Funções e Variáveis Definidas para Regras e Modelos::


File: maxima.info,  Node: Introdução a Regras e Modelos,  Next: Funções e Variáveis Definidas para Regras e Modelos,  Prev: Regras e Modelos,  Up: Regras e Modelos

36.1 Introdução a Regras e Modelos
==================================

Essa seção descreve coincidências de modelos definidos pelo usuário e
regras de simplificação.  Existem dois grupos de funções que
implementam até certo ponto diferentes esquemas de coincidência de
modelo.  Em um grupo estão `tellsimp', `tellsimpafter', `defmatch',
`defrule', `apply1', `applyb1', e `apply2'.  Em outro grupo estão `let'
e `letsimp'.  Ambos os esquemas definem modelos em termos de variáveis
de modelo declaradas por `matchdeclare'.

   Regras de coincidência de modelos definidas por `tellsimp' e
`tellsimpafter' são aplicadas automaticamente através do simplificador
do Maxima.  Regras definidas através de `defmatch', `defrule', e `let'
são aplicadas através de uma chamada explícita de função.

   Existe mecanismos adicionais para regras aplicadas a polinômios
através de `tellrat', e para álgebra comutativa e não comutativa no
pacote `affine'.


File: maxima.info,  Node: Funções e Variáveis Definidas para Regras e Modelos,  Prev: Introdução a Regras e Modelos,  Up: Regras e Modelos

36.2 Funções e Variáveis Definidas para Regras e Modelos
========================================================

 -- Função: apply1 (<expr>, <rule_1>, ..., <rule_n>)
     Repetidamente aplica <rule_1> a <expr> até que isso falhe, então
     repetidamente aplica a mesma regra a todas as subexpressões de
     <expr>, da esquerda para a direita, até que <rule_1> tenha falhado
     sobre todas as subexpressões.  Chama o resultado da
     transformação de <expr> dessa maneira de <expr_2>.  Então <rule_2>
     é aplicada no mesmo estilo iniciando no topo de <expr_2>.  Quando
     <rule_n> falhar na subexpressão final, o resultado é retornado.

     `maxapplydepth' é a intensidade de nível mais distante de
     subexpressões processadas por `apply1' e `apply2'.

     Veja também `applyb1', `apply2', e `let'.


 -- Função: apply2 (<expr>, <rule_1>, ..., <rule_n>)
     Se <rule_1> falhar sobre uma dada subexpressão, então <rule_2> é
     repetidamente aplicada, etc.  Somente se todas as regras falharem
     sobre uma dada subexpressão é que o conjunto completo de regras é
     repetidamente aplicada à próxima subexpressão.  Se uma das regras
     obtém sucesso, então a mesma subexpressão é reprocessada,
     iniciando com a primeira regra.

     `maxapplydepth' é a intensidade do nível mais distante de
     subexpressões processadas através de `apply1' e `apply2'.

     Veja também `apply1' e `let'.


 -- Função: applyb1 (<expr>, <rule_1>, ..., <rule_n>)
     Repetidamente aplica <rule_1> para a subexpressão mais distante de
     <expr> até falhar, então repetidamente aplica a mesma regra um
     nível mais acima (i.e., subexpressãos mais larga), até que
     <rule_1> tenha falhado sobre a expressão de nível mais alto.
     Então <rule_2> é aplicada com o mesmo estilo para o resultado de
     <rule_1>.  após <rule_n> ter sido aplicada à expressão de nível
     mais elevado, o resultado é retornado.

     `applyb1' é similar a `apply1' mas trabalha da base para cima em
     lugar de do topo para baixo.

     `maxapplyheight' é o ápice que `applyb1' encontra antes de
     interromper.

     Veja também `apply1', `apply2', e `let'.


 -- Variável de opção: current_let_rule_package
     Valor padrão: `default_let_rule_package'

     `current_let_rule_package' é o nome do pacote de regras que está
     sendo usado por funções no pacote `let' (`letsimp', etc.) se
     nenhum outro pacote de regras for especificado.  A essa variável
     pode ser atribuído o nome de qualquer pacote de regras definido
     via comando `let'.

     Se uma chamada tal como `letsimp (expr, nome_pct_regras)' for
     feita, o pacote de regras `nome_pct_regras' é usado para aquela
     chamada de função somente, e o valor de `current_let_rule_package'
     não é alterado.


 -- Variável de opção: default_let_rule_package
     Valor padrão: `default_let_rule_package'

     `default_let_rule_package' é o nome do pacote de regras usado
     quando um não for explicitamente escolhido pelo usuário com `let'
     ou através de alteração do valor de `current_let_rule_package'.


 -- Função: defmatch (<prognome>, <modelo>, <x_1>, ..., <x_n>)
 -- Função: defmatch (<prognome>, <modelo>)
     Define uma função `<prognome>(<expr>, <x_1>, ..., <x_n>)' que
     testa <expr> para ver se essa expressão coincide com <modelo>.

     <modelo> é uma expressão contendo os argumentos modelo <x_1>, ...,
     <x_n> (se existir algum) e alguns modelos de variáveis (se existir
     algum).  os argumentos modelo são fornecidos explicitamente como
     argumentos para `defmatch' enquanto os modelos de variáveis são
     declarados através da função `matchdeclare'.  Qualquer variável
     não declarada como modelo em `matchdeclare' ou como um argumento
     modelo em `defmatch' coincide somente com si mesma.

     O primeiro argumento para a função criada <prognome> é uma
     expressão a serem comparadas contra o modelo  e os outros
     argumentos são os atuais argumetnos que correspondem às variáveis
     respectivas <x_1>, ..., <x_n> no modelo.

     Se a tentativa de coincidência obtiver sucesso, <prognome> retorna
     uma lista de equações cujos lados esquerdos são os argumetnos de
     modelo e variáveis de modelo, e cujo lado direito forem as
     subexpressões cujos argumentos de modelo e as variáveis coincidem.
     Os modelos de variáveis, mas não tos argumentos de modelo, são
     atribuídos às subexpressões que coincidirem.  Se a coincidência
     falhar, <prognome> retorna `false'.

     Um modelo literal (isto é, um modelo que não contiver nem
     argumentos de modelo nem variáveis de modelo) retorna `true' se a
     coincidência ocorrer.

     Veja também `matchdeclare', `defrule', `tellsimp', e
     `tellsimpafter'.

     Exemplos:

     Define uma função `linearp(expr, x)' que testa `expr' para ver se
     essa expressão da forma `a*x + b' tal que `a' e `b' não contenham
     `x' e `a' seja não nulo.  Essa função de coincidência coincide com
     expressões que sejam lineares em qualquer variável, por que o
     argumento de modelo `x' é fornecido para `defmatch'.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b, x);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y
          (%i6) x;
          (%o6)                           x

     Define uma função `linearp(expr)' que testa `expr' para ver se
     essa expressão é da forma `a*x + b' tal que `a' e `b' não
     contenham `x' e `a' seja não nulo.  Essa função de coincidência
     somente coincide com expressões lineares em `x', não em qualquer
     outra variável, porque nenhum argumento de modelo é fornecido a
     `defmatch'.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2);
          (%o3)                         false
          (%i4) linearp (3*x + (y + 1)*x + y^2);
                                       2
          (%o4)                  [b = y , a = y + 4]

     Define uma função `checklimits(expr)' que testa `expr' para ver se
     essa expressão é uma integral definida.

          (%i1) matchdeclare ([a, f], true);
          (%o1)                         done
          (%i2) constinterval (l, h) := constantp (h - l);
          (%o2)        constinterval(l, h) := constantp(h - l)
          (%i3) matchdeclare (b, constinterval (a));
          (%o3)                         done
          (%i4) matchdeclare (x, atom);
          (%o4)                         done
          (%i5) simp : false;
          (%o5)                         false
          (%i6) defmatch (checklimits, 'integrate (f, x, a, b));
          (%o6)                      checklimits
          (%i7) simp : true;
          (%o7)                         true
          (%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o8)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i9) checklimits (%);
          (%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]


 -- Função: defrule (<nomeregra>, <modelo>, <substituição>)
     Define e nomeia uma regra de substituição para o modelo dado.  Se
     a regra nomeada <nomeregra> for aplicada a uma expressão (através
     de `apply1', `applyb1', ou `apply2'), toda subexpressão
     coincidindo com o modelo será substituída por `substituição'.
     Todas as variáveis em `substituição' que tiverem sido atribuidos
     valores pela coincidência com o modelo são atribuidas esses
     valores na `substituição' que é então simplificado.

     As regras por si mesmas podem ser tratadas como funções que
     transforma uma expressão através de uma operação de coincidência
     de modelo e substituição.  Se a coincidência falhar, a função da
     regra retorna `false'.


 -- Função: disprule (<nomeregra_1>, ..., <nomeregra_2>)
 -- Função: disprule (all)
     Mostra regras com os nomes <nomeregra_1>, ..., <nomeregra_n>, como
     retornado por `defrule', `tellsimp', ou `tellsimpafter', ou um
     modelo definido por meio de `defmatch'.  Cada regra é mostrada com
     um rótulo de expressão intermediária (`%t').

     `disprule (all)' mostra todas as regras.

     `disprule' não avalia seus argumentos.  `disprule' retorna a lista
     de rótulos de expressões intermedáirias correspondendo às regras
     mostradas.

     Veja também `letrules', que mostra regras definidas através de
     `let'.

     Examples:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
          +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]


 -- Função: let (<prod>, <repl>, <prednome>, <arg_1>, ..., <arg_n>)
 -- Função: let ([<prod>, <repl>, <prednome>, <arg_1>, ..., <arg_n>],
          <nome_pacote>)
     Define uma regra de substituição para `letsimp' tal que <prod> é
     substituído por <repl>.  <prod> é um produto de expoentes
     positivos ou negativos dos seguintes termos:

        * Atomos que `letsimp' irá procurar literalmente a menos que
          previamente chamando `letsimp' a função `matchdeclare' é
          usada para associar um predicado com o átomo.  Nesse caso
          `letsimp' irá coincidir com o átomo para qualquer termo de um
          produto satisfazendo o predicado.

        * Núcleos tais como `sin(x)', `n!', `f(x,y)', etc.  Como com
          átomos acima `letsimp' irá olhar um literal coincidente a
          menos que `matchdeclare' seja usada para associar um
          predicado com o argumento do núcleo.

     Um termo para um expoente positivo irá somente coincidir com um
     termo tendo ao menos aquele expoente.  Um termo para um expoente
     negativo por outro lado irá somente coincidir com um termo com um
     expoente ao menos já negativo.  o caso de expentes negativos em
     <prod> o comutador `letrat' deve ser escolhido para `true'.  Veja
     também `letrat'.

     Se um predicado for incluído na função `let' seguido por uma lista
     de argumentos, uma tentativa de coincidência (i.e. uma que pode
     ser aceita se o predicado fosse omitido) é aceita somente se
     `prednome (arg_1', ..., arg_n')' avaliar para `true' onde <arg_i'>
     é o valor coincidente com <arg_i>.  O <arg_i> pode ser o nome de
     qualquer átomo ou o argumento de qualquer núcleo aparecendo em
     <prod>.  <repl> pode ser qualquer expressão racional. Se quaisquer
     dos átomos ou argumentos de <prod> aparecer em <repl> a
     substituição é feita.  O sinalizador global `letrat' controla a
     simplificação dos quocientes através de `letsimp'.  Quando
     `letrat' for `false', `letsimp' simplifica o numerador e o
     denominador de <expr> separadamente, e não simplifica o quociente.
     Substituições tais como `n!/n' vão para `(n-1)!' então falham
     quando `letrat' for `false'.  Quando `letrat' for `true', então o
     numerador, o denominador, e o quociente são simplificados nessa
     ordem.

     Essas funções de substituição permitem a você trabalhar com muitos
     pacotes de regras.  Cada pacote de regras pode conter qualquer
     número de regras `let' e é referenciado através de um nome
     definido pelo usuário.  `let ([<prod>, <repl>, <prednome>,
     <arg_1>, ..., <arg_n>], <nome_pacote>)' adiciona a regra
     <prednome> ao pacote de regras <nome_pacote>.  `letsimp (<expr>,
     <nome_pacote>)' aplica as regras em <nome_pacote>.  `letsimp
     (<expr>, <nome_pacote1>, <nome_pacote2>, ...)' é equivalente a
     `letsimp (<expr>, <nome_pacote1>)' seguido por `letsimp (%,
     <nome_pacote2>)', ....

     `current_let_rule_package' é o nome do pacote de regras que está
     atualmente sendo usando.  Essa variável pode receber o nome de
     qualquer pacote de regras definidos via o comando `let'.  Quando
     qualquer das funções compreendidas no pacote `let' são chamadas
     sem o nome do pacote, o pacote nomeado por
     `current_let_rule_package' é usado.  Se uma chamada tal como
     `letsimp (<expr>, <nome_pct_regras>)' é feita, o pacote de regras
     <nome_pct_regras> é usado somente para aquele comando `letsimp', e
     `current_let_rule_package' não é alterada.  Se não especificado de
     outra forma, `current_let_rule_package' avalia de forma
     padronizada para `default_let_rule_package'.

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1


 -- Variável de opção: letrat
     Valor padrão: `false'

     Quando `letrat' for `false', `letsimp' simplifica o numerador e o
     denominador de uma razão separadamente, e não simplifica o
     quociente.

     Quando `letrat' for `true', o numerador, o denominador, e seu
     quocienten são simplificados nessa ordem.

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!


 -- Função: letrules ()
 -- Função: letrules (<nome_pacote>)
     Mostra as regras em um pacote de regras.  `letrules ()' mostra as
     regras no pacote de regras corrente.  `letrules (<nome_pacote>)'
     mostra as regras em `nome_pacote'.

     O pacote de regras corrente é nomeado por
     `current_let_rule_package'.  Se não especificado de outra forma,
     `current_let_rule_package' avalia de forma padrão para
     `default_let_rule_package'.

     Veja também `disprule', que mostra regras defindas por `tellsimp'
     e `tellsimpafter'.


 -- Função: letsimp (<expr>)
 -- Função: letsimp (<expr>, <nome_pacote>)
 -- Função: letsimp (<expr>, <nome_pacote_1>, ..., <nome_pacote_n>)
     Repetidamente aplica a substituição definida por `let' até que
     nenhuma mudança adicional seja feita para <expr>.

     `letsimp (<expr>)' usa as regras de `current_let_rule_package'.

     `letsimp (<expr>, <nome_pacote>)' usa as regras de <nome_pacote>
     sem alterar `current_let_rule_package'.

     `letsimp (<expr>, <nome_pacote_1>, ..., <nome_pacote_n>)' é
     equivalente a `letsimp (<expr>, <nome_pacote_1>', seguido por
     `letsimp (%, <nome_pacote_2>)', e assim sucessivamente.


 -- Variável de opção: let_rule_packages
     Valor padrão: `[default_let_rule_package]'

     `let_rule_packages' é uma lista de todos os pacotes de regras
     `let' definidos pelo usuário mais o pacote padrão
     `default_let_rule_package'.


 -- Função: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)
     Associa um predicado <pred_k> com uma variável ou lista de
     variáveis <a_k> de forma que <a_k> coincida com expressões para as
     quais o predicado retorne qualquer coisa que não `false'.

     Umpredicado é o nome de uma função, ou de uma expressão lambda, ou
     uma chamada de função ou chamada de função lambda iomitindo o
     úlltimo argumento, ou `true' ou `all'.  Qualquer expressão
     coincide com `true' ou `all'.  Se o predicado for especificado
     como uma chamada de função ou chamada de função lambda, a
     expressão a ser testada é anexada ao final da lista de argumentos;
     os argumentos são avaliados ao mesmo tempo que a coincidência é
     avaliada.  De outra forma, o predicado é especificado como um nome
     de função ou expressão lambda, e a expressão a ser testada é o
     argumento sozinho.  Uma função predicado não precisa ser definida
     quando `matchdeclare' for chamada; o predicado não é avaliado até
     que uma coincidência seja tentada.

     Um predicado pode retornar uma expressão Booleana além de `true'
     ou `false'.  Expressões Booleanas são avaliadas por `is' dentro da
     função da regra construída, de forma que não é necessário chamar
     `is' dentro do predicado.

     Se uma expressão satisfaz uma coincidência de predicado, a
     variável de coincidência é atribuída à expressão, exceto para
     variáveis de coincidência que são operandos de adição `+' ou
     multiplicação `*'.  Somente adição e multiplicação são manuseadas
     de forma especial; outros operadores enários (ambos os definidos
     internamente e os definidos pelo usuário) são tratados como
     funções comuns.

     No caso de adição e multiplicação, a variável de coincidência pode
     ser atribuida a uma expressão simples que satisfaz o predicado de
     coincidência, ou uma adição ou um produto (respectivamente) de
     tais expressões.  Tal coincidência de termo multiplo é gulosa:
     predicados são avaliados na ordem em que suas variáveis associadas
     aparecem no modelo de coincidência, e o termo que satisfizer mais
     que um predicado é tomado pelo primeiro predicado que satisfizer.
     Cada predicado é testado contra todos os operandos de adição ou
     produto antes que o próximo predicado seja avaliado.
     Adicionalmente, se 0 ou 1 (respectivamente) satisfazem um
     predicado de coincidência, e não existe outros termos que
     satisfaçam o predicado, 0 ou 1 é atribuído para a variável de
     coincidência associada com o predicado.

     O algorítmo para processar modelos contendo adição e
     multiplicação faz alguns resultados de coincidência (por exemplo,
     um modelo no qual uma variável "coincida com qualquer coisa"
     aparecer) dependerem da ordem dos termos no modelo de coincidência
     e na expressão a ser testada a coincidência.  Todavia, se todos os
     predicados de coincidência são mutuamente exclusivos, o resultado
     de coincidência é insensível a ordenação, como um predicado de
     coincidência não pode aceitar termos de coincidência de outro.

     Chamado `matchdeclare' com uma variável <a> como um argumento muda
     a propriedade `matchdeclare' para <a>, se a variável <a> tiver
     sido declarada anteriormente; somente o `matchdeclare' mais
     recente está em efeito quando uma regra é definida, mudanças
     posteriores para a propriedade `matchdeclare' (via `matchdeclare'
     ou `remove') não afetam regras existentes.

     `propvars (matchdeclare)' retorna a lista de todas as variáveis
     para as quais exista uma propriedade `matchdeclare'.  `printprops
     (<a>, matchdeclare)' retorna o predicado para a variável `a'.
     `printprops (all, matchdeclare)' retorna a lista de predicados
     para todas as variáveis `matchdeclare'.  `remove (<a>,
     matchdeclare)' remove a propriedade `matchdeclare' da variável <a>.

     As funções `defmatch', `defrule', `tellsimp', `tellsimpafter', e
     `let' constroem regras que testam expressões contra modelos.

     `matchdeclare' coloca apóstrofo em seus argumentos.
     `matchdeclare' sempre retorna `done'.

     Exemplos:

     Um predicado é o nome de uma função, ou uma expressão lambda, ou
     uma chamada de função ou chamada a função lambda omitindo o último
     argumento, or `true' or `all'.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) matchdeclare (bb, lambda ([x], x > 0));
          (%o2)                         done
          (%i3) matchdeclare (cc, freeof (%e, %pi, %i));
          (%o3)                         done
          (%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
          (%o4)                         done
          (%i5) matchdeclare (ee, true);
          (%o5)                         done
          (%i6) matchdeclare (ff, all);
          (%o6)                         done

     Se uma expressão satisfaz um predicado de coincidência, a variável
     de coincidência é atribuída à expressão.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) defrule (r1, bb^aa, ["integer" = aa, "atom" = bb]);
                              aa
          (%o2)        r1 : bb   -> [integer = aa, atom = bb]
          (%i3) r1 (%pi^8);
          (%o3)               [integer = 8, atom = %pi]

     No caso de adição e multiplicação, à variável de coincidência pode
     ser atribuída uma expressão simples que satisfaz o predicado de
     coincidência, ou um somatório ou produtório (respectivamente) de
     tais expressões.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + sin(x));
          (%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * sin(x));
          (%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]

     Quando coincidindo argumentos de `+' e `*', se todos os predicados
     de coincidência forem mutuamente exclusivos, o resultado da
     coincidência é insensíve à ordenação, como um predicado de
     coincidência não pode aceitar termos que coincidiram com outro.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                               n
          (%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                            n
                                                   (b + a) 2  sin(x)
          (%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                           c

     As funções `propvars' e `printprops' retornam informações sobre
     variávels de coincidência.

          (%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
          (%o1)                         done
          (%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x > 100));
          (%o2)                         done
          (%i3) propvars (matchdeclare);
          (%o3)             [aa, bb, cc, dd, ee, ff, gg]
          (%i4) printprops (ee, matchdeclare);
          (%o4)                    [integerp(ee)]
          (%i5) printprops (gg, matchdeclare);
          (%o5)              [lambda([x], x > 100, gg)]
          (%i6) printprops (all, matchdeclare);
          (%o6) [lambda([x], x > 100, gg), floatnump(ff), integerp(ee),
                                integerp(dd), atom(cc), atom(bb), atom(aa)]


 -- Função: matchfix (<delimitador_e>, <delimitador_d>)
 -- Função: matchfix (<delimitador_e>, <delimitador_d>, <arg_pos>,
          <pos>)
     Declara um operador `matchfix' com delimitadores esquerdo e
     direito <delimitador_e> e <delimitador_d>.  Os delimitadores são
     especificados como seqüêcias de caracteres.

     Um operador "matchfix" é uma função que aceita qualquer número de
     argumentos, tal que os argumentos ocorram entre os delimitadores
     correspondentes esquerdo e direito.  Os delimitadores podem ser
     quaisquer seqüêcias de caracteres, contanto que o analisador de
     expressões do Maxima possa distingüir os delimitadores dos
     operandos e de outras expressões e operadores.  Na prática essas
     regras excluem delimitadores não analisáveis tais como `%', `,',
     `$' e `;', e pode ser necessário isolar os delimitadores com
     espaços em branco.  O delimitador da direita pode ser o mesmo ou
     diferente do delimitador da esquerda.

     Um delimitador esquerdo pode ser associado com somente um
     delimitador direito; dois diferentes operadores `matchfix' não
     podem ter o mesmo delimitador esquerdo.

     Um operador existente pode ser redeclarado com um operador
     `matchfix' sem alterar suas outras propriedades.  Particularmente,
     operadores internos tais como adição `+' podem ser declarados
     `matchfix', mas funções operadores não podem ser definidas para
     operadores internos.

     `matchfix (<delimitador_e>, <delimitador_d>, <arg_pos>, <pos>)'
     declara o argumento <arg_pos> como sendo um entre: expressão
     lógica, expressão comum do Maxima mas que não seja do tipo
     anterior, e qualquer outro tipo de expressão que não esteja
     incluída nos dois primeiros tipos.  Essa declaração resulta em
     <pos> sendo um entre: expressão lógica, expressão comum do Maxima
     mas que não seja do tipo anterior, e qualquer outro tipo de
     expressão que não esteja incluída nos dois primeiros tipos e os
     delimitadores <delimitador_e> e <delimitador_d>.

     A função para realizar uma operação `matchfix' é uma função comum
     definida pelo usuário.  A função operador é definida da forma usual
     com o operador de definição de função `:=' ou `define'.  Os
     argumentos podem ser escritos entre os delimitadores, ou com o
     delimitador esquerdo com uma seqüência de caracteres com apóstrofo
     e os argumentos seguindo entre parêntesis.  `dispfun
     (<delimitador_e>)' mostra a definição da função operador.

     O único operador interno `matchfix' é o construtor de listas `[ ]'.
     Parêntesis `( )' e aspas duplas `" "' atuam como operadores
     `matchfix', mas não são tratados como tal pelo analisador do
     Maxima.

     `matchfix' avalia seus argumentos.  `matchfix' retorna seu
     primeiro argumento, <delimitador_e>.

     Exemplos:

        * Delimitadores podem ser quase quaisquer seqüência de
          caracteres.

          (%i1) matchfix ("@@", "~");
          (%o1)                          @@
          (%i2) @@ a, b, c ~;
          (%o2)                      @@a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                          >>
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                          foo
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                      @@p, q~

        * Operadores `matchfix' são funções comuns definidas pelo
          usuário.

          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15


 -- Função: remlet (<prod>, <nome>)
 -- Função: remlet ()
 -- Função: remlet (all)
 -- Função: remlet (all, <nome>)
     Apaga a regra de substituiçao, prod -> repl, mais recentemente
     definida através dea função `let'.  Se `nome' for fornecido a
     regra é apagada do pacote de regras chamado `nome'.

     `remlet()' e `remlet(all)' apagam todas as regras de
     substituição do pacote de regras corrente.  Se o nome de um pacote
     de regras for fornecido, e.g. `remlet (all, <nome>)', o pacote de
     regras <nome> é também apagado.

     Se uma substituição é para ser mudada usando o mesmo produto,
     `remlet' não precisa ser chamada, apenas redefina a
     substituição usando o mesmo produto (literalmente) com a função
     `let' e a nova substituição e/ou nome de predicado.  Pode agora
     `remlet (<prod>)' ser chamada e a regra de substituição original é
     ressuscitada.

     Veja também `remrule', que remove uma regra definida através de
     `tellsimp' ou de `tellsimpafter'.


 -- Função: remrule (<op>, <nomeregra>)
 -- Função: remrule (<op>, all)
     Remove regras definidas por `tellsimp', ou `tellsimpafter'.

     `remrule (<op>, <nomeregra>)' remove a regra com o nome
     `nomeregra' do operador <op>.  Quando <op> for um operador interno
     ou um operador definido pelo usuário (como definido por `infix',
     `prefix', etc.), <op> e <rulename> devem ser colocados entre aspas
     duplas.

     `remrule (<op>, all)' remove todas as regras para o operador <op>.

     Veja também `remlet', que remove uma regra definida através de
     `let'.

     Examples:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@@");
          (%o3)                          @@
          (%i4) tellsimp (aa @@ bb, bb/aa);
          (%o4)                   [@@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                 quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", "+rule1");
          (%o9)                           +
          (%i10) remrule ("@@", "@@rule1");
          (%o10)                         @@
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                  quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e),
                                                   quux(%e, %pi)]


 -- Função: tellsimp (<pattern>, <replacement>)
     é similar a `tellsimpafter' mas coloca nova informação antes da
     antiga de forma que essa nova regra seja aplicada antes das regras
     de simplificação internas.

     `tellsimp' é usada quando for importante modificar a expressão
     antes que o simplificador trabalhe sobre ela, por exemplo se o
     simplificador "sabe" alguma coisa sobre a expressão, mas o que ele
     retorna não é para sua apreciação.  Se o simplificador "sabe"
     alguma coisa sobre o principal operador da expressão, mas está
     simplesmente escondendo de você, você provavelmente quer usar
     `tellsimpafter'.

     O modelo pode não ser uma adição, um produto, variável simples, ou
     número.

     `rules' é a lista de regras definidas por `defrule', `defmatch',
     `tellsimp', e `tellsimpafter'.

     Exemplos:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)


 -- Função: tellsimpafter (<modelo>, <substituição>)
     Define a uma regra de simplificação que o simplificador do Maxima
     aplica após as regras de simplificação internas.  <modelo> é uma
     expressão, compreendendo variáveis de modelo (declaradas através
     de `matchdeclare') e outros átomos e operações, considerados
     literais para o propósito de coincidência de modelos.
     <substituição> é substituída para uma expressão atual que coincide
     com <modelo>; variáveis de modelo em <substituição> são atribuidas
     a valores coincidentes na expressão atual.

     <modelo> pode ser qualquer expressão não atômica na qual o
     principal operador não é uma variável de modelo; a regra de
     simplificação está associada com o operador principal.  Os nomes
     de funções (com uma excessão, descrita abaixo), listas, e arrays
     podem aparecer em <modelo> como o principal operador somente como
     literais (não variáveis de modelo); essas regras fornecem
     expressões tais como `aa(x)' e `bb[y]' como modelos, se `aa' e
     `bb' forem variáveis de modelo.  Nomes de funções, listas, e
     arrays que são variáveis de modelo podem aparecer como operadores
     outros que não o operador principal em <modelo>.

     Existe uma excessão para o que foi dito acima com relação a regras
     e nomes de funções.  O nome de uma função subscrita em uma
     expressão tal como `aa[x](y)' pode ser uma variável de modelo,
     porque o operador principal não é `aa' mas ao contrário o átomo
     Lisp `mqapply'.  Isso é uma conseqüência da representação de
     expressões envolvendo funções subscritas.

     Regras de simplificação são aplicadas após avaliação (se não
     suprimida através de colocação de apóstrofo ou do sinalizador
     `noeval').  Regras estabelecidas por `tellsimpafter' são aplicadas
     na ordem em que forem definidas, e após quaisquer regras internas.
     Regras são aplicadas de baixo para cima, isto é, aplicadas
     primeiro a subexpressões antes de ser aplicada à expressão
     completa.  Isso pode ser necessário para repetidamente simplificar
     um resultado (por exemplo, via o operador apóstrofo-apóstrofo `'''
     ou o sinalizador `infeval') para garantir que todas as regras são
     aplicadas.

     Variáveis de modelo são tratadas como variáveis locais em regras
     de simplificação.  Assim que uma regra é definida, o valor de uma
     variável de modelo não afeta a regra, e não é afetado pela regra.
     Uma atribuição para uma variável de modelo que resulta em uma
     coincidência de regra com sucesso não afeta a atribuição corrente
     (ou necessita disso) da variável de modelo.  Todavia, como com
     todos os átomos no Maxima, as propriedades de variáveis de modelo
     (como declarado por `put' e funções relacionadas) são globais.

     A regra construída por `tellsimpafter' é nomeada após o operador
     principal de `modelo'.  Regras para operadores internos, e
     operadores definidos pelo usuário definidos por meio de `infix',
     `prefix', `postfix', `matchfix', e `nofix', possuem nomes que são
     seqüências de caracteres do Maxima.  Regras para outras funções
     possuem nomes que são identificadores comuns do Maxima.

     O tratamento de substantivos e formas verbais é desprezívelmente
     confuso. Se uma regra é definida para uma forma substantiva (ou
     verbal) e uma regra para o verbo correspondente (ou substantivo)
     já existe, então a nova regra definida aplica-se a ambas as formas
     (substantiva e verbal).  Se uma regra para a correspondente forma
     verbal (ou substantiva) não existe, a nova regra definida
     aplicar-se-á somente para a forma substantiva (ou verbal).

     A regra construída através de `tellsimpafter' é uma função Lisp
     comum.  Se o nome da regra for `$foorule1', a construção `:lisp
     (trace $foorule1)' rastreia a função, e `:lisp (symbol-function
     '$foorule1' mostra sua definição.

     `tellsimpafter' não avalia seus argumentos.  `tellsimpafter'
     retorna a lista de regras para o operador principal de <modelo>,
     incluindo a mais recente regra estabelecia.

     Veja também `matchdeclare', `defmatch', `defrule', `tellsimp',
     `let', `kill', `remrule', e `clear_rules'.

     Exemplos:

     <modelo> pode ser qualquer expressão não atômica na qual o
     principal operador não é uma variável de modelo.

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     Regras são aplicadas na ordem em que forem definidas.  Se duas
     regras podem coincidir com uma expressão, a regra que foi primeiro
     definida é a que será aplicada.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     variáveis de modelo são tratadas como variáveis locais em regras
     de simplificação.  (Compare a `defmatch', que trata variáveis de
     modelo como variáveis globais.)

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     Como com todos os átomos, propriedades de variáveis de modelo são
     globais embora valores sejam locais.  Nesse exemplo, uma
     propriedade de atribuição é declarada via `define_variable'.  Essa
     é a propriedade do átomo `bb' através de todo o Maxima.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     Regras são nomeadas após operadores principais.  Nomes de regras
     para operadores internos e operadores definidos pelo usuário são
     seqüências de caracteres, enquanto nomes para outras funções são
     identificadores comuns.

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [trigrule0, trigrule1, trigrule2, trigrule3, trigrule4,
          htrigrule1, htrigrule2, htrigrule3, htrigrule4, foorule1,
          foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) [?mstringp (foorule_name), symbolp (foorule_name)];
          (%o10)                    [false, true]
          (%i11) [?mstringp (plusrule_name), symbolp (plusrule_name)];
          (%o11)                    [true, true]
          (%i12) remrule (foo, foorule1);
          (%o12)                         foo
          (%i13) remrule ("^", "^rule1");
          (%o13)                          ^

     Um exemplo trabalhado: multiplicação anticomutativa.

          (%i1) gt (i, j) := integerp(j) and i < j;
          (%o1)           gt(i, j) := integerp(j) and i < j
          (%i2) matchdeclare (i, integerp, j, gt(i));
          (%o2)                         done
          (%i3) tellsimpafter (s[i]^^2, 1);
          (%o3)                 [^^rule1, simpncexpt]
          (%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
          (%o4)                   [.rule1, simpnct]
          (%i5) s[1] . (s[1] + s[2]);
          (%o5)                    s  . (s  + s )
                                    1     2    1
          (%i6) expand (%);
          (%o6)                      1 - s  . s
                                          2    1
          (%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
          (%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
                      9    8    7    6    5    4    3    2    1    0


 -- Função: clear_rules ()
     Executa `kill (rules)' e então re-escolhe o próximo número de
     regra para 1 para adição `+', multiplicação `*', e
     exponenciação `^'.



File: maxima.info,  Node: Listas,  Next: Conjuntos,  Prev: Regras e Modelos,  Up: Top

37 Listas
*********

* Menu:

* Introdução a Listas::
* Funções e Variáveis Definidas para Listas::


File: maxima.info,  Node: Introdução a Listas,  Next: Funções e Variáveis Definidas para Listas,  Prev: Listas,  Up: Listas

37.1 Introdução a Listas
========================

Listas são o bloco básico de construção para Maxima e Lisp.**Todos os
outros tipos de dado como arrays, tabelas desordenadas, números são
representados como listas Lisp.  Essas listas Lisp possuem a forma

     ((MPLUS) $A 2)

para indicar a expressão `a+2'.**No nível um do Maxima poderemos ver a
notação infixa `a+2'.**Maxima também tem listas que foram impressas como

     [1, 2, 7, x+y]

para uma lista com 4 elementos.**Internamente isso corresponde a uma
lista Lisp da forma

     ((MLIST) 1  2  7  ((MPLUS)  $X $Y ))

O sinalizador que denota o tipo campo de uma expressão Maxima é uma
lista em si mesmo, após ter sido adicionado o simplificador a lista
poderá transforma-se

     ((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))


File: maxima.info,  Node: Funções e Variáveis Definidas para Listas,  Prev: Introdução a Listas,  Up: Listas

37.2 Funções e Variáveis Definidas para Listas
==============================================

 -- Função: append (<list_1>, ..., <list_n>)
     Retorna uma lista simples dos elementos de <list_1> seguidos pelos
     elementos de <list_2>, ....  `append' também trabalha sobre
     expressões gerais, e.g. `append (f(a,b), f(c,d,e));' retorna
     `f(a,b,c,d,e)'.

     Faça `example(append);' para um exemplo.


 -- Função: assoc (<key>, <list>, <default>)
 -- Função: assoc (<key>, <list>)
     Essa função procura pela chave <key> do lado esquerdo da entrada
     <list> que é da forma `[x,y,z,...]' onde cada elemento de <list> é
     uma expressão de um operando binário e 2 elementos.  Por exemplo
     `x=1', `2^3', `[a,b]' etc.  A chave <key> é verificada contra o
     primeiro operando.  `assoc' retorna o segundo operando se `key'
     for achada.  Se a chave `key' não for achada isso retorna o valor
     padrão <default>.  <default> é opcional e o padrão é `false'.


 -- Função: atom (<expr>)
     Retorna `true' se <expr> for atomica (i.e. um número, nome ou
     seqüência de caracteres) de outra forma retorna `false'.  Desse
     modo `atom(5)' é `true' enquanto `atom(a[1])' e `atom(sin(x))' São
     `false' (assumindo `a[1]' e `x' não estão associados).


 -- Função: cons (<expr>, <list>)
     Retorna uma nova lista construída do elemento <expr> como seu
     primeiro elemento, seguido por elementos de <list>.  `cons' também
     trabalha sobre outras expressões, e.g. `cons(x, f(a,b,c));'  ->
     `f(x,a,b,c)'.


 -- Função: copylist (<list>)
     Retorna uma cópia da lista <list>.


 -- Função: create_list (<form>, <x_1>, <list_1>, ..., <x_n>, <list_n>)
     Cria uma lista por avaliação de <form> com <x_1> associando a cada
     elemento <list_1>, e para cada tal associação anexa <x_2> para
     cada elemento de <list_2>, ....  O número de elementos no
     resultado será o produto do número de elementos de cada lista.
     Cada variável <x_i> pode atualmente ser um síbolo -o qual não pode
     ser avaliado.  A lista de argumentos será avaliada uma única vez
     no início do bloco de repetição.

          (%i82) create_list1(x^i,i,[1,3,7]);
          (%o82) [x,x^3,x^7]

     Com um bloco de repetição duplo:

          (%i79) create_list([i,j],i,[a,b],j,[e,f,h]);
          (%o79) [[a,e],[a,f],[a,h],[b,e],[b,f],[b,h]]

     Em lugar de <list_i> dois argumentos podem ser fornecidos cada um
     dos quais será avaliado como um número.   Esses podem vir a ser
     inclusive o limite inferior e superior do bloco de repetição.

          (%i81) create_list([i,j],i,[1,2,3],j,1,i);
          (%o81) [[1,1],[2,1],[2,2],[3,1],[3,2],[3,3]]

     Note que os limites ou lista para a variável `j' podem depender do
     valor corrente de `i'.


 -- Função: delete (<expr_1>, <expr_2>)
 -- Função: delete (<expr_1>, <expr_2>, <n>)
     Remove todas as ocorrências de <expr_1> em <expr_2>. <expr_1> pode
     ser uma parcela de <expr_2> (se isso for uma adição) ou um fator
     de <expr_2> (se isso for um produto).

          (%i1) delete(sin(x), x+sin(x)+y);
          (%o1)                         y + x

     `delete(<expr_1>, <expr_2>, <n>)' remove as primeiras <n>
     ocorrências de <expr_1> em <expr_2>.  Se houver menos que <n>
     ocorrências de <expr_1> em <expr_2> então todas as corrências
     seram excluídas.

          (%i1) delete(a, f(a,b,c,d,a));
          (%o1)                      f(b, c, d)
          (%i2) delete(a, f(a,b,a,c,d,a), 2);
          (%o2)                     f(b, c, d, a)


 -- Função: eighth (<expr>)
     Retorna o oitavo item de uma expressão ou lista <expr>.  Veja
     `first' para maiores detalhes.


 -- Função: endcons (<expr>, <list>)
     Retorna uma nova lista consistindo de elementos de `list' seguidos
     por <expr>.  `endcons' também trabalha  sobre expressões gerais,
     e.g.  `endcons(x, f(a,b,c));'  ->  `f(a,b,c,x)'.


 -- Função: fifth (<expr>)
     Retorna o quinto item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: first (<expr>)
     Retorna a primeira parte de <expr> que pode resultar no primeiro
     elemento de uma lista, a primeira linha de uma matriz, a primeira
     parcela de uma adição, etc.  Note que `first' e suas funções
     relacionadas, `rest' e `last', trabalham sobre a forma de <expr>
     que é mostrada não da forma que é digitada na entrada.  Se a
     variável `inflag' é escolhida para `true' todavia, essa funções
     olharão  na forma interna de <expr>.  Note que o simplificador
     re-ordena expressões.  Desse modo `first(x+y)' será `x' se `inflag'
     for `true' e `y' se `inflag' for `false' (`first(y+x)' fornece os
     mesmos resultados).  As funções `second' .. `tenth' retornam da
     segunda até a décima parte do seu argumento.


 -- Função: fourth (<expr>)
     Retorna o quarto item da expressõ ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: get (<a>, <i>)
     Recupera a propriedade de usuário indicada por <i> associada com o
     átomo <a> ou retorna `false' se "a" não tem a propriedade <i>.

     `get' avalia seus argumentos.

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]


 -- Função: join (<l>, <m>)
     Cria uma nova lista contendo os elementos das lista <l> e <m>,
     intercaladas.  O resultado tem os elementos `[<l>[1], <m>[1],
     <l>[2], <m>[2], ...]'.  As listas <l> e <m> podem conter qualquer
     tipo de elementos.

     Se as listas forem de diferentes comprimentos, `join' ignora
     elementos da lista mais longa.

     Maxima reclama se <l> ou <m> não for uma lista.

     Exemplos:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]


 -- Função: last (<expr>)
     Retorna a última parte (parcela, linha, elemento, etc.) de <expr>.


 -- Função: length (<expr>)
     Retorna (por padrão) o número de partes na forma externa
     (mostrada) de <expr>.  Para listas isso é o número de elementos,
     para matrizes isso é o número de linhas, e para adições isso é o
     número de parcelas (veja `dispform').

     O comando `length' é afetado pelo comutador `inflag'.  Então, e.g.
     `length(a/(b*c));' retorna 2 se `inflag' for `false' (Assumindo
     `exptdispflag' sendo `true'), mas 3 se `inflag' for `true' (A
     representação interna é essencialmente `a*b^-1*c^-1').


 -- Variável de opção: listarith
     Valor padrão: `true' - se `false' faz com que quaisquer
     operações aritméticas com listas sejam suprimidas; quando `true',
     operações lista-matriz são contagiosas fazendo com que listas
     sejam convertidas para matrizes retornando um resultado que é
     sempre uma matriz.  Todavia, operações lista-lista podem retornar
     listas.


 -- Função: listp (<expr>)
     Retorna `true' se <expr> for uma lista de outra forma retorna
     `false'.


 -- Função: makelist (<expr>, <i>, <i_0>, <i_1>)
 -- Função: makelist (<expr>, <x>, <list>)
     Constrói e retorna uma lista, cada elemento dessa lista é gerado
     usando <expr>.

     `makelist (<expr>, <i>, <i_0>, <i_1>)' retorna uma lista, o
     `j''ésimo elemento dessa lista é igual a `ev (<expr>, <i>=j)' para
     `j' variando de <i_0> até <i_1>.

     `makelist (<expr>, <x>, <list>)' retorna uma lista, o `j''ésimo
     elemento é igual a `ev (<expr>, <x>=<list>[j])' para `j' variando
     de 1 até `length (<list>)'.

     Exemplos:

          (%i1) makelist(concat(x,i),i,1,6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist(x=y,y,[a,b,c]);
          (%o2)                 [x = a, x = b, x = c]


 -- Função: member (<expr_1>, <expr_2>)
     Retorna `true' se `is(<expr_1> = <a>)' para algum elemento <a> em
     `args(<expr_2>)', de outra forma retorna `false'.

     `expr_2' é tipicamente uma lista, nesse caso `args(<expr_2>) =
     <expr_2>' e `is(<expr_1> = <a>)' para algum elemento <a> em
     `expr_2' é o teste.

     `member' não inspeciona partes dos argumentos de `expr_2', então
     `member' pode retornar `false' mesmo se `expr_1' for uma parte de
     algum argumento de `expr_2'.

     Veja também `elementp'.

     Exemplos:

          (%i1) member (8, [8, 8.0, 8b0]);
          (%o1)                         true
          (%i2) member (8, [8.0, 8b0]);
          (%o2)                         false
          (%i3) member (b, [a, b, c]);
          (%o3)                         true
          (%i4) member (b, [[a, b], [b, c]]);
          (%o4)                         false
          (%i5) member ([b, c], [[a, b], [b, c]]);
          (%o5)                         true
          (%i6) F (1, 1/2, 1/4, 1/8);
                                         1  1  1
          (%o6)                     F(1, -, -, -)
                                         2  4  8
          (%i7) member (1/8, %);
          (%o7)                         true
          (%i8) member ("ab", ["aa", "ab", sin(1), a + b]);
          (%o8)                         true


 -- Função: ninth (<expr>)
     Retorna o nono item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: rest (<expr>, <n>)
 -- Função: rest (<expr>)
     Retorna <expr> com seus primeiros <n> elementos removidos se <n>
     for positivo e seus últimos `- <n>' elementos removidos se <n> for
     negativo.  Se <n> for 1 isso pode ser omitido.  <expr> pode ser
     uma lista, matriz, ou outra expressão.


 -- Função: reverse (<list>)
     Ordem reversa para os membros de <list> (não os membros em si
     mesmos).  `reverse' também trabalha sobre expressões gerais, e.g.
     `reverse(a=b);' fornece `b=a'.


 -- Função: second (<expr>)
     Retorna o segundo item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: seventh (<expr>)
     Retorna o sétimo item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: sixth (<expr>)
     Retorna o sexto item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: sublist_indices (<L>, <P>)
     Retorna os índices dos elementos `x' da lista <L> para os quais o
     predicado `maybe(<P>(x))' retornar `true'; isso inclui `unknown'
     bem como `false'.  <P> pode ser um nome de função ou uma expressão
     lambda.  <L> deve ser uma lista literal.

     Exemplos:

          (%i1) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], lambda ([x], x='b));
          (%o1)                     [2, 3, 7, 9]
          (%i2) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], symbolp);
          (%o2)                  [1, 2, 3, 4, 7, 9]
          (%i3) sublist_indices ([1 > 0, 1 < 0, 2 < 1, 2 > 1, 2 > 0], identity);
          (%o3)                       [1, 4, 5]
          (%i4) assume (x < -1);
          (%o4)                       [x < - 1]
          (%i5) map (maybe, [x > 0, x < 0, x < -2]);
          (%o5)                [false, true, unknown]
          (%i6) sublist_indices ([x > 0, x < 0, x < -2], identity);
          (%o6)                          [2]


 -- Função: tenth (<expr>)
     Retorna o décimo item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: third (<expr>)
     Retorna o terceiro item da expressão ou lista <expr>.  Veja
     `first' para maiores detalhes.



File: maxima.info,  Node: Conjuntos,  Next: Definição de Função,  Prev: Listas,  Up: Top

38 Conjuntos
************

* Menu:

* Introdução a Conjuntos::
* Funções e Variáveis Definidas para Conjuntos::


File: maxima.info,  Node: Introdução a Conjuntos,  Next: Funções e Variáveis Definidas para Conjuntos,  Prev: Conjuntos,  Up: Conjuntos

38.1 Introdução a Conjuntos
===========================

Maxima fornece funções de conjunto, tais como intersecção e união, para
conjuntos finitos que são definidos por enumeração explícitamente.
Maxima trata listas e conjuntos como objetos distintos. Esse recurso
torna possível trabalhar com conjuntos que possuem elementos que são ou
listas ou conjuntos.

   Adicionalmente para funções de conjuntos finitos, Maxima fornece
algumas funoes relacionadas a análise combinatória; essas incluem os
números de Stirling de primero e de segundo tipo, os números de Bell,
coefincientes multinomiais, partições de inteiros não negativos, e umas
poucas outras.  Maxima também define uma função delta de Kronecker.

38.1.1 Utilização
-----------------

Para construir um conjunto com elementos `a_1, ..., a_n', escreva
`set(a_1, ..., a_n)' ou `{a_1, ..., a_n}'; para construir o conjunto
vazio, escreva `set()' ou `{}'.  Para inserção de dados, `set(...)' e
`{ ... }' são equivalentes.  Conjuntos são sempre mostrados entre
chaves (`{ ... }').

   Se um elemento é listado mais de uma vez, a simplificação elimina o
elemento redundante.

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

   Dois elementos <x> e <y> são redundantes (i.e., considerados o mesmo
para propósito de construção de conjuntos) se e somente se `is(<x> =
<y>)' retornar `true'.  Note que `is(equal(<x>, <y>))' pode retornar
`true' enquanto `is(<x> = <y>)' retorna `false'; nesse caso os
elementos <x> e <y> são considerados distintos.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) {x, y, z};
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

   Para construir um conjunto dos elementos de uma lista, use `setify'.

     (%i1) setify ([b, a]);
     (%o1)                        {a, b}

   Os elementos de conjuntos `x' e `y' são iguais fornecendo `is(x = y)'
avaliando para `true'. Dessa forma `rat(x)' e `x' são iguais como
elementos de conjuntos; conseqüentemente,

     (%i1) {x, rat(x)};
     (%o1)                          {x}

   Adicionalmente, uma vez que `is((x - 1)*(x + 1) = x^2 - 1)' avalia
para `false', `(x - 1)*(x + 1)' e `x^2 - 1' são distintos elementos de
conjunto; dessa forma

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

   Para reduzir esse conjunto a um conjunto simples, apliquemos `rat' a
cada elemeto do conjunto

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map (rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

   Para remover redundâncias de outros conjuntos, você pode precisar
usar outras funções de simplificação. Aqui está um exemplo que usa
`trigsimp':

     (%i1) {1, cos(x)^2 + sin(x)^2};
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map (trigsimp, %);
     (%o2)                          {1}

   Um conjunto esta'simplificado quando seus elementos não são
redundantes e o conjunto está ordenado. A versão corrente das funções
de conjunto usam a função do Máxima `orderlessp' para ordenar
conjuntos; odavia, versões futuras das funções de conjunto podem usar
uma função de ordenação diferente.

   Algumas operações sobre conjuntos, tais como substituições,
forçam automaticamente a uma re-simplificação; por exemplo,

     (%i1) s: {a, b, c}$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

   Maxima trata listas e conjuntos como objetos distintos; funções tais
como `union' e `intersection' reclamam se qualquer argumetno não for um
conjunto. se você precisar aplicar uma função de conjunto a uma lista,
use a função `setify' para converter essa lsita para um conjunto. dessa
forma

     (%i1) union ([1, 2], {a, b});
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), {a, b});
     (%o2)                     {1, 2, a, b}

   Para extrair todos os elemetnos de conjunto de um conjunto `s' que
satisfazem um predicado `f', use `subset(s, f)'. (Um predicado é um uma
função que avalia para os valores booleanos `true'/`false'.) Por
exemplo, para encontrar as equações em um dado conjunto que não depende
de uma variável `z', use

     (%i1) subset ({x + y + z, x - y + 4, x + y - 5}, lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

   A seção *Note Funções e Variáveis Definidas para Conjuntos:: passui
uma lista completa das funções de conjunto no Maxima.

38.1.2 Iterações entre Elementos de Conjuntos
---------------------------------------------

Existem dois camainhos para fazer iterações sobre elementos de
conjuntos. Um caminho é usar `map'; por exemplo:

     (%i1) map (f, {a, b, c});
     (%o1)                  {f(a), f(b), f(c)}

   O outro caminho é usar `for <x> in <s> do'

     (%i1) s: {a, b, c};
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

   A função Maxima `first' e `rest' trabalham atualmente sobre
conjuntos. Aplicada a um conjunto, `first' retorna o primeiro elemento
mostrado de um conjunto; qual élemento que é mostrado pode ser
dependente da implementação. Se `s' for um conjunto, então `rest(s)' é
equivalente a `disjoin(first(s), s)'.  Atualmente, existem outras
funções do Maxima que trabalham corretamente sobre conjuntos.  Em
futuras versões das funções de conjunto, `first' e `rest' podem vir a
funcionar diferentemente ou não completamente.

38.1.3 Erros
------------

As funções de conjunto usam a função Maxima `orderlessp' para organizar
os elementos de cum conjunto e a função (a nível de Lisp) `like' para
testar a igualdade entre elementos de conjuntos. Ambas essas funções
possuem falhas conhecidas que podem se manifestar se você tentar usar
conjuntos com elementos que são listas ou matrizes que contenham
expressões na forma racional canônica (CRE). Um exemplo é

     (%i1) {[x], [rat (x)]};
     Maxima encountered a Lisp error:

       The value #:X1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Essa expressão faz com que o Maxima fique exitante com um erro (a
mensagem de erro depende de qual a versão do Lisp seu Maxima está
usando). Outro exemplo é

     (%i1) setify ([[rat(a)], [rat(b)]]);
     Maxima encountered a Lisp error:

       The value #:A1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Essas falhas são causadas por falhas em `orderlessp' e `like'; elas
não são caudadas por falhas nas funções de conjunto. Para ilustrar,
tente as expressões

     (%i1) orderlessp ([rat(a)], [rat(b)]);
     Maxima encountered a Lisp error:

       The value #:B1441 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.
     (%i2) is ([rat(a)] = [rat(a)]);
     (%o2)                         false

   Até que essas falhas sejam corrigidas, não construa conjuntos com
com elementos que sejam listas ou matrizes contendo expressões na forma
racional canônica (CRE); um conjunto com um elemento na forma CRE,
todavia, pode não ser um problema:

     (%i1) {x, rat (x)};
     (%o1)                          {x}

   A `orderlessp' do Maxima possui outra falha que pode causr problemas
com funções de conjunto, sabidamente o predicado de ordenação
`orderlessp' é não transitivo. o mais simples exemplo conhecido que
mostra isso é

     (%i1) q: x^2$
     (%i2) r: (x + 1)^2$
     (%i3) s: x*(x + 2)$
     (%i4) orderlessp (q, r);
     (%o4)                         true
     (%i5) orderlessp (r, s);
     (%o5)                         true
     (%i6) orderlessp (q, s);
     (%o6)                         false

   Essa falha pode causar problemas com todas as funções de conjutno
bem como com funções Maxima em geral. É provável, mas não certo, que
essa falha possa ser evitada se todos os elementos do conjunto
estiverem ou na forma CRE ou tiverem sido simplificado usando `ratsimp'.

   Os mecanismos `orderless' e `ordergreat' do Maxima são incompatíveis
com as funções de conjunto. Se você rpecisar usar ou `orderless' ou
`ordergreat', chame todas essas funções antes de construir quaisquer
conjuntos, e não chame `unorder'.

   Se você encontrar alguma coisa que você pense ser uma falha em
alguma funçõ de conjunto, por favor relate isso para a base de dados de
falhas do Maxima. Veja `bug_report'.

38.1.4 Autores
--------------

Stavros Macrakis de Cambridge, Massachusetts e Barton Willis da
Universidade e Nebraska e Kearney (UNK) escreveram as fnções de
conjunto do Maxima e sua documentação.


File: maxima.info,  Node: Funções e Variáveis Definidas para Conjuntos,  Prev: Introdução a Conjuntos,  Up: Conjuntos

38.2 Funções e Variáveis Definidas para Conjuntos
=================================================

 -- Função: adjoin (<x>, <a>)
     Retorna a união do conjunto <a> com `{<x>}'.

     `adjoin' reclama se <a> não for um conjunto literal.

     `adjoin(<x>, <a>)' e `union(set(<x>), <a>)' são equivalentes;
     todavia, `adjoin' pode ser um pouco mais rápida que `union'.

     Veja também `disjoin'.

     Exemplos:

          (%i1) adjoin (c, {a, b});
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, {a, b});
          (%o2)                        {a, b}


 -- Função: belln (<n>)
     Representa o n-ésimo número de Bell number.  `belln(n)' é o número
     de partições de um conjunto <n> elementos.

     Para inteiros não negativos <n>, `belln(<n>)' simplifica para o
     n-ésimo número de Bell.  `belln' não simplifica para qualquer
     outro tipo de argumento.

     `belln' distribui sobre equações, listas, matrizes e conjuntos.

     Exemplos:

     `belln' aplicado a inteiros não negativos.

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions ({})) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) = belln (6));
          (%o3)                         true

     `belln' aplicado a argumentos que não são inteiros não negativos.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]


 -- Função: cardinality (<a>)
     Retorna o número de elementos distintos do conjunto <a>.

     `cardinality' ignora elementos redundantes mesmo quando a
     simplificação está dessabilitada.

     Exemplos:

          (%i1) cardinality ({});
          (%o1)                           0
          (%i2) cardinality ({a, a, b, c});
          (%o2)                           3
          (%i3) simp : false;
          (%o3)                         false
          (%i4) cardinality ({a, a, b, c});
          (%o4)                           3


 -- Função: cartesian_product (<b_1>, ... , <b_n>)
     Retorna um conjunto de listas da forma `[<x_1>, ..., <x_n>]', onde
     <x_1>, ..., <x_n> são elementos dos conjuntos <b_1>, ... , <b_n>,
     respectivamente.

     `cartesian_product' reclama se qualquer argumento não for um
     conjunto literal.

     Exemplos:

          (%i1) cartesian_product ({0, 1});
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product ({0, 1}, {0, 1});
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product ({x}, {y}, {z});
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product ({x}, {-1, 0, 1});
          (%o4)              {[x, - 1], [x, 0], [x, 1]}

 -- Função: disjoin (<x>, <a>)
     Retorna o conjunto <a> sem o elemento <x>.  Se <x> não for um
     elemento de <a>, retorna <a> sem modificações.

     `disjoin' reclama se <a> não for um conjunto literal.

     `disjoin(<x>, <a>)', `delete(<x>, <a>)', e `setdifference(<a>,
     set(<x>))' são todos equivalentes.  Desses, `disjoin' é geralmente
     mais rápido que os outros.

     Exemplos:

          (%i1) disjoin (a, {a, b, c, d});
          (%o1)                       {b, c, d}
          (%i2) disjoin (a + b, {5, z, a + b, %pi});
          (%o2)                      {5, %pi, z}
          (%i3) disjoin (a - b, {5, z, a + b, %pi});
          (%o3)                  {5, %pi, b + a, z}


 -- Função: disjointp (<a>, <b>)
     Retorna `true' se e somente se os conjuntos <a> e <b> forem
     disjuntos.

     `disjointp' reclama se ou <a> ou <b> não forem conjuntos literais.

     Exemplos:

          (%i1) disjointp ({a, b, c}, {1, 2, 3});
          (%o1)                         true
          (%i2) disjointp ({a, b, 3}, {1, 2, 3});
          (%o2)                         false


 -- Função: divisors (<n>)
     Representa o conjunto dos divisores de <n>.

     `divisors(<n>)' simplifica para um conjunto de inteiros quando <n>
     for um inteiro não nulo.  O cojunto dos divisores inclui os
     elementos 1 e <n>.  Os divisores de um inteiro negativo são os
     divisores de seu valor absoluto.

     `divisors' distribui sobre equações, listas, matrizes, e conjuntos.

     Exemplos:

     Podemos verificar que 28 é um número perfeito: a adição de seus
     divisores (exceto o próprio 28) é 28.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     `divisors' é uma função de simplificação.  Substituindo 8 por `a'
     em `divisors(a)' retorna os divisores sem fazer a reavaliação de
     `divisors(8)'.

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     `divisors' distribui sobre equações, listas, matrizes, e conjuntos.

          (%i1) divisors (a = b);
          (%o1)               divisors(a) = divisors(b)
          (%i2) divisors ([a, b, c]);
          (%o2)        [divisors(a), divisors(b), divisors(c)]
          (%i3) divisors (matrix ([a, b], [c, d]));
                            [ divisors(a)  divisors(b) ]
          (%o3)             [                          ]
                            [ divisors(c)  divisors(d) ]
          (%i4) divisors ({a, b, c});
          (%o4)        {divisors(a), divisors(b), divisors(c)}

 -- Função: elementp (<x>, <a>)
     Retorna `true' se e somente se <x> for um elemento do conjunto <a>.

     `elementp' reclama se <a> não for um conjunto literal.

     Exemplos:

          (%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
          (%o1)                         true
          (%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
          (%o2)                         false


 -- Função: emptyp (<a>)
     Retorna `true' se e somente se <a> for o conjunto vazio ou a lista
     vazia.

     Exemplos:

          (%i1) map (emptyp, [{}, []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, {{}}, %pi]);
          (%o2)                 [false, false, false]

 -- Função: equiv_classes (<s>, <F>)
     Retorna um conjunto das classes de equivalências do conjunto <s>
     com relação à relação de equivalência <F>.

     <F> é uma função de duas variáveis definida sobre o produto
     cartesiano <s> por <s>.  O valor de retorno de <F> é ou `true' ou
     `false', ou uma expressão <expr> tal que `is(<expr>)' é ou `true'
     ou `false'.

     Quando <F> nõ for um relação de equivalência, `equiv_classes'
     aceita sem reclamação, mas o resultado é geralmente incorreto
     nesse caso.

     Exemplos:

     A relação de equivalência é uma expressão lambda a qual retorna
     `true' ou `false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, lambda ([x, y], is (equal (x, y))));
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     A relação de equivalência é o nome de uma função relacional que
     avalia para `true' ou `false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     As classes de equivalência são números que diferem por um multiplo
     de 3.

          (%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7}, lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}

 -- Função: every (<f>, <s>)
 -- Função: every (<f>, <L_1>, ..., <L_n>)
     Retorna `true' se o predicado <f> for `true' para todos os
     argumentos fornecidos.

     Dado um conjunto como sgundo argumento, `every(<f>, <s>)' retorna
     `true' se `is(<f>(<a_i>))' retornar `true' para todos os <a_i> em
     <s>.  `every' pode ou não avaliar <f> para todos os <a_i> em <s>.
     Uma vez que conjuntos são desordenados, `every' pode avaliar
     `<f>(<a_i>)' em qualquer ordem.

     Dada uma ou mais listas como argumentos, `every(<f>, <L_1>, ...,
     <L_n>)' retorna `true' se `is(<f>(<x_1>, ..., <x_n>))' retornar
     `true' para todos os <x_1>, ..., <x_n> em <L_1>, ..., <L_n>,
     respectivamente.  `every' pode ou não avaliar <f> para toda
     combinação <x_1>, ..., <x_n>.  `every' avalia listas na ordem de
     incremento do índice.

     Dado um conjunto vazio `{}' ou uma lista vazia `[]' como
     argumentos, `every' retorna `false'.

     Quando o sinalizador global `maperror' for `true', todas as listas
     <L_1>, ..., <L_n> devem ter o mesmo comprimento.  Quando
     `maperror' for `false', argumentos listas são efetivamente
     truncados para o comprimento da menor lista.

     Retorna valores do predicado <f> que avaliam (via `is') para
     alguma coisa outra que não `true' ou `false' são governados
     através do sinalizador global `prederror'.  Quando `prederror' for
     `true', tais valores são tratados como `false', e o valor de
     retorno de `every' é `false'.  Quando `prederror' for `false',
     tais valores são tratados como `unknown', e o valor de retorno de
     `every' é `unknown'.

     Exemplos:

     `every' aplicada a um conjunto simples.  O predicado é uma
     função de um argumento.

          (%i1) every (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         false

     `every' aplicada a duas listas.  O predicado é uma função de dois
     argumentos.

          (%i1) every ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) every ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Retorna valores do predicado <f> que avalia para alguma coisa
     outra que não `true' ou `false' são governados por meio do
     sinalizador global `prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) prederror : true;
          (%o4)                         true
          (%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o5)                         false


 -- Função: extremal_subset (<s>, <f>, max)
 -- Função: extremal_subset (<s>, <f>, min)
     Retorna o subconjunto de <s> para o qual a função <f> toma valore
     máximos ou mínimos.

     `extremal_subset(<s>, <f>, max)' retorna o subconjunto do conjunto
     ou lista <s> para os quais a função real <f> assume valor maximo.

     `extremal_subset(<s>, <f>, min)' retorna o subconjuno do conjunto
     ou lista <s> para a qual a função real <f> assume valor mínimo.

     Exemplos:

          (%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
          (%o2)                       {sqrt(2)}

 -- Função: flatten (<expr>)
     Recebe argumentos de subexpressões que possuem o mesmo operator
     como <expr> e constrói uma expressão a partir desses argumentos
     coletados.

     subexpressões nas quais o operador é diferente do operador
     principal de `expr' são copiadas sem modificação, mesmo se elas,
     in turn, contiverem a mesma subexpressão na qual o operador seja o
     mesmo que em `expr'.

     Pode ser possível para `flatten' construir expressões nas quais o
     número de argumentos difira dos argumentos declarados para um
     operador; isso pode provocar uma mensagem de erro do simplificador
     ou do avaliador.  `flatten' não tenta detectar tais situações.

     Expressões com representações especiais, por exemplo, expressãoes
     racionais canônicas (CRE), não podem usar a função `flatten';
     nesses casos, `flatten' retorna seus argumentos sem modificação.

     Exemplos:

     Aplicado a uma lista, `flatten' reune todos os elementos de lista
     que são listas.

          (%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
          (%o1)            [a, b, c, d, e, f, g, h, i, j]

     Aplicado a um conjunto, `flatten' reune todos os elementos de
     conjunto que são conjuntos.

          (%i1) flatten ({a, {b}, {{c}}});
          (%o1)                       {a, b, c}
          (%i2) flatten ({a, {[a], {a}}});
          (%o2)                       {a, [a]}

     `flatten' é similar ao efeito de declarar o operador principal
     para ser enário.  Todavia, `flatten' não faz efeito sobre
     subexpressões que possuem um operador diferente do operador
     principal, enquanto uma declaração enária faz efeito.

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     `flatten' trata funções subscritas da mesma forma que qualquer
     outro operador.

          (%i1) flatten (f[5] (f[5] (x, y), z));
          (%o1)                      f (x, y, z)
                                      5

     Pode ser possível para `flatten' construir expressões nas quais o
     número de argumentos difira dos argumentos declarados  para um
     operador;

          (%i1) 'mod (5, 'mod (7, 4));
          (%o1)                   mod(5, mod(7, 4))
          (%i2) flatten (%);
          (%o2)                     mod(5, 7, 4)
          (%i3) ''%, nouns;
          Wrong number of arguments to mod
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Função: full_listify (<a>)
     Substitui todo oeradr de conjutno em <a> por um operadro de lista,
     e retorna o resultado.  `full_listify' substitui operadores de
     conjunto em subexpressões restantes, mesmo se o operadro principal
     não for conjunto (`set').

     `listify' substitui somente o operador principal.

     Exemplos:

          (%i1) full_listify ({a, b, {c, {d, e, f}, g}});
          (%o1)               [a, b, [c, [d, e, f], g]]
          (%i2) full_listify (F (G ({a, b, H({c, d, e})})));
          (%o2)              F(G([a, b, H([c, d, e])]))


 -- Função: fullsetify (<a>)
     Quando <a> for uma lista, substitui o operador de lista por um
     operador de conjunto, e aplica `fullsetify' a cada elemento que
     for um conjunto.  Quando <a> não for uma lista, essa não lista é
     retornada em sua forma original e sem modificações.

     `setify' substitui somente o operador principal.

     Exemplos:

     Na linha (%o2), o argumento de `f' não é convertido para um
     conjunto porque o operador principal de `f([b])' não é uma lista.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}


 -- Função: identity (<x>)
     Retorna <x> para qualquer argumento <x>.

     Exemplos:

     `identity' pode ser usado como um predicado quando os argumentos
     forem  valores Booleanos.

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Função: integer_partitions (<n>)
 -- Função: integer_partitions (<n>, <len>)
     Retorna partições inteiras de <n>, isto é, listas de inteiros cuja
     soma dos elementos de cada lista é <n>.

     `integer_partitions(<n>)' retorna o conjunto de todas as
     partições do inteiro <n>.  Cada partição é uma lista ordenada do
     maior para o menor.

     `integer_partitions(<n>, <len>)' retorna todas as partições que
     possuem comprimento <len> ou menor; nesse caso, zeros são anexado
     ao final de cada partição de comprimento menor que <len> terms to
     make each partition have exactly <len> terms.  Each partition is a
     list sorted from greatest to least.

     Uma lista [a_1, ..., a_m] é uma partição de inteiros não negativos
     n quando (1) cada a_i é um inteiro não nulo, e (2) a_1 + ... + a_m
     = n. Dessa forma 0 não tem partiçãoes.

     Exemplos:

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     Para encontrar todas as partições que satisfazem uma condição, use
     a função `subset'; aqui está um exemplo que encontra todas as
     partições de 10 cujos elementos da lista são números primos.

          (%i1) s: integer_partitions (10)$
          (%i2) cardinality (s);
          (%o2)                          42
          (%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i4) subset (s, lambda ([x], every (xprimep, x)));
          (%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}


 -- Função: intersect (<a_1>, ..., <a_n>)
     `intersect' é o mesmo que `intersection', como veremos.


 -- Função: intersection (<a_1>, ..., <a_n>)
     Retorna um conjunto contendo os elementos que são comuns aos
     conjuntos <a_1> até <a_n>.

     `intersection' reclama se qualquer argumento não for um conjunto
     literal.

     Exemplos:

          (%i1) S_1 : {a, b, c, d};
          (%o1)                     {a, b, c, d}
          (%i2) S_2 : {d, e, f, g};
          (%o2)                     {d, e, f, g}
          (%i3) S_3 : {c, d, e, f};
          (%o3)                     {c, d, e, f}
          (%i4) S_4 : {u, v, w};
          (%o4)                       {u, v, w}
          (%i5) intersection (S_1, S_2);
          (%o5)                          {d}
          (%i6) intersection (S_2, S_3);
          (%o6)                       {d, e, f}
          (%i7) intersection (S_1, S_2, S_3);
          (%o7)                          {d}
          (%i8) intersection (S_1, S_2, S_3, S_4);
          (%o8)                          {}


 -- Função: kron_delta (<x>, <y>)
     Representa a função delta de Kronecker.

     `kron_delta' simplifica para 1 quando <x> e <y> forem identicos ou
     demonstadamente equivalentes, e simplifica para 0 quando <x> e <y>
     demonstradamente não equivalentes.  De outra forma, se não for
     certo que <x> e <y> são equivalentes, e `kron_delta' simplifica
     para uma expressão substantiva.  `kron_delta' implementa uma
     política de segurança para expressões em ponto flutuante: se a
     diferença `<x> - <y>' for um número em ponto flutuante,
     `kron_delta' simplifica para uma expressão substantiva quando <x>
     for aparentemente equivalente a <y>.

     Specificamente, `kron_delta(<x>, <y>)' simplifica para 1 quando
     `is(x = y)' for `true'.  `kron_delta' também simplifica para 1
     quando `sign(abs(<x> - <y>))' for `zero' e `<x> - <y>' não for um
     número em ponto flutuante (e também não for um número de precisão
     simples em ponto flutuante e também não for um número de precisão
     dupla em poto flutuante, isto é, não for um bigfloat).
     `kron_delta' simplifica para 0 quando `sign(abs(<x> - <y>))' for
     `pos'.

     De outra forma, `sign(abs(<x> - <y>))' é alguma coisa outra que
     não `pos' ou `zero', ou se for `zero' e `<x> - <y>' for umnúmero
     em ponto flutuante.  Nesses casos, `kron_delta' retorna um
     expressão substantiva.

     `kron_delta' é declarada para ser simétrica.  Isto é,
     `kron_delta(<x>, <y>)' é igual a `kron_delta(<y>, <x>)'.

     Exemplos:

     Os argumentos de `kron_delta' são identicos.  `kron_delta'
     simplifica para 1.

          (%i1) kron_delta (a, a);
          (%o1)                           1
          (%i2) kron_delta (x^2 - y^2, x^2 - y^2);
          (%o2)                           1
          (%i3) float (kron_delta (1/10, 0.1));
          (%o3)                           1

     Os argumentos de `kron_delta' são equivalentes, e a diferença
     entre eles não é um número em ponto flutuante.  `kron_delta'
     simplifica para 1.

          (%i1) assume (equal (x, y));
          (%o1)                     [equal(x, y)]
          (%i2) kron_delta (x, y);
          (%o2)                           1

     Os argumentos de `kron_delta' não são equivalentes.  `kron_delta'
     simplifica para 0.

          (%i1) kron_delta (a + 1, a);
          (%o1)                           0
          (%i2) assume (a > b)$
          (%i3) kron_delta (a, b);
          (%o3)                           0
          (%i4) kron_delta (1/5, 0.7);
          (%o4)                           0

     Os argumentos de `kron_delta' podem ou não serem equivalentes.
     `kron_delta' simplifica para uma expressão substantiva.

          (%i1) kron_delta (a, b);
          (%o1)                   kron_delta(a, b)
          (%i2) assume(x >= y)$
          (%i3) kron_delta (x, y);
          (%o3)                   kron_delta(x, y)

     Os argumentos de `kron_delta' são equivalentes, mas a
     diferença entre eles é um número em ponto flutuante.  `kron_delta'
     simplifica para uma expressão substantiva.

          (%i1) 1/4 - 0.25;
          (%o1)                          0.0
          (%i2) 1/10 - 0.1;
          (%o2)                          0.0
          (%i3) 0.25 - 0.25b0;
          Warning:  Float to bigfloat conversion of 0.25
          (%o3)                         0.0b0
          (%i4) kron_delta (1/4, 0.25);
                                            1
          (%o4)                  kron_delta(-, 0.25)
                                            4
          (%i5) kron_delta (1/10, 0.1);
                                            1
          (%o5)                  kron_delta(--, 0.1)
                                            10
          (%i6) kron_delta (0.25, 0.25b0);
          Warning:  Float to bigfloat conversion of 0.25
          (%o6)               kron_delta(0.25, 2.5b-1)

     `kron_delta' é simétrica.

          (%i1) kron_delta (x, y);
          (%o1)                   kron_delta(x, y)
          (%i2) kron_delta (y, x);
          (%o2)                   kron_delta(x, y)
          (%i3) kron_delta (x, y) - kron_delta (y, x);
          (%o3)                           0
          (%i4) is (equal (kron_delta (x, y), kron_delta (y, x)));
          (%o4)                         true
          (%i5) is (kron_delta (x, y) = kron_delta (y, x));
          (%o5)                         true


 -- Função: listify (<a>)
     Retorna uma lista contendo os elementos de <a> quando <a> for um
     conjunto.  De outra forma, `listify' retorna <a>.

     `full_listify' substitui todos os operadores de conjunto em <a>
     por operadores de lista.

     Exemplos:

          (%i1) listify ({a, b, c, d});
          (%o1)                     [a, b, c, d]
          (%i2) listify (F ({a, b, c, d}));
          (%o2)                    F({a, b, c, d})


 -- Função: lreduce (<F>, <s>)
 -- Função: lreduce (<F>, <s>, <s_0>)
     Extende a função de dois operadores <F> para uma função de `n'
     operadores usando composição, onde <s> é uma lista.

     `lreduce(<F>, <s>)' returns `F(... F(F(s_1, s_2), s_3), ... s_n)'.
     Quando o argumento opcional <s_0> estiver presente, o resultado é
     equivalente a `lreduce(<F>, cons(<s_0>, <s>))'.

     A função <F> é primeiramente aplicada à lista de elementos
     leftmost - mais à esquerda, daí o nome "lreduce".

     Veja também `rreduce', `xreduce', e `tree_reduce'.

     Exemplos:

     `lreduce' sem o argumento opcional.

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     `lreduce' com o argumento opcional.

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     `lreduce' aplicada a operadores de dois argumentos internos (já
     definidos por padrão) do Maxima.  `/' é o operador de divisão.

          (%i1) lreduce ("^", args ({a, b, c, d}));
                                         b c d
          (%o1)                       ((a ) )
          (%i2) lreduce ("/", args ({a, b, c, d}));
                                          a
          (%o2)                         -----
                                        b c d


 -- Função: makeset (<expr>, <x>, <s>)
     Retorna um conjunto com elementos gerados a partir da expressão
     <expr>, onde <x> é uma lista de variáveis em <expr>, e <s>é um
     conjunto ou lista de listas.  Para gerar cada elemento do conjunto,
     <expr> é avaliada com as variáveis <x> paralelamente a um elemento
     de <s>.

     Cada elemento de <s> deve ter o mesmo comprimento que <x>.  A
     lista de variáveis <x> deve ser uma lista de símbolos, sem
     subscritos.  Mesmo se existir somente um símbolo, <x> deve ser uma
     lista de um elemento, e cada elemento de <s> deve ser uma lista de
     um elemento.

     Veja também `makelist'.

     Exemplos:

          (%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                                     1  2  3  4
          (%o1)                     {-, -, -, -}
                                     a  b  c  d
          (%i2) S : {x, y, z}$
          (%i3) S3 : cartesian_product (S, S, S);
          (%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y],
          [x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x],
          [y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z],
          [y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y],
          [z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x],
          [z, z, y], [z, z, z]}
          (%i4) makeset (i + j + k, [i, j, k], S3);
          (%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x,
                                                 z + 2 y, 2 z + x, 2 z + y}
          (%i5) makeset (sin(x), [x], {[1], [2], [3]});
          (%o5)               {sin(1), sin(2), sin(3)}

 -- Função: moebius (<n>)
     Representa a função de Moebius.

     Quando <n> for o produto de k primos distintos, `moebius(<n>)'
     simplifica para (-1)^k; quando <n> = 1, simplifica para 1; e
     simplifica para 0 para todos os outros inteiros positivos.

     `moebius' distribui sobre equações, listas, matrizes, e conjuntos.

     Exemplos:

          (%i1) moebius (1);
          (%o1)                           1
          (%i2) moebius (2 * 3 * 5);
          (%o2)                          - 1
          (%i3) moebius (11 * 17 * 29 * 31);
          (%o3)                           1
          (%i4) moebius (2^32);
          (%o4)                           0
          (%i5) moebius (n);
          (%o5)                      moebius(n)
          (%i6) moebius (n = 12);
          (%o6)                    moebius(n) = 0
          (%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
          (%o7)                      [- 1, 1, 1]
          (%i8) moebius (matrix ([11, 12], [13, 14]));
                                     [ - 1  0 ]
          (%o8)                      [        ]
                                     [ - 1  1 ]
          (%i9) moebius ({21, 22, 23, 24});
          (%o9)                      {- 1, 0, 1}


 -- Função: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Função: multinomial_coeff ()
     Retorna o coeficiente multinomial.

     Quando cada <a_k> for um inteiro não negativo, o coeficiente
     multinomial fornece o número de formas possíveis de colocar `<a_1>
     + ... + <a_n>' objetos distintos em n caixas com <a_k> elementos na
     k'ésima caixa. Em geral, `multinomial_coeff (<a_1>, ..., <a_n>)'
     avalia para `(<a_1> + ... + <a_n>)!/(<a_1>! ... <a_n>!)'.

     `multinomial_coeff()' (sem argumentos) avalia para 1.

     `minfactorial' pode estar apta a simplificar o valor retornado por
     `multinomial_coeff'.

     Exemplos:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10

 -- Função: num_distinct_partitions (<n>)
 -- Função: num_distinct_partitions (<n>, list)
     Retorna o n;umero de partições de inteiros distintos de <n> quando
     <n> for um inteiro não negativo.  De outra forma,
     `num_distinct_partitions' retorna uma expressão substantiva.

     `num_distinct_partitions(<n>, list)' retorna uma lista do número
     de partições distintas de 1, 2, 3, ..., <n>.

     Uma partição distinta de <n> é uma lista de inteiros positivos
     distintos k_1, ..., k_m tais que <n> = k_1 + ... + k_m.

     Exemplos:

          (%i1) num_distinct_partitions (12);
          (%o1)                          15
          (%i2) num_distinct_partitions (12, list);
          (%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
          (%i3) num_distinct_partitions (n);
          (%o3)              num_distinct_partitions(n)


 -- Função: num_partitions (<n>)
 -- Função: num_partitions (<n>, list)
     Retorna o número das partições inteiras de <n> quando <n> for um
     inteiro não negativo.  De outra forma, `num_partitions' retorna
     uma expressão substantiva.

     `num_partitions(<n>, list)' retorna uma lista do número de
     partições inteiras de 1, 2, 3, ..., <n>.

     Para um inteiro não negativo <n>, `num_partitions(<n>)' é igual a
     `cardinality(integer_partitions(<n>))'; todavia, `num_partitions'
     não constrói atualmente o conjunto das partições, nesse sentido
     `num_partitions' é mais rápida.

     Exemplos:

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)


 -- Função: partition_set (<a>, <f>)
     Partições do conjunto <a> que satisfazem o predicado <f>.

     `partition_set' retorna uma lista de dois conjuntos.  O primeiro
     conjunto compreende os elementos de <a> para os quais <f> avalia
     para `false', e o segundo conjunto compreende quaisquer outros
     elementos de <a>.  `partition_set' não aplica `is' ao valor de
     retorno de <f>.

     `partition_set' reclama se <a> não for um conjunto literal.

     Veja também `subset'.

     Exemplos:

          (%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set ({x, rat(y), rat(y) + z, 1}, lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]

 -- Função: permutations (<a>)
     Retorna um conjunto todas as permutações distintas dos elementos da
     lista ou do conjunto <a>. Cada permutação é uma lista, não um
     conjunto.

     Quando <a> for uma lista, elementos duplicados de <a> são incluídos
     nas permutações.

     `permutations' reclama se <a> não for um conjunto literal ou uma
     lista literal.

     Veja também `random_permutation'.

     Exemplos:

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}


 -- Função: powerset (<a>)
 -- Função: powerset (<a>, <n>)
     Retorna o conjunto de todos os dubconjuntos de <a>, ou um
     subconjunto de <a>.

     `powerset(<a>)' retorna o conjunto de todos os subconjuntos do
     conjunto <a>.  `powerset(<a>)' tem `2^cardinality(<a>)' elementos.

     `powerset(<a>, <n>)' retorna o conjunto de todos os subconjuntos
     de <a> que possuem cardinalidade <n>.

     `powerset' reclama se <a> não for um conjunto literal, ou se <n>
     não for um inteiro não negativo.

     Exemplos:

          (%i1) powerset ({a, b, c});
          (%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
          (%i2) powerset ({w, x, y, z}, 4);
          (%o2)                    {{w, x, y, z}}
          (%i3) powerset ({w, x, y, z}, 3);
          (%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
          (%i4) powerset ({w, x, y, z}, 2);
          (%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
          (%i5) powerset ({w, x, y, z}, 1);
          (%o5)                 {{w}, {x}, {y}, {z}}
          (%i6) powerset ({w, x, y, z}, 0);
          (%o6)                         {{}}


 -- Função: random_permutation (<a>)
     Retorna uma permutação aleatória do conjunto ou da lista <a>, como
     construído pelo algorítimo de embaralhar desenvolvido por Knuth.

     O valor de retorno é uma nova lista, que é diferente da
     lista/conjunto original podendo inclusive ser a propria lista
     repetida.  Todavia, os elementos do argumento não são copiados.

     Exemplos:

          (%i1) random_permutation ([a, b, c, 1, 2, 3]);
          (%o1)                  [c, 1, 2, 3, a, b]
          (%i2) random_permutation ([a, b, c, 1, 2, 3]);
          (%o2)                  [b, 3, 1, c, a, 2]
          (%i3) random_permutation ({x + 1, y + 2, z + 3});
          (%o3)                 [y + 2, z + 3, x + 1]
          (%i4) random_permutation ({x + 1, y + 2, z + 3});
          (%o4)                 [x + 1, y + 2, z + 3]


 -- Função: rreduce (<F>, <s>)
 -- Função: rreduce (<F>, <s>, <s_{n + 1}>)
     Extende a função de dois argumentos <F> para uma função de <n>
     argumentos usando composição de funções, onde <s> é uma lista.

     `rreduce(<F>, <s>)' retorna `F(s_1, ... F(s_{n - 2}, F(s_{n - 1},
     s_n)))'.  Quando o argumetno opcional <s_{n + 1}> estiver presente,
     o resultado é equivalente a `rreduce(<F>, endcons(<s_{n + 1}>,
     <s>))'.

     A função <F> é primeiro aplicada à lista de elementos mais à
     direita - rightmost, daí o nome "rreduce".

     Veja também `lreduce', `tree_reduce', e `xreduce'.

     Exemplos:

     `rreduce' sem o argumento opcional.

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     `rreduce' com o argumetno opcional.

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     `rreduce' aplicada a operadores de dois argumentos internos (
     definidos por padrão) ao Maxima.  `/' é o operadro de divisão.

          (%i1) rreduce ("^", args ({a, b, c, d}));
                                           d
                                          c
                                         b
          (%o1)                         a
          (%i2) rreduce ("/", args ({a, b, c, d}));
                                         a c
          (%o2)                          ---
                                         b d


 -- Função: setdifference (<a>, <b>)
     Retorna um conjunto contendo os elementos no conjunto <a> que não
     estãono conjunto <b>.

     `setdifference' reclama se ou <a> ou <b> não for um conjunto
     literal.

     Exemplos:

          (%i1) S_1 : {a, b, c, x, y, z};
          (%o1)                  {a, b, c, x, y, z}
          (%i2) S_2 : {aa, bb, c, x, y, zz};
          (%o2)                 {aa, bb, c, x, y, zz}
          (%i3) setdifference (S_1, S_2);
          (%o3)                       {a, b, z}
          (%i4) setdifference (S_2, S_1);
          (%o4)                     {aa, bb, zz}
          (%i5) setdifference (S_1, S_1);
          (%o5)                          {}
          (%i6) setdifference (S_1, {});
          (%o6)                  {a, b, c, x, y, z}
          (%i7) setdifference ({}, S_1);
          (%o7)                          {}


 -- Função: setequalp (<a>, <b>)
     Retorna `true' se os conjuntos <a> e <b> possuirem o mesmo número
     de elementos e `is(<x> = <y>)' for `true' para `x' nos elementos
     de <a> e `y' nos elementos de <b>, considerados na ordem
     determinada por `listify'.  De outra forma, `setequalp' retorna
     `false'.

     Exemplos:

          (%i1) setequalp ({1, 2, 3}, {1, 2, 3});
          (%o1)                         true
          (%i2) setequalp ({a, b, c}, {1, 2, 3});
          (%o2)                         false
          (%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
          (%o3)                         false


 -- Função: setify (<a>)
     Constrói um conjunto de elementos a partir da lista <a>. Elementos
     duplicados da lista <a> são apagados e os elementos são ordenados
     de acordo com o predicado `orderlessp'.

     `setify' reclama se <a> não for uma lista literal.

     Exemplos:

          (%i1) setify ([1, 2, 3, a, b, c]);
          (%o1)                  {1, 2, 3, a, b, c}
          (%i2) setify ([a, b, c, a, b, c]);
          (%o2)                       {a, b, c}
          (%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
          (%o3)                {1, 3, 5, 7, 9, 11, 13}


 -- Função: setp (<a>)
     Retorna `true' se e somente se <a> for um conjunto na
     interpretação do Maxima.

     `setp' retorna `true' para conjuntos não simplificados (isto é,
     conjuntos com elementos redundantes) e também para conjuntos
     simplificados.

     `setp' é equivalente à função do Maxima `setp(a) := not atom(a)
     and op(a) = 'set'.

     Exemplos:

          (%i1) simp : false;
          (%o1)                         false
          (%i2) {a, a, a};
          (%o2)                       {a, a, a}
          (%i3) setp (%);
          (%o3)                         true


 -- Função: set_partitions (<a>)
 -- Função: set_partitions (<a>, <n>)
     Retorna o conjunto de todas as partições de <a>, ou um subconjunto
     daquele conjunto de partições.

     `set_partitions(<a>, <n>)' retorna um conjunto de todas as
     decomposições de <a> em <n> subconjutnos disjuntos não vazios.

     `set_partitions(<a>)' retorna o conjunto de todas as partições.

     `stirling2' retorna a cardinalidade de um conjuntode partições de
     um conjunto.

     Um conjunto de conjuntos P é uma partição de um conjunto S quando

       1. cada elemento de P é um conjunto não vazio,

       2. elementos distintos de P são disjuntos,

       3. a união dos elementos de P é igual a S.

     Exemplos:

     O conjunto vazio é uma partição de si mesmo, as ondições 1 e 2 são
     "vaziamente" verdadeiras.

          (%i1) set_partitions ({});
          (%o1)                         {{}}

     A cardinalidade do conjunto de partições de um conjunto pode ser
     encontrada usando `stirling2'.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) cardinality(p) = stirling2 (6, 3);
          (%o3)                        90 = 90

     Cada elemento de `p' pode ter <n> = 3 elementos; vamos verificar.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (cardinality, p);
          (%o3)                          {3}

     Finalmente, para cada elementos de `p', a união de seus elementos
     possivelmente será igua a `s'; novamente vamos comprovar.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (lambda ([x], apply (union, listify (x))), p);
          (%o3)                 {{0, 1, 2, 3, 4, 5}}

 -- Função: some (<f>, <a>)
 -- Função: some (<f>, <L_1>, ..., <L_n>)
     Retorna `true' se o predicado <f> for `true' para um ou mais
     argumentos dados.

     Given one set as the second argument, `some(<f>, <s>)' returns
     `true' if `is(<f>(<a_i>))' returns `true' for one or more <a_i> in
     <s>.  `some' may or may not evaluate <f> for all <a_i> in <s>.
     Since sets are unordered, `some' may evaluate `<f>(<a_i>)' in any
     order.

     Dadas uma ou mais listas como argumentos, `some(<f>, <L_1>, ...,
     <L_n>)' retorna `true' se `is(<f>(<x_1>, ..., <x_n>))' retornar
     `true' para um ou mais <x_1>, ..., <x_n> em <L_1>, ..., <L_n>,
     respectivamente.  `some' pode ou não avaliar <f> para algumas
     combinações <x_1>, ..., <x_n>.  `some' avalia listas na ordem do
     índice de incremento.

     Dado um conjunto vazio `{}' ou uma lista vazia `[]' como
     argumentos, `some' retorna `false'.

     Quando o sinalizador global `maperror' for `true', todas as listas
     <L_1>, ..., <L_n> devem ter obrigatóriamente comprimentos iguais.
     Quando `maperror' for `false', argumentos do tipo lista são
     efetivamente truncados para o comprimento da menor lista.

     Retorna o valor de um predicado <f> o qual avalia (por meio de
     `is') para alguma coisa outra que não `true' ou `false' e são
     governados pelo sinalizador global `prederror'.  Quando
     `prederror' for `true', tais valores são tratados como `false'.
     Quando `prederror' for `false', tais valores são tratados como
     `unknown' (desconhecidos).

     Exemplos:

     `some' aplicado a um conjunto simples.  O predicado é uma
     função de um argumento.

          (%i1) some (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         true

     `some' aplicada a duas listas.  O predicado é uma função de dois
     argumentos.

          (%i1) some ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) some ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Retorna o valor do predicado <f> o qual avalia para alguma coisa
     que não `true' ou `false' e são governados através do sinalizador
     global `prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o4)                         true
          (%i5) prederror : true;
          (%o5)                         true
          (%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o6)                         false
          (%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o7)                         true

 -- Função: stirling1 (<n>, <m>)
     Representa o número de Stirling de primeiro tipo.

     Quando <n> e <m> forem não negativos inteiros, a magnitude de
     `stirling1 (<n>, <m>)' é o número de permutações de um conjunto
     com <n> elementos que possui <m> ciclos.  Para detalhes, veja
     Graham, Knuth e Patashnik Concrete Mathematics.  Maxima utiliza
     uma relação recursiva para definir `stirling1 (<n>, <m>)' para <m>
     menor que 0; `stirling1' não é definida para <n> menor que 0 e
     para argumetnos não inteiros.

     `stirling1' é uma função de simplificação.  Maxima conhece as
     seguintes identidades:

       1. stirling1(0, n) = kron_delta(0, n) (Ref. [1])

       2. stirling1(n, n) = 1 (Ref. [1])

       3. stirling1(n, n - 1) = binomial(n, 2) (Ref. [1])

       4. stirling1(n + 1, 0) = 0 (Ref. [1])

       5. stirling1(n + 1, 1) = n! (Ref. [1])

       6. stirling1(n + 1, 2) = 2^n  - 1 (Ref. [1])

     Essas identidades são aplicadas quando os argumentos forem
     inteiros literais ou símbolos declarados como inteiros, e o
     primeiro argumento for não negativo.  `stirling1' não simplififca
     para argumentos não inteiros.

     Referências:

     [1] Donald Knuth, The Art of Computer Programming, terceira
     edição, Volume 1, Seção 1.2.6, Equações 48, 49, e 50.

     Exemplos:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     `stirling1' não simplifica para argumentos não inteiros.

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima aplica identidades a `stirling1'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!

 -- Função: stirling2 (<n>, <m>)
     Representa o número de Stirling de segundo tipo.

     Quando <n> e <m> forem inteiros não negativos, `stirling2 (<n>,
     <m>)' é o número de maneiras através dos quais um conjunto com
     cardinalidade <n> pode ser particionado em <m> subconjuntos
     disjuntos.  Maxima utiliza uma relação recursiva para definir
     `stirling2 (<n>, <m>)' para <m> menor que 0; `stirling2' é
     indefinida para <n> menor que 0 e para argumentos não inteiros.

     `stirling2' é uma função de simplificação.  Maxima conhece as
     seguintes identidades.

       1. stirling2(0, n) = kron_delta(0, n) (Ref. [1])

       2. stirling2(n, n) = 1 (Ref. [1])

       3. stirling2(n, n - 1) = binomial(n, 2) (Ref. [1])

       4. stirling2(n + 1, 1) = 1 (Ref. [1])

       5. stirling2(n + 1, 2) = 2^n  - 1 (Ref. [1])

       6. stirling2(n, 0) = kron_delta(n, 0) (Ref. [2])

       7. stirling2(n, m) = 0 when m > n (Ref. [2])

       8. stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) /
          m!  onde m e n são inteiros, e n é não negativo. (Ref. [3])

     Essas identidades são aplicadas quando os argumentos forem
     inteiros literais ou símbolos declarados como inteiros, e o
     primeiro argumento for não negativo.  `stirling2' não simplifica
     para argumentos não inteiros.

     Referências:

     [1] Donald Knuth. The Art of Computer Programming, terceira
     edição, Volume 1, Seção 1.2.6, Equações 48, 49, e 50.

     [2] Graham, Knuth, e Patashnik. Concrete Mathematics, Tabela 264.

     [3] Abramowitz e Stegun. Handbook of Mathematical Funçãos,
     Seção 24.1.4.

     Exemplos:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     `stirling2' não simplifica para argumentos não inteiros.

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima aplica identidades a `stirling2'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1

 -- Função: subset (<a>, <f>)
     Retorna o subconjuntode um conjunto <a> que satisfaz o predicado
     <f>.

     `subset' returns um conjunto which comprises the elements of <a>
     for which <f> returns anything other than `false'.  `subset' does
     not apply `is' to the return value of <f>.

     `subset' reclama se <a> não for um conjunto literal.

     See also `partition_set'.

     Exemplos:

          (%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
          (%o2)                      {2, 8, 14}


 -- Função: subsetp (<a>, <b>)
     Retorna `true' se e somente se o conjunto <a> for um subconjunto
     de <b>.

     `subsetp' reclama se ou <a> ou <b> não forem um conjunto literal.

     Exemplos:

          (%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
          (%o1)                         true
          (%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
          (%o2)                         false


 -- Função: symmdifference (<a_1>, ..., <a_n>)
     Retorna a diferença simétrica, isto é, o conjunto dos elemetnos
     que ocorrem em exatamente um conjunto <a_k>.

     Given two arguments, `symmdifference(<a>, <b>)' is the same as
     `union(setdifference(<a>, <b>), setdifference(<b>, <a>))'.

     `symmdifference' reclama se any argument não for um conjunto
     literal.

     Exemplos:

          (%i1) S_1 : {a, b, c};
          (%o1)                       {a, b, c}
          (%i2) S_2 : {1, b, c};
          (%o2)                       {1, b, c}
          (%i3) S_3 : {a, b, z};
          (%o3)                       {a, b, z}
          (%i4) symmdifference ();
          (%o4)                          {}
          (%i5) symmdifference (S_1);
          (%o5)                       {a, b, c}
          (%i6) symmdifference (S_1, S_2);
          (%o6)                        {1, a}
          (%i7) symmdifference (S_1, S_2, S_3);
          (%o7)                        {1, z}
          (%i8) symmdifference ({}, S_1, S_2, S_3);
          (%o8)                        {1, z}


 -- Função: tree_reduce (<F>, <s>)
 -- Função: tree_reduce (<F>, <s>, <s_0>)
     Extende a função binária <F> a uma função enária através de
     composição, onde <s> é um conjunto ou uma lista.

     `tree_reduce' é equivalente ao seguinte: Aplicar <F> a sucessivos
     pares de elementos para formar uma nova lista `[<F>(<s_1>, <s_2>),
     <F>(<s_3>, <s_4>), ...]', mantendo o elemento final inalterado
     caso haja um número ímpar de elementos.  Repetindo então o
     processo até que a lista esteja reduzida a um elemento simples, o
     qual é o valor de retorno da função.

     Quando o argumento opcional <s_0> estiver presente, o resultado é
     equivalente a `tree_reduce(<F>, cons(<s_0>, <s>)'.

     Para adições em ponto flutuante, `tree_reduce' pode retornar uma
     soma que possui um menor ero de arredondamento que `rreduce' ou
     `lreduce'.

     Os elementos da lista <s> e os resultados parciais podem ser
     arranjados em uma árvore binária de profundidade mínima, daí o
     nome "tree_reduce".

     Exemplos:

     `tree_reduce' aplicada a uma lista com um número par de elementos.

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     `tree_reduce' aplicada a uma lista com um número ímpar de
     elementos.

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)


 -- Função: union (<a_1>, ..., <a_n>)
     Retorna a união dos conjuntos de <a_1> a <a_n>.

     `union()' (sem argumentos) retorna o conjunto vazio.

     `union' reclama se qualquer argumento não for um conjunto literal.

     Exemplos:

          (%i1) S_1 : {a, b, c + d, %e};
          (%o1)                   {%e, a, b, d + c}
          (%i2) S_2 : {%pi, %i, %e, c + d};
          (%o2)                 {%e, %i, %pi, d + c}
          (%i3) S_3 : {17, 29, 1729, %pi, %i};
          (%o3)                {17, 29, 1729, %i, %pi}
          (%i4) union ();
          (%o4)                          {}
          (%i5) union (S_1);
          (%o5)                   {%e, a, b, d + c}
          (%i6) union (S_1, S_2);
          (%o6)              {%e, %i, %pi, a, b, d + c}
          (%i7) union (S_1, S_2, S_3);
          (%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
          (%i8) union ({}, S_1, S_2, S_3);
          (%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}


 -- Função: xreduce (<F>, <s>)
 -- Função: xreduce (<F>, <s>, <s_0>)
     Extendendo a função <F> para uma função enária por composição, ou,
     se <F> já for enária, aplica-se <F> a <s>.  Quando <F> não for
     enária, `xreduce' funciona da mesma forma que `lreduce'.  O
     argumento <s> é uma lista.

     Funções sabidamente enárias inclui adição `+', multiplicação `*',
     `and', `or', `max', `min', e `append'.  Funções podem também serem
     declaradas enárias por meio de `declare(<F>, nary)'.  Para essas
     funções, é esperado que `xreduce' seja mais rápida que ou
     `rreduce' ou `lreduce'.

     Quando o argumento opcional <s_0> estiver presente, o resultado é
     equivalente a `xreduce(<s>, cons(<s_0>, <s>))'.

     Adições em ponto flutuante não são exatamente associativas; quando
     a associatividade ocorrer, `xreduce' aplica a adição enária do
     Maxima quando <s> contiver números em ponto flutuante.

     Exemplos:

     `xreduce' aplicada a uma função sabidamente enária.  `F' é chamada
     uma vez, com todos os argumentos.

          (%i1) declare (F, nary);
          (%o1)                         done
          (%i2) F ([L]) := L;
          (%o2)                      F([L]) := L
          (%i3) xreduce (F, [a, b, c, d, e]);
          (%o3)         [[[[[("[", simp), a], b], c], d], e]

     `xreduce' aplicada a uma função não sabidamente enária.  `G' é
     chamada muitas vezes, com dois argumentos de cada vez.

          (%i1) G ([L]) := L;
          (%o1)                      G([L]) := L
          (%i2) xreduce (G, [a, b, c, d, e]);
          (%o2)         [[[[[("[", simp), a], b], c], d], e]
          (%i3) lreduce (G, [a, b, c, d, e]);
          (%o3)                 [[[[a, b], c], d], e]



File: maxima.info,  Node: Definição de Função,  Next: Fluxo de Programa,  Prev: Conjuntos,  Up: Top

39 Definição de Função
**********************

* Menu:

* Introdução a Definição de Função::
* Função::
* Macros::
* Funções e Variáveis para Definição de Função::


File: maxima.info,  Node: Introdução a Definição de Função,  Next: Função,  Prev: Definição de Função,  Up: Definição de Função

39.1 Introdução a Definição de Função
=====================================


File: maxima.info,  Node: Função,  Next: Macros,  Prev: Introdução a Definição de Função,  Up: Definição de Função

39.2 Função
===========

39.2.1 Ordinary functions
-------------------------

Para definir uma função no Maxima você usa o operador `:='.  E.g.

     f(x) := sin(x)

define uma função `f'.  Funções anônimas podem também serem criadas
usando `lambda'.  Por exemplo

     lambda ([i, j], ...)

pode ser usada em lugar de `f' onde

     f(i,j) := block ([], ...);
     map (lambda ([i], i+1), l)

retornará uma lista com 1 adicionado a cada termo.

   Você pode também definir uma função com um número variável de
argumentos, teno um argumento final que é atribuído para uma lista de
argumentos extras:

     (%i1) f ([u]) := u;
     (%o1)                      f([u]) := u
     (%i2) f (1, 2, 3, 4);
     (%o2)                     [1, 2, 3, 4]
     (%i3) f (a, b, [u]) := [a, b, u];
     (%o3)               f(a, b, [u]) := [a, b, u]
     (%i4) f (1, 2, 3, 4, 5, 6);
     (%o4)                 [1, 2, [3, 4, 5, 6]]

   O lado direito de uma função é uma expressão.  Desse modo Se você
quer uma seqüência de expressões, você faz

     f(x) := (expr1, expr2, ...., exprn);

   e o valor de <exprn> é que é retornado pela função.

   Se você deseja fazer um `return' de alguma expressão dentro da
função então você deve usar `block' e `return'.

     block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)

   é em si mesma uma expressão, e então poderá ocupar o lugar do lado
direito de uma definição de função.  Aqui pode acontecer que o retorno
aconteça mais facilmente que no exemplo anterior a essa última
expressão.

   O primeiro `[]' no bloco, pode conter uma lista de variáveis e
atribuições de variáveis, tais como `[a: 3, b, c: []]', que farão com
que as três variáveis `a',`b',e `c' não se refiram a seus valores
globais, mas ao contrário tenham esses valores especiais enquanto o
código estiver executando a parte dentro do bloco `block', ou dentro da
funções chamadas de dentro do bloco `block'.  Isso é chamado
associação dynamic, uma vez que as variáveis permanecem do início do
bloco pelo tempo que ele existir.  Uma vez que você retorna do `block',
ou descarta-o, os valores antigos (quaisquer que sejam) das variáveis
serão restaurados.   É certamente uma boa idéia para proteger suas
variáveis nesse caminho.   Note que as atribuições em variáveis do
bloco, são concluídas em paralelo.   Isso significa, que se tiver usado
`c: a' acima, o valor de `c' será o valor de `a' a partir do momento em
que vocêntrou no bloco, mas antes `a' foi associado.   Dessa forma
fazendo alguma coisa como

     block ([a: a], expr1, ...  a: a+3, ..., exprn)

   protegerá o valor externo de `a' de ser alterado, mas impedirá você
acessar o valor antigo.   Dessa forma o lado direito de atribuições, é
avaliado no contexto inserido, antes que qualquer avaliação ocorra.
Usando apenas `block ([x], ...' faremos com que o `x' tenha a si mesmo
como valor, apenas como x teria se você tivesse entrado numa breve
sessão do Maxima.

   Os atuais argumentos para uma função são tratados exatamente da
mesma que as variáveis em um bloco.  Dessa forma em

     f(x) := (expr1, ..., exprn);

   e

     f(1);

   teremos um contexto similar para avaliação de expressões como se
tivéssemos concluído

     block ([x: 1], expr1, ..., exprn)

   Dentro de funções, quando o lado direito de uma definição, pode ser
calculado em tempo de execução, isso é úti para usar `define' e
possivelmente `buildq'.

39.2.2 Função de Array
----------------------

Uma função de Array armazena o valor da função na primeira vez que ela
for chamada com um argumento dado, e retorna o valor armazenado, sem
recalcular esse valor, quando o mesmo argumento for fornecido.  De modo
que uma função é muitas vezes chamada uma função de memorização.

   Nomes de funções de Array são anexados ao final da lista global
`arrays' (não na lista global `functions').  O comando `arrayinfo'
retorna a lista de argumentos para os quais exite valores armazenados,
e `listarray' retorna os valores armazenados.  Os comandos `dispfun' e
`fundef' retornam a definição da função de array.

   O comando `arraymake' contrói uma chamada de função de array,
análogamente a `funmake' para funções comuns.  O comando `arrayapply'
aplica uma função de array a seus argmentos, análogamente a `apply'
para funções comuns.  Não existe nada exatamente análogo a `map' para
funções de array, embora `map(lambda([<x>], <a>[<x>]), <L>)' ou
`makelist(<a>[<x>], <x>, <L>)', onde <L> é uma lista, não estejam tão
longe disso.

   O comando `remarray' remove uma definição de função de array
(incluindo qualquer valor armazenado pela função removida), análogo a
`remfunction' para funções comuns.

   o comando `kill(<a>[<x>])' remove o valor da função de array <a>
armazenado para o argumento <x>; a próxima vez que <a> foor chamada com
o argumento <x>, o valor da função é recomputado.  Todavia, não exite
caminho para remover todos os valores armazenados de uma vez, exceto
para `kill(<a>)' ou `remarray(<a>)', o qual remove também remove a
definição da função de array.


File: maxima.info,  Node: Macros,  Next: Funções e Variáveis para Definição de Função,  Prev: Função,  Up: Definição de Função

39.3 Macros
===========

 -- Função: buildq (<L>, <expr>)
     Substitue variáveis nomeadas pela lista <L> dentro da expressão
     <expr>, paralelamente, sem avaliar <expr>.  A expressão resultante
     é simplificada, mas não avaliada, após `buildq' realizar a
     substituição.

     Os elementos de <L> são símbolos ou expressões de atribuição
     `<símbolo>: <valor>', avaliadas paralelamente.  Isto é, a
     associação de uma variável sobre o lado direito de uma
     atribuição é a associação daquela variável no contexto do qual
     `buildq' for chamada, não a associação daquela variável na lista
     <L> de variáveis.  Se alguma variável em <L> não dada como uma
     atribuição explícita, sua associação em `buildq' é a mesma que no
     contexto no qual `buildq' for chamada.

     Então as variáveis nomeadas em <L> são substituidas em <expr>
     paralelamente.  Isto é, a substituição para cada variável é
     determinada antes que qualquer substituição seja feita, então a
     substituição para uma variável não tem efeito sobre qualquer outra.

     Se qualquer variável <x> aparecer como `splice (<x>)' em <expr>,
     então <x> deve estar associada para uma lista, e a lista recebe
     uma aplicação da função `splice' (é interpolada) na <expr> em
     lugar de substituída.

     Quaisquer variáveis em <expr> não aparecendo em <L> são levados no
     resultado tal como foram escritos, mesmo se elas tiverem
     associações no contexto do qual `buildq' tiver sido chamada.

     Exemplos

     `a' é explicitamente associada a `x', enquanto `b' tem a mesma
     associação (nomeadamente 29) como no contexto chamado, e `c' é
     levada do começo ao fim da forma como foi escrita.  A expressão
     resultante não é avaliada até a avaliação explícita ( com duplo
     apóstrofo - não com aspas - `''%'.

          (%i1) (a: 17, b: 29, c: 1729)$
          (%i2) buildq ([a: x, b], a + b + c);
          (%o2)                      x + c + 29
          (%i3) ''%;
          (%o3)                       x + 1758

     `e' está associado a uma lista, a qual aparece também como tal nos
     argumentos de `foo', e interpolada nos argumentos de `bar'.

          (%i1) buildq ([e: [a, b, c]], foo (x, e, y));
          (%o1)                 foo(x, [a, b, c], y)
          (%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
          (%o2)                  bar(x, a, b, c, y)

     O resultado é simplificado após substituição.  Se a
     simplificação for aplicada antes da substituição, esses dois
     resultados podem ser iguais.
          (%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
          (%o1)                    2 c + 2 b + 2 a
          (%i2) buildq ([e: [a, b, c]], 2 * splice (e));
          (%o2)                        2 a b c

     As variáveis em <L> são associadas em paralelo; se associadas
     seqüêncialmente, o primeiro resultado pode ser `foo (b, b)'.
     Substituições são realizadas em paralelo; compare o segundo
     resultado com o resultado de `subst', que realiza substituições
     seqüêncialmente.

          (%i1) buildq ([a: b, b: a], foo (a, b));
          (%o1)                       foo(b, a)
          (%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
          (%o2)                 bar(v, w, x, y, z, u)
          (%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
          (%o3)                 bar(u, u, u, u, u, u)

     Constrói uma lista de euqções com algumas variáveis ou expressões
     sobre o lado esquerdo e seus valores sobre o lado direito.
     `macroexpand' mostra a expressão retornada por `show_values'.

          (%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
          (%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
          (%i2) (a: 17, b: 29, c: 1729)$
          (%i3) show_values (a, b, c - a - b);
          (%o3)          [a = 17, b = 29, c - b - a = 1683]
          (%i4) macroexpand (show_values (a, b, c - a - b));
          (%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])


 -- Função: macroexpand (<expr>)
     Retorna a expansão da macro de <expr> sem avaliar a expressão,
     quando `expr' for uma chamada de função de macro.  De outra forma,
     `macroexpand' retorna <expr>.

     Se a expansão de <expr> retorna outra chamada de função de macro,
     aquela chamada de função de macro é também expandida.

     `macroexpand' coloca apóstrofo em seus argumentos, isto é, não os
     avalia.  Todavia, se a expansão de uma chamada de função de macro
     tiver algum efeito, esse efeito colateral é executado.

     Veja também `::=', `macros', e `macroexpand1'.

     Exemplos

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand (h (y));
                                        y - a
          (%o4)                         -----
                                         99
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Função: macroexpand1 (<expr>)
     Retorna a expansão de macro de <expr> sem avaliar a expressão,
     quando `expr' for uma chamada de função de macro.  De outra forma,
     `macroexpand1' retorna <expr>.

     `macroexpand1' não avalia seus argumentos.  Todavia, se a expansão
     de uma chamada de função de macro tiver algum efeito, esse efeito
     colateral é executado.

     Se a expansão de <expr> retornar outra chamada de função de macro,
     aquela chamada de função de macro não é expandida.

     Veja também `::=', `macros', e `macroexpand'.

     Exemplos

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand1 (h (y));
          (%o4)                       g(y - a)
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Global variable: macros
     Default value: `[]'

     `macros' é a lista de funções de macro definidas pelo usuário.  O
     operador de definição de função de macro `::=' coloca uma nova
     função de macro nessa lista, e `kill', `remove', e `remfunction'
     removem funções de macro da lista.

     Veja também `infolists'.


 -- Função: splice (<a>)
     Une como se fosse um elo de ligação (interpola) a lista nomeada
     através do átomo <a> em uma expressão, mas somente se `splice'
     aparecer dentro de `buildq'; de outra forma, `splice' é tratada
     como uma função indefinida.  Se aparecer dentro de `buildq' com
     <a> sozinho (sem `splice'), <a> é substituido (não interpolado)
     como uma lista no resultado.  O argumento de `splice' pode somente
     ser um átomo; não pode ser uma lista lateral ou uma expressão que
     retorna uma lista.

     Tipicamente `splice' fornece os argumentos para uma função ou
     operador.  Para uma função `f', a expressão `f (splice (<a>))'
     dentro de `buildq' expande para `f (<a>[1], <a>[2], <a>[3], ...)'.
     Para um operador `o', a expressão `"o" (splice (<a>)' dentro de
     `buildq' expande para `"o" (<a>[1], <a>[2], <a>[3], ...)', onde
     `o' pode ser qualquer tipo de operador (tipicamente um que toma
     multiplos argumentos).  Note que o operador deve ser contido
     dentro de aspas duplas `"'.

     Exemplos

          (%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                                 foo(1, %pi, z - y)
          (%o1)                -----------------------
                               length([1, %pi, z - y])
          (%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                          1
          (%o2)                          ---
                                         %pi
          (%i3) matchfix ("<>", "<>");
          (%o3)                          <>
          (%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
          (%o4)                   <>1, %pi, z - y<>



File: maxima.info,  Node: Funções e Variáveis para Definição de Função,  Prev: Macros,  Up: Definição de Função

39.4 Funções e Variáveis para Definição de Função
=================================================

 -- Função: apply (<F>, [<x_1>, ..., <x_n>])
     Constrói e avalia uma expressãp `<F>(<arg_1>, ..., <arg_n>)'.

     `apply' não tenta distinguir funções de array de funções comuns;
     quando <F> for o nome de uma função de array, `apply' avalia
     `<F>(...)' (isto é, uma chamada de função com parêntesis em lugar
     de colchêtes).  `arrayapply' avalia uma chamada de função com
     colchêtes nesse caso.

     Exemplos:

     `apply' avalia seus argumentos.  Nesse exemplo, `min' é aplicado a
     `L'.

          (%i1) L : [1, 5, -10.2, 4, 3];
          (%o1)                 [1, 5, - 10.2, 4, 3]
          (%i2) apply (min, L);
          (%o2)                        - 10.2

     `apply' avalia argumentos, mesmo se a função <F> disser que os
     argumentos não devem ser avaliados.

          (%i1) F (x) := x / 1729;
                                             x
          (%o1)                     F(x) := ----
                                            1729
          (%i2) fname : F;
          (%o2)                           F
          (%i3) dispfun (F);
                                             x
          (%t3)                     F(x) := ----
                                            1729

          (%o3)                         [%t3]
          (%i4) dispfun (fname);
          fname is not the name of a user function.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) apply (dispfun, [fname]);
                                             x
          (%t5)                     F(x) := ----
                                            1729

          (%o5)                         [%t5]

     `apply' avalia o nome de função <F>.  Apóstrofo `'' evita
     avaliação.  `demoivre' é o nome de uma variável global e também de
     uma função.

          (%i1) demoivre;
          (%o1)                         false
          (%i2) demoivre (exp (%i * x));
          (%o2)                  %i sin(x) + cos(x)
          (%i3) apply (demoivre, [exp (%i * x)]);
          demoivre evaluates to false
          Improper name or value in functional position.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) apply ('demoivre, [exp (%i * x)]);
          (%o4)                  %i sin(x) + cos(x)


 -- Função: block ([<v_1>, ..., <v_m>], <expr_1>, ..., <expr_n>)
 -- Função: block (<expr_1>, ..., <expr_n>)
     `block' avalia <expr_1>, ..., <expr_n> em seqüência e retorna o
     valor da última expressão avaliada.  A seqüência pode ser
     modificada pelas funções `go', `throw', e `return'.  A última
     expressão é <expr_n> a menos que `return' ou uma expressão
     contendo `throw' seja avaliada.  Algumas variáveis <v_1>, ...,
     <v_m> podem ser declaradas locais para o bloco; essas são
     distinguidas das variáveis globais dos mesmos nomes.  Se variáveis
     não forem declaradas locais então a lista pode ser omitida.
     Dentro do bloco, qualquer variável que não <v_1>, ..., <v_m> é uma
     variável global.

     `block' salva os valores correntes das variáveis <v_1>, ..., <v_m>
     (quaisquer valores) na hora da entrada para o bloco, então libera
     as variáveis dessa forma eles avaliam para si mesmos.  As
     variáveis locais podem ser associadas a valores arbitrários dentro
     do bloco mas quando o bloco é encerrado o valores salvos são
     restaurados, e os valores atribuídos dentro do bloco são perdidos.

     `block' pode aparecer dentro de outro `block'.  Variáveis locais
     são estabelecidas cada vez que um novo `block' é avaliado.
     Variáveis locais parecem ser globais para quaisquer blocos
     fechados.  Se uma variável é não local em um bloco, seu valor é o
     valor mais recentemente atribuído por um bloco fechado, quaisquer
     que sejam, de outra forma, seu valor é o valor da variável no
     ambiente global.  Essa política pode coincidir com o entendimento
     usual de "escopo dinâmico".

     Se isso for desejado para salvar e restaurar outras propriedades
     locais ao lado de `value', por exemplo `array' (exceto para arrays
     completos), `function', `dependencies', `atvalue', `matchdeclare',
     `atomgrad', `constant', e `nonscalar' então a função `local' pode
     ser usada dentro do bloco com argumentos sendo o nome das
     variáveis.

     O valor do bloco é o valor da última declaração ou o valor do
     argumento para a função `return' que pode ser usada para sair
     explicitamente do bloco.  A função `go' pode ser usada para
     transferir o controle para a declaração do bloco que é
     identificada com o argumento para `go'.  Para identificar uma
     declaração, coloca-se antes dela um argumento atômico como outra
     declaração no bloco.  Por exemplo: `block ([x], x:1, loop, x: x+1,
     ..., go(loop), ...)'.  O argumento para `go' deve ser o nome de um
     identificador que aparece dentro do bloco.  Não se deve usar `go'
     para transferir para um identificador em um outro bloco a não ser
     esse que contém o `go'.

     Blocos tipicamente aparecem do lado direito de uma definição de
     função mas podem ser usados em outros lugares também.


 -- Função: break (<expr_1>, ..., <expr_n>)
     Avalia e imprime <expr_1>, ..., <expr_n> e então causa uma parada
     do Maxima nesse ponto e o usuário pode examinar e alterar seu
     ambiente.  Nessa situação digite `exit;' para que o cálculo seja
     retomado.


 -- Função: catch (<expr_1>, ..., <expr_n>)
     Avalia <expr_1>, ..., <expr_n> uma por uma; se qualquer
     avaliação levar a uma avaliação de uma expressão da forma `throw
     (arg)', então o valor de `catch' é o valor de `throw (arg)', e
     expressões adicionais não são avaliadas.  Esse "retorno não local"
     atravessa assim qualquer profundidade de aninhar para o mais
     próximo contendo `catch'.  Se não existe nenhum `catch' contendo
     um `throw', uma mensagem de erro é impressa.

     Se a avaliação de argumentos não leva para a avaliação de qualquer
     `throw' então o valor de `catch' é o valor de <expr_n>.

          (%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
          (%i2) g(l) := catch (map (''%, l))$
          (%i3) g ([1, 2, 3, 7]);
          (%o3)               [f(1), f(2), f(3), f(7)]
          (%i4) g ([1, 2, -3, 7]);
          (%o4)                          - 3

     A função `g' retorna uma lista de `f' de cada elemento de `l' se
     `l' consiste somente de números não negativos; de outra forma, `g'
     "captura" o primeiro elemento negativo de `l' e "arremessa-o".


 -- Função: compfile (<nomearquivo>, <f_1>, ..., <f_n>)
 -- Função: compfile (<nomearquivo>, funç ~oes)
 -- Função: compfile (<nomearquivo>, all)
     Traduz fuções Maxima para Lisp e escreve o código traduzido no
     arquivo <nomearquivo>.

     `compfile(<nomearquivo>, <f_1>, ..., <f_n>)' traduz as funções
     especificadas.  `compfile(<nomearquivo>, functions)' e
     `compfile(<nomearquivo>, all)' traduz todas as funções definidas
     pelo usuário.

     As traduções Lisp não são avaliadas, nem é o arquivo de saída
     processado pelo compilador Lisp.  `translate' cria e avalia
     traduções Lisp.  `compile_file' traduz Maxima para Lisp, e então
     executa o compilador Lisp.

     Veja também `translate', `translate_file', e `compile_file'.


 -- Função: compile (<f_1>, ..., <f_n>)
 -- Função: compile (funç ~oes)
 -- Função: compile (all)
     Traduz funções Maxima <f_1>, ..., <f_n> para Lisp, avalia a
     tradução Lisp, e chama a função Lisp `COMPILE' sobre cada
     função traduzida.  `compile' retorna uma lista de nomes de
     funções compiladas.

     `compile (all)' ou `compile (funções)' compila todas as funções
     definidas pelo usuário.

     `compile' não avalia seus argumentos; o operador
     apóstrofo-apóstrofo `''' faz com que ocorra avaliação
     sobrepondo-se ao apóstrofo.


 -- Função: define (<f>(<x_1>, ..., <x_n>), <expr>)
 -- Função: define (<f>[<x_1>, ..., <x_n>], <expr>)
 -- Função: define (funmake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Função: define (arraymake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Função: define (ev (<expr_1>), <expr_2>)
     Define uma função chamada <f> com argumentos <x_1>, ..., <x_n> e
     corpo da função <expr>.  `define' sempre avalia seu segundo
     argumento (a menos que explícitamente receba um apostrofo de forma
     a evitar a avaliação).  A função então definida pode ser uma
     função comum do Maxima (com argumentos contidos entre parêtesis)
     ou uma função de array (com argumentos contidos entre colchêtes).

     Quando o último ou único argumento da função <x_n> for uma lista
     de um elemento, a função definida por `define' aceita um número
     variável de argumentos.  Os argumentos atuais são atribuídos um a
     um a argumentos formais <x_1>, ..., <x_(n - 1)>, e quaisquer
     argumentos adicionais atuais, se estiverem presentes, são
     atribuídos a <x_n> como uma lista.

     Quando o primeiro argumento de `define' for uma expressão da forma
     `<f>(<x_1>, ..., <x_n>)' or `<f>[<x_1>, ..., <x_n>]', os
     argumentos são avaliados mas <f> não é avaliada, mesmo se já
     existe anteriormente uma função ou variável com aquele nome.

     Quando o primeiro argumento for uma expressão com operador
     `funmake', `arraymake', ou `ev', o primeiro argumento será
     avaliado; isso permite para o nome da função seja calculado,
     também como o corpo.

     Todas as definições de função aparecem no mesmo nível de escopo e
     visibilidade; definindo uma função `f' dentro de outra função `g'
     não limita o escopo de `f' a `g'.

     Se algum argumento formal <x_k> for um símbolo com apóstrofo (após
     ter sido feita uma avaliação), a função definida por `define' não
     avalia o correspondente atual argumento.  de outra forma todos os
     argumentos atuais são avaliados.

     Veja também `:=' and `::='.

     Exemplos:

     `define' sempre avalia seu segundo argumento (a menos que
     explícitamente receba um apostrofo de forma a evitar a
     avaliação).

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) define (F1 (x, y), expr);
          (%o2)              F1(x, y) := cos(y) - sin(x)
          (%i3) F1 (a, b);
          (%o3)                    cos(b) - sin(a)
          (%i4) F2 (x, y) := expr;
          (%o4)                   F2(x, y) := expr
          (%i5) F2 (a, b);
          (%o5)                    cos(y) - sin(x)

     A função definida por `define' pode ser uma função comum do Maxima
     ou uma função de array.

          (%i1) define (G1 (x, y), x.y - y.x);
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) define (G2 [x, y], x.y - y.x);
          (%o2)                G2     := x . y - y . x
                                 x, y

     Quando o último ou único argumento da função <x_n> for uma lista
     de um único elemento, a função definida por `define' aceita um
     número variável de argumentos.

          (%i1) define (H ([L]), '(apply ("+", L)));
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

     When the first argument is an expression with operator `funmake',
     `arraymake', or `ev', the first argument is evaluated.

          (%i1) [F : I, u : x];
          (%o1)                        [I, x]
          (%i2) funmake (F, [u]);
          (%o2)                         I(x)
          (%i3) define (funmake (F, [u]), cos(u) + 1);
          (%o3)                  I(x) := cos(x) + 1
          (%i4) define (arraymake (F, [u]), cos(u) + 1);
          (%o4)                   I  := cos(x) + 1
                                   x
          (%i5) define (foo (x, y), bar (y, x));
          (%o5)                foo(x, y) := bar(y, x)
          (%i6) define (ev (foo (x, y)), sin(x) - cos(y));
          (%o6)             bar(y, x) := sin(x) - cos(y)


 -- Função: define_variable (<name>, <default_value>, <mode>)
     Introduz uma variável global dentro do ambiente Maxima.
     `define_variable' é útil em pacotes escritos pelo usuário, que são
     muitas vezes traduzidos ou compilados.

     `define_variable' realiza os seguintes passos:

       1. `mode_declare (<name>, <mode>)' declara o modo de <name> para
          o tradutor.  Veja `mode_declare' para uma lista dos modos
          possíveis.

       2. Se a variável é não associada, <default_value> é atribuído
          para <name>.

       3. `declare (<name>, special)' declara essa variável especial.

       4. Associa <name> com uma função de teste para garantir que a
          <name> seja somente atribuído valores do modo declarado.

     A propriedade `value_check' pode ser atribuída a qualquer variável
     que tenha sido definida via `define_variable' com um outro modo
     que não `any'.  A propriedade `value_check' é uma expressão lambda
     ou o nome de uma função de uma variável, que é chamada quando uma
     tentativa é feita para atribuir um valor a uma variável.  O
     argumento da  função `value_check' é o valor que será atribuído.

     `define_variable' avalia `default_value', e não avalia `name' e
     `mode'.  `define_variable' retorna o valor corrente de `name', que
     é `default_value' se `name' não tiver sido associada antes, e de
     outra forma isso é o valor prévio de `name'.

     Exemplos:

     `foo' é uma variável Booleana, com o valor inicial `true'.

          (%i1) define_variable (foo, true, boolean);
          (%o1)                         true
          (%i2) foo;
          (%o2)                         true
          (%i3) foo: false;
          (%o3)                         false
          (%i4) foo: %pi;
          Error: foo was declared mode boolean, has value: %pi
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) foo;
          (%o5)                         false

     `bar' é uma variável inteira, que deve ser um número primo.

          (%i1) define_variable (bar, 2, integer);
          (%o1)                           2
          (%i2) qput (bar, prime_test, value_check);
          (%o2)                      prime_test
          (%i3) prime_test (y) := if not primep(y) then error (y, "is not prime.");
          (%o3) prime_test(y) := if not primep(y)

                                             then error(y, "is not prime.")
          (%i4) bar: 1439;
          (%o4)                         1439
          (%i5) bar: 1440;
          1440 é not prime.
          #0: prime_test(y=1440)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) bar;
          (%o6)                         1439

     `baz_quux' é uma variável que não pode receber a atribuição de um
     valor.  O modo `any_check' é como `any', mas `any_check' habilita
     o mecanismo `value_check', e `any' não habilita.

          (%i1) define_variable (baz_quux, 'baz_quux, any_check);
          (%o1)                       baz_quux
          (%i2) F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
          (%o2) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i3) qput (baz_quux, ''F, value_check);
          (%o3) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i4) baz_quux: 'baz_quux;
          (%o4)                       baz_quux
          (%i5) baz_quux: sqrt(2);
          Cannot assign to `baz_quux'.
          #0: lambda([y],if y # 'baz_quux then error("Cannot assign to `baz_quux'."))(y=sqrt(2))
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) baz_quux;
          (%o6)                       baz_quux


 -- Função: dispfun (<f_1>, ..., <f_n>)
 -- Função: dispfun (all)
     Mostra a definição de funções definidas pelo usuário <f_1>, ...,
     <f_n>.  Cada argumento pode ser o nome de uma macro (definida com
     `::='), uma função comum (definida com `:=' ou `define'), uma
     função array (definida com `:=' ou com `define', mas contendo
     argumentos entre colchêtes `[ ]'), uma função subscrita, (definida
     com `:=' ou `define', mas contendo alguns argumentos entre
     colchêtes e outros entre parêntesis `( )') uma da família de
     funções subscritas selecionadas por um valor subscrito particular,
     ou uma função subscrita definida com uma constante subscrita.

     `dispfun (all)' mostra todas as funções definidas pelo usuário como
     dadas pelas `functions', `arrays', e listas de `macros', omitindo
     funções subscritas definidas com constantes subscritas.

     `dispfun' cria um Rótulo de expressão intermediária (`%t1', `%t2',
     etc.)  para cada função mostrada, e atribui a definição de
     função para o rótulo.  Em contraste, `fundef' retorna a
     definição de função.

     `dispfun' não avalia seus argumentos; O operador
     apóstrofo-apóstrofo `''' faz com que ocorra avaliação.  `dispfun'
     retorna a lista de rótulos de expressões intermediárias
     correspondendo às funções mostradas.

     Exemplos:

          (%i1) m(x, y) ::= x^(-y);
                                               - y
          (%o1)                   m(x, y) ::= x
          (%i2) f(x, y) :=  x^(-y);
                                               - y
          (%o2)                    f(x, y) := x
          (%i3) g[x, y] :=  x^(-y);
                                              - y
          (%o3)                     g     := x
                                     x, y
          (%i4) h[x](y) :=  x^(-y);
                                              - y
          (%o4)                     h (y) := x
                                     x
          (%i5) i[8](y) :=  8^(-y);
                                              - y
          (%o5)                     i (y) := 8
                                     8
          (%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                               - y
          (%t6)                   m(x, y) ::= x

                                               - y
          (%t7)                    f(x, y) := x

                                              - y
          (%t8)                     g     := x
                                     x, y

                                              - y
          (%t9)                     h (y) := x
                                     x

                                              1
          (%t10)                     h (y) := --
                                      5        y
                                              5

                                               1
          (%t11)                    h  (y) := ---
                                     10         y
                                              10

                                              - y
          (%t12)                    i (y) := 8
                                     8

          (%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
          (%i12) ''%;
                               - y              - y            - y
          (%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   ,
                                                      x, y
                            - y           1              1             - y
                  h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
                   x              5        y   10         y   8
                                          5             10


 -- Variável de sistema: functions
     Valor padrão: `[]'

     `functions' é a lista de todas as funções comuns do Maxima na
     sessão corrente.  Uma função comum é uma função construída através
     de `define' ou de `:=' e chamada com parêntesis `()'.  Uma
     função pode ser definida pela linha de comando do Maxima de forma
     interativa com o usuário ou em um arquivo Maxima chamado por
     `load' ou `batch'.

     Funções de array (chamadas com colchêtes, e.g., `F[x]') e
     funções com subscritos (chamadas com colchêtes e parêntesis, e.g.,
     `F[x](y)') são lsitados através da variável global `arrays', e não
     por meio de `functions'.

     Funções Lisp não são mantidas em nenhuma lista.

     Exemplos:

          (%i1) F_1 (x) := x - 100;
          (%o1)                   F_1(x) := x - 100
          (%i2) F_2 (x, y) := x / y;
                                                x
          (%o2)                    F_2(x, y) := -
                                                y
          (%i3) define (F_3 (x), sqrt (x));
          (%o3)                   F_3(x) := sqrt(x)
          (%i4) G_1 [x] := x - 100;
          (%o4)                    G_1  := x - 100
                                      x
          (%i5) G_2 [x, y] := x / y;
                                               x
          (%o5)                     G_2     := -
                                       x, y    y
          (%i6) define (G_3 [x], sqrt (x));
          (%o6)                    G_3  := sqrt(x)
                                      x
          (%i7) H_1 [x] (y) := x^y;
                                                y
          (%o7)                     H_1 (y) := x
                                       x
          (%i8) functions;
          (%o8)              [F_1(x), F_2(x, y), F_3(x)]
          (%i9) arrays;
          (%o9)                 [G_1, G_2, G_3, H_1]


 -- Função: fundef (<f>)
     Retorna a definição da função <f>.

     O argumento pode ser o nome de uma macro (definida com `::='), uma
     função comum (definida com `:=' ou `define'), uma função array
     (definida com `:=' ou `define', mas contendo argumentos entre
     colchêtes `[ ]'), Uma função subscrita, (definida com `:=' ou
     `define', mas contendo alguns argumentos entre colchêtes e
     parêntesis `( )') uma da família de funções subscritas selecionada
     por um valor particular subscrito, ou uma função subscrita
     definida com uma constante subscrita.

     `fundef' não avalia seu argumento; o operador apóstrofo-apóstrofo
     `''' faz com que ocorra avaliação.

     `fundef (<f>)' retorna a definição de <f>.  Em contraste, `dispfun
     (<f>)' cria um rótulo de expressão intermediária e atribui a
     definição para o rótulo.


 -- Função: funmake (<F>, [<arg_1>, ..., <arg_n>])
     Retorna uma expressão `<F>(<arg_1>, ..., <arg_n>)'.  O valor de
     retorno é simplificado, mas não avaliado, então a função <F> não é
     chamada, mesmo se essa função <F> existir.

     `funmake' não tenta distinguir funções de array de funções comuns;
     quando <F> for o nome de uma função de array, `funmake' retorna
     `<F>(...)' (isto é, uma chamada de função com parêntesis em lugar
     de colchêtes).  `arraymake' retorna uma chamada de função com
     colchêtes nesse caso.

     `funmake' avalia seus argumentos.

     Exemplos:

     `funmake' aplicada a uma função comum do Maxima.

          (%i1) F (x, y) := y^2 - x^2;
                                             2    2
          (%o1)                  F(x, y) := y  - x
          (%i2) funmake (F, [a + 1, b + 1]);
          (%o2)                    F(a + 1, b + 1)
          (%i3) ''%;
                                        2          2
          (%o3)                  (b + 1)  - (a + 1)

     `funmake' aplicada a uma macro.

          (%i1) G (x) ::= (x - 1)/2;
                                            x - 1
          (%o1)                    G(x) ::= -----
                                              2
          (%i2) funmake (G, [u]);
          (%o2)                         G(u)
          (%i3) ''%;
                                        u - 1
          (%o3)                         -----
                                          2

     `funmake' aplicada a uma função subscrita.

          (%i1) H [a] (x) := (x - 1)^a;
                                                  a
          (%o1)                   H (x) := (x - 1)
                                   a
          (%i2) funmake (H [n], [%e]);
                                                 n
          (%o2)               lambda([x], (x - 1) )(%e)
          (%i3) ''%;
                                              n
          (%o3)                       (%e - 1)
          (%i4) funmake ('(H [n]), [%e]);
          (%o4)                        H (%e)
                                        n
          (%i5) ''%;
                                              n
          (%o5)                       (%e - 1)

     `funmake' aplicada a um símbolo que não é uma função definida de
     qualquer tipo.

          (%i1) funmake (A, [u]);
          (%o1)                         A(u)
          (%i2) ''%;
          (%o2)                         A(u)

     `funmake' avalia seus argumentos, mas não o valor de retorno.

          (%i1) det(a,b,c) := b^2 -4*a*c;
                                              2
          (%o1)              det(a, b, c) := b  - 4 a c
          (%i2) (x : 8, y : 10, z : 12);
          (%o2)                          12
          (%i3) f : det;
          (%o3)                          det
          (%i4) funmake (f, [x, y, z]);
          (%o4)                    det(8, 10, 12)
          (%i5) ''%;
          (%o5)                         - 284

     Maxima simplifica o valor de retorno de `funmake'.

          (%i1) funmake (sin, [%pi / 2]);
          (%o1)                           1


 -- Função: lambda ([<x_1>, ..., <x_m>], <expr_1>, ..., <expr_n>)
 -- Função: lambda ([[<L>]], <expr_1>, ..., <expr_n>)
 -- Função: lambda ([<x_1>, ..., <x_m>, [<L>]], <expr_1>, ..., <expr_n>)
     Define e retorna uma expressão lambda (que é, uma função anônima)
     A função pode ter argumentos que sejam necessários <x_1>, ...,
     <x_m> e/ou argumentos opcionais <L>, os quais aparecem dentro do
     corpo da função como uma lista.  O valor de retorno da função é
     <expr_n>.  Uma expressão lambda pode ser atribuída para uma
     variável e avaliada como uma função comum.  Uma expressão lambda
     pode aparecer em alguns contextos nos quais um nome de função é
     esperado.

     Quando a função é avaliada, variáveis locais não associadas <x_1>,
     ..., <x_m> são criadas.  `lambda' pode aparecer dentro de `block'
     ou outra função `lambda'; variáveis locais são estabelecidas cada
     vez que outro `block' ou função `lambda' é avaliada.  Variáveis
     locais parecem ser globais para qualquer coisa contendo `block' ou
     `lambda'.  Se uma variável é não local, seu valor é o valor mais
     recentemente atribuído em alguma coisa contendo `block' ou
     `lambda', qualquer que seja, de outra forma, seu valor é o valor
     da variável no ambiente global.  Essa política pode coincidir com
     o entendimento usual de "escopo dinâmico".

     Após variáveis locais serem estabelecidas, <expr_1> até <expr_n>
     são avaliadas novamente.  a variável especial `%%', representando
     o valor da expressão precedente, é reconhecida.  `throw' e `catch'
     pode também aparecer na lista de expressões.

     `return' não pode aparecer em uma expressão lambda a menos que
     contendo `block', nesse caso `return' define o valor de retorno do
     bloco e não da expressão lambda, a menos que o bloco seja
     <expr_n>.  Da mesma forma, `go' não pode aparecer em uma expressão
     lambda a menos que contendo `block'.

     `lambda' não avalia seus argumentos; o operador
     apóstrofo-apóstrofo `''' faz com que ocorra avaliação.

     Exemplos:

        * A expressão lambda pode ser atribuída para uma variável e
          avaliada como uma função comum.

          (%i1) f: lambda ([x], x^2);
                                                2
          (%o1)                    lambda([x], x )
          (%i2) f(a);
                                          2
          (%o2)                          a

        * Uma expressão lambda pode aparecer em contextos nos quais uma
          avaliação de função é esperada como resposta.

          (%i3) lambda ([x], x^2) (a);
                                          2
          (%o3)                          a
          (%i4) apply (lambda ([x], x^2), [a]);
                                          2
          (%o4)                          a
          (%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                                  2   2   2   2   2
          (%o5)                 [a , b , c , d , e ]

        * Variáveis argumento são variáveis locais.  Outras variáveis
          aparecem para serem variáveis globais.  Variáveis globais são
          avaliadas ao mesmo tempo em que a expressão lambda é avaliada,
          a menos que alguma avaliação especial seja forçada por alguns
          meios, tais como `'''.

          (%i6) a: %pi$
          (%i7) b: %e$
          (%i8) g: lambda ([a], a*b);
          (%o8)                   lambda([a], a b)
          (%i9) b: %gamma$
          (%i10) g(1/2);
                                       %gamma
          (%o10)                       ------
                                         2
          (%i11) g2: lambda ([a], a*''b);
          (%o11)                lambda([a], a %gamma)
          (%i12) b: %e$
          (%i13) g2(1/2);
                                       %gamma
          (%o13)                       ------
                                         2

        * Expressões lambda podem ser aninhadas.  Variáveis locais
          dentro de outra expressão lambda parece ser global para a
          expressão interna a menos que mascarada por variáveis locais
          de mesmos nomes.

          (%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                             1
          (%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                             2
          (%i15) h(%pi, %gamma);
                                       %gamma
          (%o15)                       ------
                                         2

        * Uma vez que `lambda' não avalia seus argumentos, a expressão
          lambda `i' abaixo não define uma função "multiplicação por
          `a'".  Tanto uma função pode ser definida via `buildq', como
          na expressão lambda `i2' abaixo.

          (%i16) i: lambda ([a], lambda ([x], a*x));
          (%o16)            lambda([a], lambda([x], a x))
          (%i17) i(1/2);
          (%o17)                  lambda([x], a x)
          (%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
          (%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
          (%i19) i2(1/2);
                                               x
          (%o19)                   lambda([x], -)
                                               2
          (%i20) i2(1/2)(%pi);
                                         %pi
          (%o20)                         ---
                                          2

        * Uma expressão lambda pode receber um número variável de
          argumentos, os quais são indicados por meio de `[<L>]' como o
          argumento único ou argumento final.  Os argumentos aparecem
          dentro do corpo da função como uma lista.

          (%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
          (%o1)          lambda([aa, bb, [cc]], aa cc + bb)
          (%i2) f (foo, %i, 17, 29, 256);
          (%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
          (%i3) g : lambda ([[aa]], apply ("+", aa));
          (%o3)             lambda([[aa]], apply(+, aa))
          (%i4) g (17, 29, x, y, z, %e);
          (%o4)                  z + y + x + %e + 46

 -- Função: local (<v_1>, ..., <v_n>)
     Declara as variáveis <v_1>, ..., <v_n> para serem locais com
     relação a todas as propriedades na declaração na qual essa
     função é usada.

     `local' não avalia seus argumentos.  `local' retorna `done'.

     `local' pode somente ser usada em `block', no corpo de
     definições de função ou expressões `lambda', ou na função `ev', e
     somente uma ocorrêcia é permitida em cada.

     `local' é independente de `context'.


 -- Variável de opção: macroexpansion
     Valor padrão: `false'

     `macroexpansion' controla se a expansão (isto é, o valor de
     retorno) de uma função de macro é substituído pela chamada à
     função de macro.  Uma substituição pode aumentar a velocidade de
     subseqüênte avaliações da expressão, ao custo de armazenar a
     expansão.

    `false'
          A expansão de uma função de macro não é substituída pela
          chamada de função de macro.

    `expand'
          Da primeira vez que a função de macro é avaliada, a expansão
          é armazenada.  A expansão não é recalculada sobre chamadas
          subseqüêntes; qualquer efeito colateral (tais como `print' ou
          atribuições a variáveis globais) ocorrem somente quando
          chamadas à função de macro forem avaliadas primeiramente.
          Expansões em uma expressão não afetam outras expressões que
          possuem a mesma chamada à função de macro.

    `displace'
          Na primeira vez que uma função de macro é avaliada, a
          expansão é substituída pela chamada, dessa forma modificando
          a expressão a partir da qual a função de macro foi chamada.
          A expansão não é recalculada nas chamadas subseqüêntes;
          qualquer efeito colateral acontece somente quando a chamada à
          função de macro for avaliada primeiramente.  Expansões na
          expressão não afetam outras expressões que possuem a mesma
          chamada à função de macro.

     Exemplos

     Quandon `macroexpansion' for `false', uma função de macro é
     chamada a cada vez que a expressão que está chamando é avaliada, e
     a expressão que está chamandonão é modificada.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: false;
          (%o4)                         false
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     Quando `macroexpansion' for `expand', uma função de macro é
     chamada uma única vez, e a expressão que está chamando não é
     modificada.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: expand;
          (%o4)                        expand
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     Quando `macroexpansion' for `expand', uma função de macro é
     chamada uma única vez, e a expressão que está chamando é
     modificada.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: displace;
          (%o4)                       displace
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                           x - 99
          (%t6)                    f(x) := ------
                                           x + 99

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99


 -- Variável de opção: mode_checkp
     Valor padrão: `true'

     Quando `mode_checkp' é `true', `mode_declare' verifica os modos de
     associação de variáveis.


 -- Variável de opção: mode_check_errorp
     Valor padrão: `false'

     Quando `mode_check_errorp' é `true', `mode_declare' chama a
     função "error".


 -- Variável de opção: mode_check_warnp
     Valor padrão: `true'

     Quando `mode_check_warnp' é `true', modo "errors" são descritos.


 -- Função: mode_declare (<y_1>, <mode_1>, ..., <y_n>, <mode_n>)
     `mode_declare' é usado para declarar os modos de variáveis e
     funções para subseqüênte tradução ou compilação das funções.
     `mode_declare' é tipicamente colocada no início de uma
     definição de função, no início de um script Maxima, ou executado
     através da linha de comando de forma interativa.

     Os argumentos de `mode_declare' são pares consistindo de  uma
     variável e o modo que é um de `boolean', `fixnum', `number',
     `rational', ou `float'.  Cada variável pode também ser uma lista
     de variáveis todas as quais são declaradas para ter o mesmo modo.

     Se uma variável é um array, e se todo elemento do array que é
     referenciado tiver um valor então `array (yi, complete, dim1,
     dim2, ...)' em lugar de
          array(yi, dim1, dim2, ...)
     deverá ser usado primeiro declarando as associações do array.  Se
     todos os elementos do array estão no modo `fixnum' (`float'), use
     `fixnum' (`float') em lugar de `complete'.  Também se todo
     elemento do array está no mesmo modo, digamos `m', então

          mode_declare (completearray (yi), m))

     deverá ser usado para uma tradução eficiente.

     Código numéricos usando arrays podem rodar mais rápidamente se for
     decladado o tamanho esperado do array, como em:

          mode_declare (completearray (a [10, 10]), float)

     para um array numérico em ponto flutuante que é 10 x 10.

     Pode-se declarar o modo do resultado de uma função usando
     `function (f_1, f_2, ...)' como um argumento; aqui `f_1', `f_2',
     ...  são nomes de funções.  Por exemplo a expressão,

          mode_declare ([function (f_1, f_2, ...)], fixnum)

     declara que os valores retornados por `f_1', `f_2', ...  são
     inteiros palavra simples.

     `modedeclare' é um sinônimo para `mode_declare'.


 -- Função: mode_identity (<arg_1>, <arg_2>)
     Uma forma especial usada com `mode_declare' e `macros' para
     declarar, e.g., uma lista de listas de números em ponto flutuante
     ou outros objetos de dados.  O primeiro argumento para
     `mode_identity' é um valor primitivo nome de modo como dado para
     `mode_declare' (i.e., um de `float', `fixnum', `number', `list',
     ou `any'), e o segundo argumento é uma expressão que é avaliada e
     retornada com o valor de `mode_identity'.  Todavia, se o valor de
     retorno não é permitido pelo modo declarado no primeiro argumento,
     um erro ou alerta é sinalizado.  Um ponto importante é que o modo
     da expressão como determinado pelo Maxima para o tradutor Lisp,
     será aquele dado como o primeiro argumento, independente de
     qualquer coisa que vá no segundo argumento.  E.g., `x: 3.3;
     mode_identity (fixnum, x);' retorna um erro.  `mode_identity
     (flonum, x)' returns 3.3 .  Isso tem númerosas utilidades, e.g.,
     se você soube que `first (l)' retornou um número então você pode
     escrever `mode_identity (number, first (l))'.  Todavia, um mais
     eficiente caminho para fazer isso é definir uma nova primitiva,

          firstnumb (x) ::= buildq ([x], mode_identity (number, x));

     e usar `firstnumb' toda vez que você pegar o primeiro de uma lista
     de números.


 -- Variável de opção: transcompile
     Valor padrão: `true'

     Quando `transcompile' é `true', `translate' e `translate_file'
     geram declarações para fazer o código traduzido mais adequado para
     compilação.

     `compfile' escolhe `transcompile: true' para a duração.


 -- Função: translate (<f_1>, ..., <f_n>)
 -- Função: translate (funç ~oes)
 -- Função: translate (all)
     Traduz funções definidas pelo usuário <f_1>, ..., <f_n> da
     linguagem de Maxima para Lisp e avalia a tradução Lisp.
     Tipicamente as funções traduzidas executam mais rápido que as
     originais.

     `translate (all)' ou `translate (funções)' traduz todas as
     funções definidas pelo usuário.

     Funções a serem traduzidas incluir~ao uma chamada para
     `mode_declare' no início quando possível com o objetivo de
     produzir um código mais eficiente.  Por exemplo:

          f (x_1, x_2, ...) := block ([v_1, v_2, ...],
              mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)

     quando <x_1>, <x_2>, ...  são parâmetros para a função e <v_1>,
     <v_2>, ...  são variáveis locais.

     Os nomes de funções traduzidas são removidos da lista `functions'
     se `savedef' é `false' (veja abaixo) e são adicionados nas listas
     `props'.

     Funções não poderão ser traduzidas a menos que elas sejam
     totalmente depuradas.

     Expressões são assumidas simplificadas; se não forem, um código
     correto será gerado mas não será um código ótimo.  Dessa forma, o
     usuário não poderá escolher o comutador `simp' para `false' o qual
     inibe simplificação de expressões a serem traduzidas.

     O comutador `translate', se `true', causa tradução automatica de
     uma função de usuário para Lisp.

     Note que funções traduzidas podem não executar identicamente para
     o caminho que elas faziam antes da tradução como certas
     incompatabilidades podem existir entre o Lisp e versões do Maxima.
     Principalmente, a função  `rat' com mais de um argumento e a
     função `ratvars' não poderá ser usada se quaisquer variáveis são
     declaradas com `mode_declare' como sendo expressões rotacionais
     canônicas(CRE).  Também a escolha `prederror: false' não traduzirá.

     `savedef' - se `true' fará com que a versão Maxima de uma
     função  usuário permaneça quando a função é traduzida com
     `translate'.  Isso permite a que definição seja mostrada por
     `dispfun' e autoriza a função a ser editada.

     `transrun' - se `false' fará com que a versão interpretada de
     todas as funções sejam executadas (desde que estejam ainda
     disponíveis) em lugar da versão traduzida.

     O resultado retornado por `translate' é uma lista de nomes de
     funções traduzidas.


 -- Função: translate_file (<maxima_nomearquivo>)
 -- Função: translate_file (<maxima_nomearquivo>, <lisp_nomearquivo>)
     Traduz um arquivo com código Maxima para um arquivo com código
     Lisp.  `translate_file' retorna uma lista de três nomes de arquivo:
     O nome do arquivo Maxima, o nome do arquivo Lisp, e o nome do
     arquivo contendo informações adicionais sobre a tradução.
     `translate_file' avalia seus argumentos.

     `translate_file ("foo.mac"); load("foo.LISP")' é o mesmo que
     `batch ("foo.mac")' exceto por certas restrições, o uso de `''' e
     `%', por exemplo.

     `translate_file (<maxima_nomearquivo>)' traduz um arquivo Maxima
     <maxima_nomearquivo> para um similarmente chamado arquivo Lisp.
     Por exemplo, `foo.mac' é traduzido em `foo.LISP'.  O nome de
     arquivo Maxima pod incluir nome ou nomes de diretório(s), nesse
     caso o arquivo de saída Lisp é escrito para o mesmo diretório que
     a entrada Maxima.

     `translate_file (<maxima_nomearquivo>, <lisp_nomearquivo>)' traduz
     um arquivo Maxima <maxima_nomearquivo> em um arquivo Lisp
     <lisp_nomearquivo>.  `translate_file' ignora a extensão do nome do
     arquivo, se qualquer, de `lisp_nomearquivo'; a extensão do arquivo
     de saída Lisp é sempre `LISP'.  O nome de arquivo Lisp pode
     incluir um nome ou nomes de diretórios), nesse caso o arquivo de
     saída Lisp é escrito para o diretório especificado.

     `translate_file' também escreve um arquivo de mensagens de alerta
     do tradutor em vários graus de severidade.  A extensão do nome de
     arquivo desse arquivo é `UNLISP'.  Esse arquivo pode conter
     informação valiosa, apesar de possivelmente obscura, para rastrear
     erros no código traduzido.  O arquivo `UNLISP' é sempre escrito
     para o mesmo diretório que a entrada Maxima.

     `translate_file' emite código Lisp o qual faz com que algumas
     definições tenham efeito tão logo o código Lisp é compilado.  Veja
     `compile_file' para mais sobre esse tópico.

     Veja também `tr_array_as_ref', `tr_bound_function_applyp',
     `tr_exponent', `tr_file_tty_messagesp',
     `tr_float_can_branch_complex', `tr_function_call_default',
     `tr_numer', `tr_optimize_max_loop', `tr_semicompile',
     `tr_state_vars', `tr_warnings_get', `tr_warn_bad_function_calls',
     `tr_warn_fexpr', `tr_warn_meval', `tr_warn_mode',
     `tr_warn_undeclared', `tr_warn_undefined_variable', and `tr_windy'.


 -- Variável de opção: transrun
     Valor padrão: `true'

     Quando `transrun' é `false' fará com que a versão interpretada de
     todas as funções sejam executadas (desde que estejam ainda
     disponíveis) em lugar de versão traduzidas.


 -- Variável de opção: tr_array_as_ref
     Valor padrão: `true'

     Se `translate_fast_arrays' for `false', referências a arrays no
     Código Lisp emitidas por `translate_file' são afetadas por
     `tr_array_as_ref'.  Quando `tr_array_as_ref' é `true', nomes de
     arrays são avaliados, de outra forma nomes de arrays aparecem como
     símbolos literais no código traduzido.

     `tr_array_as_ref' não terão efeito se `translate_fast_arrays' for
     `true'.


 -- Variável de opção: tr_bound_function_applyp
     Valor padrão: `true'

     Quando `tr_bound_function_applyp' for `true', Maxima emite um
     alerta se uma associação de variável (tal como um argumento de
     função) é achada sendo usada como uma função.
     +`tr_bound_function_applyp' não afeta o código gerado em tais
     casos.

     Por exemplo, uma expressão tal como `g (f, x) := f (x+1)' irá
     disparar a mensagem de alerta.


 -- Variável de opção: tr_file_tty_messagesp
     Valor padrão: `false'

     Quando `tr_file_tty_messagesp' é `true', messagens geradas por
     `translate_file' durante a tradução de um arquivo são mostradas
     sobre o console e inseridas dentro do arquivo UNLISP.  Quando
     `false', messagens sobre traduções de arquivos são somente
     inseridas dentro do arquivo UNLISP.


 -- Variável de opção: tr_float_can_branch_complex
     Valor padrão: `true'

     Diz ao tradutor Maxima-para-Lisp assumir que as funções `acos',
     `asin', `asec', e `acsc' podem retornar resultados complexos.

     O efeito ostensivo de `tr_float_can_branch_complex' é mostrado
     adiante.  Todavia, parece que esse sinalizador não tem efeito
     sobre a saída do tradutor.

     Quando isso for `true' então `acos(x)' será do modo `any' sempre
     que `x' for do modo `float' (como escolhido por `mode_declare').
     Quando `false' então `acos(x)' será do modo `float' se e somente
     se `x' for do modo `float'.


 -- Variável de opção: tr_function_call_default
     Valor padrão: `general'

     `false' significa abandonando e chamando `meval', `expr' significa
     que Lisp assume função de argumento fixado.  `general', o código
     padrão dado como sendo bom para `mexprs' e `mlexprs' mas não
     `macros'.  `general' garante que associações de variável são
     corretas em códigos compilados.  No modo `general', quando
     traduzindo F(X), se F for uma variável associada, então isso
     assumirá que `apply (f, [x])' é significativo, e traduz como tal,
     com o alerta apropriado.  Não é necessário desabilitar isso.  Com
     as escolhas padrão, sem mensagens de alerta implica
     compatibilidade total do código traduzido e compilado com o
     interpretador Maxima.


 -- Variável de opção: tr_numer
     Valor padrão: `false'

     Quando `tr_numer' for `true' propriedades `numer' são usadas para
     átomos que possuem essa propriedade, e.g. `%pi'.


 -- Variável de opção: tr_optimize_max_loop
     Valor padrão: 100

     `tr_optimize_max_loop' é número máximo de vezes do passo de
     macro-expansão e otimização que o tradutor irá executar
     considerando uma forma.  Isso é para capturar erros de expansão de
     macro, e propriedades de otimização não terminadas.


 -- Variável de opção: tr_semicompile
     Valor padrão: `false'

     Quando `tr_semicompile' for `true', as formas de saída de
     `translate_file' e `compfile' serão macroexpandidas mas não
     compiladas em código de máquina pelo compilador Lisp.


 -- Variável de sistema: tr_state_vars
     Valor padrão:
          [transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
          tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
          tr_function_call_default, tr_array_as_ref,tr_numer]

     A lista de comutadores que afetam a forma de saída da tradução.
     Essa informação é útil para sistemas populares quando tentam
     depurar o tradutor.  Comparando o produto traduzido para o qual
     pode ter sido produzido por um dado estado, isso é possível para
     rastrear erros.


 -- Função: tr_warnings_get ()
     Imprime uma lista de alertas que podem ter sido dadas pelo
     tradutor durante a tradução corrente.


 -- Variável de opção: tr_warn_bad_function_calls
     Valor padrão: `true'

     - Emite um alerta quando chamadas de função estão sendo feitas por
     um caminho que pode não ser correto devido a declarações
     impróprias que foram feitas em tempo de tradução.


 -- Variável de opção: tr_warn_fexpr
     Valor padrão: `compfile'

     - Emite um alerta se quaisquer FEXPRs forem encontradas.  FEXPRs
     não poderão normalmente ser saída em código traduzido, todas as
     formas de programa especial legítimo são traduzidas.


 -- Variável: tr_warn_meval
     Valor padrão: `compfile'

     - Emite um alerta se a função `meval' recebe chamadas.  Se `meval'
     é chamada isso indica problemas na tradução.


 -- Variável: tr_warn_mode
     Valor padrão: `all'

     - Emite um alerta quando a variáveis forem atribuídos valores
     inapropriados para seu modo.


 -- Variável de opção: tr_warn_undeclared
     Valor padrão: `compile'

     - Determina quando enviar alertas sobre variáveis não declaradas
     para o TTY.


 -- Variável de opção: tr_warn_undefined_variable
     Valor padrão: `all'

     - Emite um alerta quando variáveis globais indefinidas forem
     vistas.


 -- Variável de opção: tr_windy
     Valor padrão: `true'

     - Gera comentários "de grande ajuda" e dicas de programação.


 -- Função: compile_file (<nomearquivo>)
 -- Função: compile_file (<nomearquivo>, <nomearquivo_compilado>)
 -- Função: compile_file (<nomearquivo>, <nomearquivo_compilado>,
          <lisp_nomearquivo>)
     Traduz o arquivo Maxima <nomearquivo> para Lisp, executa o
     compilador Lisp, e, se a tradução e a compilação obtiverem
     sucesso, chama o código compilado dentro do Maxima.

     `compile_file' retorna uma lista dos nomes de quatro arquivos: o
     arquivo original do Maxima, o nome da tradução Lisp, uma arquivo
     de notas sobre a tradução, e o nome do arquivo que contém o código
     compilado.  Se a compilação falhar, o quarto item é `false'.

     Algumas declarações e definições passam a ter efeito tão logo o
     código Lisp seja compilado (sem que seja necessário chamar o
     código compilado).  Isso inclui funções definidas com o operador
     `:=', macros definidas com o operador `::=', `alias', `declare',
     `define_variable',  `mode_declare', e `infix', `matchfix',
     `nofix', `postfix', `prefix', e `compfile'.

     Atribuições e chamadas de função não serão avaliadas até que o
     código compilado seja carregado.  Em particular, dentro do arquivo
     Maxima, atribuições para sinalizadores traduzidos (`tr_numer',
     etc.) não têm efeito sobre a tradução.

     <nomearquivo> pode não conter declarações `:lisp'.

     `compile_file' avalia seus argumentos.


 -- Função: declare_translated (<f_1>, <f_2>, ...)
     Quando traduzindo um arquivo do código Maxima para Lisp, é
     importante para o programa tradutor saber quais funções no arquivo
     são para serem chamadas como funções traduzidas ou compiladas, e
     quais outras são apenas funções Maxima ou indefinidas.  Colocando
     essa declaração no topo do arquivo, faremos conhecido que embora
     um símbolo diga que não temos ainda um valor de função Lisp,
     teremos uma em tempo de chamada.  `(MFUNCTION-CALL fn arg1 arg2
     ...)' é gerado quando o tradutor n~ao sabe que `fn' está sendo
     compilada para ser uma função Lisp.



File: maxima.info,  Node: Fluxo de Programa,  Next: Depurando,  Prev: Definição de Função,  Up: Top

40 Fluxo de Programa
********************

* Menu:

* Introdução a Fluxo de Programa::
* Funções e Variáveis Definidas para Fluxo de Programa::


File: maxima.info,  Node: Introdução a Fluxo de Programa,  Next: Funções e Variáveis Definidas para Fluxo de Programa,  Prev: Fluxo de Programa,  Up: Fluxo de Programa

40.1 Introdução a Fluxo de Programa
===================================

Maxima fornece um `do' para ciclos iterativos, também contruções mais
primitivas tais como `go'.



Local Variables:
coding: iso-8859-1
End:
