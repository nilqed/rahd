;;;
;;; ECDB: Extended Clause Database System
;;; Tables of RAHD-generated clauses and exporting functions.
;;;
;;; ** The set of core DB functions **
;;;
;;;     Database creation, saving, loading, and erasing. 
;;;     Table creation, initialization, and deletion.
;;;     Data row initialization, and addition in a given table.
;;;     Database querying.
;;;
;;;     This code initially inspired by examples in Peter Seibel's
;;;     "Practical Common Lisp".
;;;
;;; Written by Florent Kirchner
;;; Postdoctoral Researcher, INRIA Rennes - Bretagne Atlantique, France
;;; Contact: florent.kirchner@lix.polytechnique.fr, www.lix.polytechnique.fr/~fkirchner
;;; 
;;; This file: began on         march-2-2010,
;;;            last updated on  november-2-2010.
;;;

;;;
;;; Create the ECDB package, with a requirement on the usocket package. Make it
;;; our current home.
;;;

(require :usocket)
(defpackage :ECDB (:use :common-lisp :usocket :rahd #+allegro :excl))
(in-package ECDB)

;;;
;;; Current version of the ECDB
;;;

(defparameter *ecdb-version* "v0.1")

;;;
;;; ECDB debug flag.
;;;     Allows the foreign tools to send Lisp commands.
;;;

(defconstant +ecdb-debug+ t) ; TODO: Set to nil before release.

;;;
;;; ECDB-REBOOT: Compile and reload all files in the system
;;;

(defun ecdb-reboot (&key hands-off-state)
  (rahd::compile-file-and-load
    "exporter"
    "ecdbinterpreter"
    "ecdbsocketeer"
    "ecdb")
  (if (not hands-off-state) (drop-db))
  (format t "~%[ECDB-REBOOT]: ECDB ~D successfully rebooted" *ecdb-version*)
  t)

;;;
;;; *DB*: The current database
;;;

(defparameter *db* (make-hash-table))

;;;
;;; MAKE-CLAUSE: Generate a row of a clause table. The row takes the form of a
;;; property list (PLIST), and includes the following properties:
;;;     CASE-ID     A case identifier, of the form (\d\.)*\d, e.g., 0.4.3
;;;     GOAL-KEY    A unique identifier of the parent goal
;;;     C           The case itself, as a list of literals, 
;;;                 e.g., (A B C) <-> A /\ B /\ C
;;;     CMF         The CMF used by RAHD to solve the case
;;;     CERT        A certificate for the CMF---generated by the prover, by
;;;                 RAHD, or a third-party. This should be a property list.
;;;     STATUS      The status of the case after the CMF application, as
;;;                 documented by RAHD (:UNKNOWN, :SAT, :UNSAT, :DISCHARGED-BY-SUBGOAL)
;;;

(defun make-clause-row (case-id goal-key c cmf cert status)
  (list :case-id case-id 
        :goal-key goal-key
        :c c 
        :cmf cmf 
        :cert cert 
        :status status))

;;;
;;; MAKE-TABLE: a table is a CONS of a formula, which is used as an identifier,
;;; and of a list of clause rows (cf. MAKE-CLAUSE-ROW).
;;;

(defun make-table (formula clause-row-list)
  (assert (listp clause-row-list) () 
          "ECDB.MAKE-TABLE: Clause ~A is not a list." clause-row-list)
  (cons formula clause-row-list))

;;;
;;; PUSH-CLAUSE-ROW: Given a clause row and a formula, add the row to the table
;;; identified by the formula. If the formula isn't in the database, then add
;;; it before pushing the row.
;;;

(defun push-clause-row (clause-row formula)
  (if (not (gethash formula *db*))
    (init-table formula))
  (let* ((tbl (gethash formula *db*))
         (new-tbl (push clause-row tbl)))
    (setf (gethash formula *db*) new-tbl)
    t))

;;;
;;; PUSH-TABLE and INIT-TABLE both add a new table (an CONS of a formula
;;; identifier and a list of extended clauses---see MAKE-CLAUSE-ROW) into the
;;; database.
;;;

(defun push-table (table)
  (let ((f (car table)))
    (assert (not (gethash f *db*)) () 
            "ECDB.PUSH-TABLE: Formula name ~A is already in the database." (car table))
    (setf (gethash f *db*) (cdr table))))

(defun init-table (formula)
  (let ((tbl (make-table formula 'nil)))
    (push-table tbl)))

;;;
;;; DROP-TABLE and DROP-DB respectively delete a table based on its formula
;;; identifier, and clear the whole database.
;;;

(defun drop-table (formula)
  (remhash formula *db*))

(defun drop-db ()
  (clrhash *db*))

;;;
;;; DUMP-EC: Pretty-print the contents of an extended clause (ie, a clause row).
;;;

(defun dump-ec (clause)
  (let ((translate
          (cond ((eq *ecdb-dialect* 'coq) #'make-coq-clause)
                (t #'(lambda (x) x)))))
    (princ (format nil "~a:~15t~a~%" :case-id (getf clause :case-id)))
    (princ (format nil "~a:~15t~a~%" :goal-key (getf clause :goal-key)))
    (princ (format nil "~a:~15t~a~%" :c (funcall translate (getf clause :c))))
    (princ (format nil "~a:~15t~a~%" :cmf (getf clause :cmf)))
    (princ (format nil "~a:~15t~a~%" :cert (getf clause :cert)))
    (princ (format nil "~a:~15t~a~%" :status (getf clause :status)))))

;;;
;;; DUMP-TABLE: Pretty-print the contents of a table (ie, a list of clause rows).
;;;

(defun dump-table (table)
  (dolist (clause table)
    (format t "----~%")
    (dump-ec clause)))

;;;
;;; DUMP-DB: Pretty-print the contents of the database.
;;;

(defun print-header (title)
  (format t "~a ~a ~a~%"
          (make-string 4 :initial-element #\-)
          title
          (make-string (- rahd::*terminal-width* (length title) 6) :initial-element #\-)))

(defun dump-db-keys ()
  (maphash #'(lambda (formula clause-tbl)
               (declare (ignore clause-tbl))
               (format t "~a~%" formula))
           *db*))

(defun dump-db ()
  (maphash #'(lambda (formula clause-tbl)
               (format t "----~%")
               (print-header "Table")
               (print-header (format nil "FORMULA: ~a" formula))
               (dump-table clause-tbl))
           *db*))

;;;
;;; SAVE-DB and LOAD-DB: Saving and loading the database. This is done by
;;; standardized printing and reading from a file.
;;;

(defun save-db (filename)
  (with-open-file (out filename :direction :output :if-exists :supersede)
    (with-standard-io-syntax (print *db* out))))

(defun load-db (filename)
  (with-open-file (in filename)
    (with-standard-io-syntax (setf *db* (read in)))))

;;;
;;; SELECT-IN: the DB querying function. 
;;;
;;; E.g. (select-in 'f1 (where :case-id '1.2.4 :cert 'cert1))
;;;

(defun select-in (formula selector-fn)
  (remove-if-not selector-fn (gethash formula *db*)))

(defmacro where (&rest q)
  `#'(lambda (clause-row) (and ,@(make-queries-list q))))

(defun make-queries-list (fields)
  (loop 
    :while fields
    :collect `(equal (getf clause-row ,(pop fields)) ,(pop fields))))

(defun print-from (formula selector-fn)
  (dump-table (select-in formula selector-fn)))

;;;
;;; Examples
;;;

(defun test-db ()
  (let ((case1 
         (make-clause-row '1.2.4 1 '(A B C) 'CMF1 'CERT1 'UK))
        (case2 
         (make-clause-row '1.2.4 '2 '(D) 'CMF2 'CERT2 'SAT)))
       (init-table 'f1)
       (push-clause-row case1 'f1)
       (push-clause-row case2 'f1)
       (push-table (make-table 'f2 `(,case1 ,case2)))
       (select-in 'f1 (where :case-id '1.2.4 :cert 'cert1))))

;;; Connection testing.
;;; Launch with: 
#+()
(load "rahd.lisp")
#+()
(in-package rahd)
#+()
(rahd-reboot)
#+()
(load "ecdb.lisp")
#+()
(in-package ecdb)
#+()
(ecdb-reboot)
;;; Then run the main loop:
#+()
(serve)
;;; Finally, in a separate window, launch the sample client:
;;;  python ecdbclient.py
;;; Tell the ecdb that it should process coq formulas:
#+()
(setq *ecdb-dialect* 'coq)
;;; And input a RAHD formula
#+()
'((= x 1) (> x 1) (< x 1))

; Hints on how to daemonize SBCL instance:
; http://stackoverflow.com/questions/2458805/nohup-sbcl-ubuntu-couldnt-read-from-standard-input
